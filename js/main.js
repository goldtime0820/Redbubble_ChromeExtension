; window.Modernizr = function (a, b, c) {
    function C(a) {
        j.cssText = a
    }
    function D(a, b) {
        return C(n.join(a + ";") + (b || ""))
    }
    function E(a, b) {
        return typeof a === b
    }
    function F(a, b) {
        return !!~("" + a).indexOf(b)
    }
    function G(a, b) {
        for (var d in a) {
            var e = a[d];
            if (!F(e, "-") && j[e] !== c)
                return b == "pfx" ? e : !0
        }
        return !1
    }
    function H(a, b, d) {
        for (var e in a) {
            var f = b[a[e]];
            if (f !== c)
                return d === !1 ? a[e] : E(f, "function") ? f.bind(d || b) : f
        }
        return !1
    }
    function I(a, b, c) {
        var d = a.charAt(0).toUpperCase() + a.slice(1)
            , e = (a + " " + p.join(d + " ") + d).split(" ");
        return E(b, "string") || E(b, "undefined") ? G(e, b) : (e = (a + " " + q.join(d + " ") + d).split(" "),
            H(e, b, c))
    }
    function J() {
        e.input = function (c) {
            for (var d = 0, e = c.length; d < e; d++)
                u[c[d]] = c[d] in k;
            return u.list && (u.list = !!b.createElement("datalist") && !!a.HTMLDataListElement),
                u
        }("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")),
            e.inputtypes = function (a) {
                for (var d = 0, e, f, h, i = a.length; d < i; d++)
                    k.setAttribute("type", f = a[d]),
                        e = k.type !== "text",
                        e && (k.value = l,
                            k.style.cssText = "position:absolute;visibility:hidden;",
                            /^range$/.test(f) && k.style.WebkitAppearance !== c ? (g.appendChild(k),
                                h = b.defaultView,
                                e = h.getComputedStyle && h.getComputedStyle(k, null).WebkitAppearance !== "textfield" && k.offsetHeight !== 0,
                                g.removeChild(k)) : /^(search|tel)$/.test(f) || (/^(url|email)$/.test(f) ? e = k.checkValidity && k.checkValidity() === !1 : e = k.value != l)),
                        t[a[d]] = !!e;
                return t
            }("search tel url email datetime date month week time datetime-local number range color".split(" "))
    }
    var d = "2.7.1", e = {}, f = !0, g = b.documentElement, h = "modernizr", i = b.createElement(h), j = i.style, k = b.createElement("input"), l = ":)", m = {}.toString, n = " -webkit- -moz- -o- -ms- ".split(" "), o = "Webkit Moz O ms", p = o.split(" "), q = o.toLowerCase().split(" "), r = {
        svg: "http://www.w3.org/2000/svg"
    }, s = {}, t = {}, u = {}, v = [], w = v.slice, x, y = function (a, c, d, e) {
        var f, i, j, k, l = b.createElement("div"), m = b.body, n = m || b.createElement("body");
        if (parseInt(d, 10))
            while (d--)
                j = b.createElement("div"),
                    j.id = e ? e[d] : h + (d + 1),
                    l.appendChild(j);
        return f = ["&#173;", '<style id="s', h, '">', a, "</style>"].join(""),
            l.id = h,
            (m ? l : n).innerHTML += f,
            n.appendChild(l),
            m || (n.style.background = "",
                n.style.overflow = "hidden",
                k = g.style.overflow,
                g.style.overflow = "hidden",
                g.appendChild(n)),
            i = c(l, a),
            m ? l.parentNode.removeChild(l) : (n.parentNode.removeChild(n),
                g.style.overflow = k),
            !!i
    }, z = function () {
        function d(d, e) {
            e = e || b.createElement(a[d] || "div"),
                d = "on" + d;
            var f = d in e;
            return f || (e.setAttribute || (e = b.createElement("div")),
                e.setAttribute && e.removeAttribute && (e.setAttribute(d, ""),
                    f = E(e[d], "function"),
                    E(e[d], "undefined") || (e[d] = c),
                    e.removeAttribute(d))),
                e = null,
                f
        }
        var a = {
            select: "input",
            change: "input",
            submit: "form",
            reset: "form",
            error: "img",
            load: "img",
            abort: "img"
        };
        return d
    }(), A = {}.hasOwnProperty, B;
    !E(A, "undefined") && !E(A.call, "undefined") ? B = function (a, b) {
        return A.call(a, b)
    }
        : B = function (a, b) {
            return b in a && E(a.constructor.prototype[b], "undefined")
        }
        ,
        Function.prototype.bind || (Function.prototype.bind = function (b) {
            var c = this;
            if (typeof c != "function")
                throw new TypeError;
            var d = w.call(arguments, 1)
                , e = function () {
                    if (this instanceof e) {
                        var a = function () { };
                        a.prototype = c.prototype;
                        var f = new a
                            , g = c.apply(f, d.concat(w.call(arguments)));
                        return Object(g) === g ? g : f
                    }
                    return c.apply(b, d.concat(w.call(arguments)))
                };
            return e
        }
        ),
        s.flexbox = function () {
            return I("flexWrap")
        }
        ,
        s.flexboxlegacy = function () {
            return I("boxDirection")
        }
        ,
        s.canvas = function () {
            var a = b.createElement("canvas");
            return !!a.getContext && !!a.getContext("2d")
        }
        ,
        s.canvastext = function () {
            return !!e.canvas && !!E(b.createElement("canvas").getContext("2d").fillText, "function")
        }
        ,
        s.webgl = function () {
            return !!a.WebGLRenderingContext
        }
        ,
        s.touch = function () {
            var c;
            return "ontouchstart" in a || a.DocumentTouch && b instanceof DocumentTouch ? c = !0 : y(["@media (", n.join("touch-enabled),("), h, ")", "{#modernizr{top:9px;position:absolute}}"].join(""), function (a) {
                c = a.offsetTop === 9
            }),
                c
        }
        ,
        s.geolocation = function () {
            return "geolocation" in navigator
        }
        ,
        s.postmessage = function () {
            return !!a.postMessage
        }
        ,
        s.websqldatabase = function () {
            return !!a.openDatabase
        }
        ,
        s.indexedDB = function () {
            return !!I("indexedDB", a)
        }
        ,
        s.hashchange = function () {
            return z("hashchange", a) && (b.documentMode === c || b.documentMode > 7)
        }
        ,
        s.history = function () {
            return !!a.history && !!history.pushState
        }
        ,
        s.draganddrop = function () {
            var a = b.createElement("div");
            return "draggable" in a || "ondragstart" in a && "ondrop" in a
        }
        ,
        s.websockets = function () {
            return "WebSocket" in a || "MozWebSocket" in a
        }
        ,
        s.rgba = function () {
            return C("background-color:rgba(150,255,150,.5)"),
                F(j.backgroundColor, "rgba")
        }
        ,
        s.hsla = function () {
            return C("background-color:hsla(120,40%,100%,.5)"),
                F(j.backgroundColor, "rgba") || F(j.backgroundColor, "hsla")
        }
        ,
        s.multiplebgs = function () {
            return C("background:url(https://),url(https://),red url(https://)"),
                /(url\s*\(.*?){3}/.test(j.background)
        }
        ,
        s.backgroundsize = function () {
            return I("backgroundSize")
        }
        ,
        s.borderimage = function () {
            return I("borderImage")
        }
        ,
        s.borderradius = function () {
            return I("borderRadius")
        }
        ,
        s.boxshadow = function () {
            return I("boxShadow")
        }
        ,
        s.textshadow = function () {
            return b.createElement("div").style.textShadow === ""
        }
        ,
        s.opacity = function () {
            return D("opacity:.55"),
                /^0.55$/.test(j.opacity)
        }
        ,
        s.cssanimations = function () {
            return I("animationName")
        }
        ,
        s.csscolumns = function () {
            return I("columnCount")
        }
        ,
        s.cssgradients = function () {
            var a = "background-image:"
                , b = "gradient(linear,left top,right bottom,from(#9f9),to(white));"
                , c = "linear-gradient(left top,#9f9, white);";
            return C((a + "-webkit- ".split(" ").join(b + a) + n.join(c + a)).slice(0, -a.length)),
                F(j.backgroundImage, "gradient")
        }
        ,
        s.cssreflections = function () {
            return I("boxReflect")
        }
        ,
        s.csstransforms = function () {
            return !!I("transform")
        }
        ,
        s.csstransforms3d = function () {
            var a = !!I("perspective");
            return a && "webkitPerspective" in g.style && y("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}", function (b, c) {
                a = b.offsetLeft === 9 && b.offsetHeight === 3
            }),
                a
        }
        ,
        s.csstransitions = function () {
            return I("transition")
        }
        ,
        s.fontface = function () {
            var a;
            return y('@font-face {font-family:"font";src:url("https://")}', function (c, d) {
                var e = b.getElementById("smodernizr")
                    , f = e.sheet || e.styleSheet
                    , g = f ? f.cssRules && f.cssRules[0] ? f.cssRules[0].cssText : f.cssText || "" : "";
                a = /src/i.test(g) && g.indexOf(d.split(" ")[0]) === 0
            }),
                a
        }
        ,
        s.generatedcontent = function () {
            var a;
            return y(["#", h, "{font:0/0 a}#", h, ':after{content:"', l, '";visibility:hidden;font:3px/1 a}'].join(""), function (b) {
                a = b.offsetHeight >= 3
            }),
                a
        }
        ,
        s.video = function () {
            var a = b.createElement("video")
                , c = !1;
            try {
                if (c = !!a.canPlayType)
                    c = new Boolean(c),
                        c.ogg = a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, ""),
                        c.h264 = a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, ""),
                        c.webm = a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "")
            } catch (d) { }
            return c
        }
        ,
        s.audio = function () {
            var a = b.createElement("audio")
                , c = !1;
            try {
                if (c = !!a.canPlayType)
                    c = new Boolean(c),
                        c.ogg = a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        c.mp3 = a.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                        c.wav = a.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
                        c.m4a = (a.canPlayType("audio/x-m4a;") || a.canPlayType("audio/aac;")).replace(/^no$/, "")
            } catch (d) { }
            return c
        }
        ,
        s.localstorage = function () {
            try {
                return localStorage.setItem(h, h),
                    localStorage.removeItem(h),
                    !0
            } catch (a) {
                return !1
            }
        }
        ,
        s.sessionstorage = function () {
            try {
                return sessionStorage.setItem(h, h),
                    sessionStorage.removeItem(h),
                    !0
            } catch (a) {
                return !1
            }
        }
        ,
        s.webworkers = function () {
            return !!a.Worker
        }
        ,
        s.applicationcache = function () {
            return !!a.applicationCache
        }
        ,
        s.svg = function () {
            return !!b.createElementNS && !!b.createElementNS(r.svg, "svg").createSVGRect
        }
        ,
        s.inlinesvg = function () {
            var a = b.createElement("div");
            return a.innerHTML = "<svg/>",
                (a.firstChild && a.firstChild.namespaceURI) == r.svg
        }
        ,
        s.smil = function () {
            return !!b.createElementNS && /SVGAnimate/.test(m.call(b.createElementNS(r.svg, "animate")))
        }
        ,
        s.svgclippaths = function () {
            return !!b.createElementNS && /SVGClipPath/.test(m.call(b.createElementNS(r.svg, "clipPath")))
        }
        ;
    for (var K in s)
        B(s, K) && (x = K.toLowerCase(),
            e[x] = s[K](),
            v.push((e[x] ? "" : "no-") + x));
    return e.input || J(),
        e.addTest = function (a, b) {
            if (typeof a == "object")
                for (var d in a)
                    B(a, d) && e.addTest(d, a[d]);
            else {
                a = a.toLowerCase();
                if (e[a] !== c)
                    return e;
                b = typeof b == "function" ? b() : b,
                    typeof f != "undefined" && f && (g.className += " " + (b ? "" : "no-") + a),
                    e[a] = b
            }
            return e
        }
        ,
        C(""),
        i = k = null,
        function (a, b) {
            function l(a, b) {
                var c = a.createElement("p")
                    , d = a.getElementsByTagName("head")[0] || a.documentElement;
                return c.innerHTML = "x<style>" + b + "</style>",
                    d.insertBefore(c.lastChild, d.firstChild)
            }
            function m() {
                var a = s.elements;
                return typeof a == "string" ? a.split(" ") : a
            }
            function n(a) {
                var b = j[a[h]];
                return b || (b = {},
                    i++ ,
                    a[h] = i,
                    j[i] = b),
                    b
            }
            function o(a, c, d) {
                c || (c = b);
                if (k)
                    return c.createElement(a);
                d || (d = n(c));
                var g;
                return d.cache[a] ? g = d.cache[a].cloneNode() : f.test(a) ? g = (d.cache[a] = d.createElem(a)).cloneNode() : g = d.createElem(a),
                    g.canHaveChildren && !e.test(a) && !g.tagUrn ? d.frag.appendChild(g) : g
            }
            function p(a, c) {
                a || (a = b);
                if (k)
                    return a.createDocumentFragment();
                c = c || n(a);
                var d = c.frag.cloneNode()
                    , e = 0
                    , f = m()
                    , g = f.length;
                for (; e < g; e++)
                    d.createElement(f[e]);
                return d
            }
            function q(a, b) {
                b.cache || (b.cache = {},
                    b.createElem = a.createElement,
                    b.createFrag = a.createDocumentFragment,
                    b.frag = b.createFrag()),
                    a.createElement = function (c) {
                        return s.shivMethods ? o(c, a, b) : b.createElem(c)
                    }
                    ,
                    a.createDocumentFragment = Function("h,f", "return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(" + m().join().replace(/[\w\-]+/g, function (a) {
                        return b.createElem(a),
                            b.frag.createElement(a),
                            'c("' + a + '")'
                    }) + ");return n}")(s, b.frag)
            }
            function r(a) {
                a || (a = b);
                var c = n(a);
                return s.shivCSS && !g && !c.hasCSS && (c.hasCSS = !!l(a, "article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),
                    k || q(a, c),
                    a
            }
            var c = "3.7.0", d = a.html5 || {}, e = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i, f = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i, g, h = "_html5shiv", i = 0, j = {}, k;
            (function () {
                try {
                    var a = b.createElement("a");
                    a.innerHTML = "<xyz></xyz>",
                        g = "hidden" in a,
                        k = a.childNodes.length == 1 || function () {
                            b.createElement("a");
                            var a = b.createDocumentFragment();
                            return typeof a.cloneNode == "undefined" || typeof a.createDocumentFragment == "undefined" || typeof a.createElement == "undefined"
                        }()
                } catch (c) {
                    g = !0,
                        k = !0
                }
            }
            )();
            var s = {
                elements: d.elements || "abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",
                version: c,
                shivCSS: d.shivCSS !== !1,
                supportsUnknownElements: k,
                shivMethods: d.shivMethods !== !1,
                type: "default",
                shivDocument: r,
                createElement: o,
                createDocumentFragment: p
            };
            a.html5 = s,
                r(b)
        }(this, b),
        e._version = d,
        e._prefixes = n,
        e._domPrefixes = q,
        e._cssomPrefixes = p,
        e.hasEvent = z,
        e.testProp = function (a) {
            return G([a])
        }
        ,
        e.testAllProps = I,
        e.testStyles = y,
        g.className = g.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") + (f ? " js " + v.join(" ") : ""),
        e
}(this, this.document),
    function (a, b, c) {
        function d(a) {
            return "[object Function]" == o.call(a)
        }
        function e(a) {
            return "string" == typeof a
        }
        function f() { }
        function g(a) {
            return !a || "loaded" == a || "complete" == a || "uninitialized" == a
        }
        function h() {
            var a = p.shift();
            q = 1,
                a ? a.t ? m(function () {
                    ("c" == a.t ? B.injectCss : B.injectJs)(a.s, 0, a.a, a.x, a.e, 1)
                }, 0) : (a(),
                    h()) : q = 0
        }
        function i(a, c, d, e, f, i, j) {
            function k(b) {
                if (!o && g(l.readyState) && (u.r = o = 1,
                    !q && h(),
                    l.onload = l.onreadystatechange = null,
                    b)) {
                    "img" != a && m(function () {
                        t.removeChild(l)
                    }, 50);
                    for (var d in y[c])
                        y[c].hasOwnProperty(d) && y[c][d].onload()
                }
            }
            var j = j || B.errorTimeout
                , l = b.createElement(a)
                , o = 0
                , r = 0
                , u = {
                    t: d,
                    s: c,
                    e: f,
                    a: i,
                    x: j
                };
            1 === y[c] && (r = 1,
                y[c] = []),
                "object" == a ? l.data = c : (l.src = c,
                    l.type = a),
                l.width = l.height = "0",
                l.onerror = l.onload = l.onreadystatechange = function () {
                    k.call(this, r)
                }
                ,
                p.splice(e, 0, u),
                "img" != a && (r || 2 === y[c] ? (t.insertBefore(l, s ? null : n),
                    m(k, j)) : y[c].push(l))
        }
        function j(a, b, c, d, f) {
            return q = 0,
                b = b || "j",
                e(a) ? i("c" == b ? v : u, a, b, this.i++, c, d, f) : (p.splice(this.i++, 0, a),
                    1 == p.length && h()),
                this
        }
        function k() {
            var a = B;
            return a.loader = {
                load: j,
                i: 0
            },
                a
        }
        var l = b.documentElement, m = a.setTimeout, n = b.getElementsByTagName("script")[0], o = {}.toString, p = [], q = 0, r = "MozAppearance" in l.style, s = r && !!b.createRange().compareNode, t = s ? l : n.parentNode, l = a.opera && "[object Opera]" == o.call(a.opera), l = !!b.attachEvent && !l, u = r ? "object" : l ? "script" : "img", v = l ? "script" : u, w = Array.isArray || function (a) {
            return "[object Array]" == o.call(a)
        }
            , x = [], y = {}, z = {
                timeout: function (a, b) {
                    return b.length && (a.timeout = b[0]),
                        a
                }
            }, A, B;
        B = function (a) {
            function b(a) {
                var a = a.split("!"), b = x.length, c = a.pop(), d = a.length, c = {
                    url: c,
                    origUrl: c,
                    prefixes: a
                }, e, f, g;
                for (f = 0; f < d; f++)
                    g = a[f].split("="),
                        (e = z[g.shift()]) && (c = e(c, g));
                for (f = 0; f < b; f++)
                    c = x[f](c);
                return c
            }
            function g(a, e, f, g, h) {
                var i = b(a)
                    , j = i.autoCallback;
                i.url.split(".").pop().split("?").shift(),
                    i.bypass || (e && (e = d(e) ? e : e[a] || e[g] || e[a.split("/").pop().split("?")[0]]),
                        i.instead ? i.instead(a, e, f, g, h) : (y[i.url] ? i.noexec = !0 : y[i.url] = 1,
                            f.load(i.url, i.forceCSS || !i.forceJS && "css" == i.url.split(".").pop().split("?").shift() ? "c" : c, i.noexec, i.attrs, i.timeout),
                            (d(e) || d(j)) && f.load(function () {
                                k(),
                                    e && e(i.origUrl, h, g),
                                    j && j(i.origUrl, h, g),
                                    y[i.url] = 2
                            })))
            }
            function h(a, b) {
                function c(a, c) {
                    if (a) {
                        if (e(a))
                            c || (j = function () {
                                var a = [].slice.call(arguments);
                                k.apply(this, a),
                                    l()
                            }
                            ),
                                g(a, j, b, 0, h);
                        else if (Object(a) === a)
                            for (n in m = function () {
                                var b = 0, c;
                                for (c in a)
                                    a.hasOwnProperty(c) && b++;
                                return b
                            }(),
                                a)
                                a.hasOwnProperty(n) && (!c && !--m && (d(j) ? j = function () {
                                    var a = [].slice.call(arguments);
                                    k.apply(this, a),
                                        l()
                                }
                                    : j[n] = function (a) {
                                        return function () {
                                            var b = [].slice.call(arguments);
                                            a && a.apply(this, b),
                                                l()
                                        }
                                    }(k[n])),
                                    g(a[n], j, b, n, h))
                    } else
                        !c && l()
                }
                var h = !!a.test, i = a.load || a.both, j = a.callback || f, k = j, l = a.complete || f, m, n;
                c(h ? a.yep : a.nope, !!i),
                    i && c(i)
            }
            var i, j, l = this.yepnope.loader;
            if (e(a))
                g(a, 0, l, 0);
            else if (w(a))
                for (i = 0; i < a.length; i++)
                    j = a[i],
                        e(j) ? g(j, 0, l, 0) : w(j) ? B(j) : Object(j) === j && h(j, l);
            else
                Object(a) === a && h(a, l)
        }
            ,
            B.addPrefix = function (a, b) {
                z[a] = b
            }
            ,
            B.addFilter = function (a) {
                x.push(a)
            }
            ,
            B.errorTimeout = 1e4,
            null == b.readyState && b.addEventListener && (b.readyState = "loading",
                b.addEventListener("DOMContentLoaded", A = function () {
                    b.removeEventListener("DOMContentLoaded", A, 0),
                        b.readyState = "complete"
                }
                    , 0)),
            a.yepnope = k(),
            a.yepnope.executeStack = h,
            a.yepnope.injectJs = function (a, c, d, e, i, j) {
                var k = b.createElement("script"), l, o, e = e || B.errorTimeout;
                k.src = a;
                for (o in d)
                    k.setAttribute(o, d[o]);
                c = j ? h : c || f,
                    k.onreadystatechange = k.onload = function () {
                        !l && g(k.readyState) && (l = 1,
                            c(),
                            k.onload = k.onreadystatechange = null)
                    }
                    ,
                    m(function () {
                        l || (l = 1,
                            c(1))
                    }, e),
                    i ? k.onload() : n.parentNode.insertBefore(k, n)
            }
            ,
            a.yepnope.injectCss = function (a, c, d, e, g, i) {
                var e = b.createElement("link"), j, c = i ? h : c || f;
                e.href = a,
                    e.rel = "stylesheet",
                    e.type = "text/css";
                for (j in d)
                    e.setAttribute(j, d[j]);
                g || (n.parentNode.insertBefore(e, n),
                    m(c, 0))
            }
    }(this, document),
    Modernizr.load = function () {
        yepnope.apply(window, [].slice.call(arguments, 0))
    }
    ;
/*! jQuery v1.11.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function (a, b) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function (a) {
        if (!a.document)
            throw new Error("jQuery requires a window with a document");
        return b(a)
    }
        : b(a)
}("undefined" != typeof window ? window : this, function (a, b) {
    var c = []
        , d = c.slice
        , e = c.concat
        , f = c.push
        , g = c.indexOf
        , h = {}
        , i = h.toString
        , j = h.hasOwnProperty
        , k = "".trim
        , l = {}
        , m = "1.11.0"
        , n = function (a, b) {
            return new n.fn.init(a, b)
        }
        , o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g
        , p = /^-ms-/
        , q = /-([\da-z])/gi
        , r = function (a, b) {
            return b.toUpperCase()
        };
    n.fn = n.prototype = {
        jquery: m,
        constructor: n,
        selector: "",
        length: 0,
        toArray: function () {
            return d.call(this)
        },
        get: function (a) {
            return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this)
        },
        pushStack: function (a) {
            var b = n.merge(this.constructor(), a);
            return b.prevObject = this,
                b.context = this.context,
                b
        },
        each: function (a, b) {
            return n.each(this, a, b)
        },
        map: function (a) {
            return this.pushStack(n.map(this, function (b, c) {
                return a.call(b, c, b)
            }))
        },
        slice: function () {
            return this.pushStack(d.apply(this, arguments))
        },
        first: function () {
            return this.eq(0)
        },
        last: function () {
            return this.eq(-1)
        },
        eq: function (a) {
            var b = this.length
                , c = +a + (0 > a ? b : 0);
            return this.pushStack(c >= 0 && b > c ? [this[c]] : [])
        },
        end: function () {
            return this.prevObject || this.constructor(null)
        },
        push: f,
        sort: c.sort,
        splice: c.splice
    },
        n.extend = n.fn.extend = function () {
            var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
            for ("boolean" == typeof g && (j = g,
                g = arguments[h] || {},
                h++),
                "object" == typeof g || n.isFunction(g) || (g = {}),
                h === i && (g = this,
                    h--); i > h; h++)
                if (null != (e = arguments[h]))
                    for (d in e)
                        a = g[d],
                            c = e[d],
                            g !== c && (j && c && (n.isPlainObject(c) || (b = n.isArray(c))) ? (b ? (b = !1,
                                f = a && n.isArray(a) ? a : []) : f = a && n.isPlainObject(a) ? a : {},
                                g[d] = n.extend(j, f, c)) : void 0 !== c && (g[d] = c));
            return g
        }
        ,
        n.extend({
            expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function (a) {
                throw new Error(a)
            },
            noop: function () { },
            isFunction: function (a) {
                return "function" === n.type(a)
            },
            isArray: Array.isArray || function (a) {
                return "array" === n.type(a)
            }
            ,
            isWindow: function (a) {
                return null != a && a == a.window
            },
            isNumeric: function (a) {
                return a - parseFloat(a) >= 0
            },
            isEmptyObject: function (a) {
                var b;
                for (b in a)
                    return !1;
                return !0
            },
            isPlainObject: function (a) {
                var b;
                if (!a || "object" !== n.type(a) || a.nodeType || n.isWindow(a))
                    return !1;
                try {
                    if (a.constructor && !j.call(a, "constructor") && !j.call(a.constructor.prototype, "isPrototypeOf"))
                        return !1
                } catch (c) {
                    return !1
                }
                if (l.ownLast)
                    for (b in a)
                        return j.call(a, b);
                for (b in a)
                    ;
                return void 0 === b || j.call(a, b)
            },
            type: function (a) {
                return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a
            },
            globalEval: function (b) {
                b && n.trim(b) && (a.execScript || function (b) {
                    a.eval.call(a, b)
                }
                )(b)
            },
            camelCase: function (a) {
                return a.replace(p, "ms-").replace(q, r)
            },
            nodeName: function (a, b) {
                return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
            },
            each: function (a, b, c) {
                var d, e = 0, f = a.length, g = s(a);
                if (c) {
                    if (g) {
                        for (; f > e; e++)
                            if (d = b.apply(a[e], c),
                                d === !1)
                                break
                    } else
                        for (e in a)
                            if (d = b.apply(a[e], c),
                                d === !1)
                                break
                } else if (g) {
                    for (; f > e; e++)
                        if (d = b.call(a[e], e, a[e]),
                            d === !1)
                            break
                } else
                    for (e in a)
                        if (d = b.call(a[e], e, a[e]),
                            d === !1)
                            break;
                return a
            },
            trim: k && !k.call("\ufeff\xa0") ? function (a) {
                return null == a ? "" : k.call(a)
            }
                : function (a) {
                    return null == a ? "" : (a + "").replace(o, "")
                }
            ,
            makeArray: function (a, b) {
                var c = b || [];
                return null != a && (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)),
                    c
            },
            inArray: function (a, b, c) {
                var d;
                if (b) {
                    if (g)
                        return g.call(b, a, c);
                    for (d = b.length,
                        c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++)
                        if (c in b && b[c] === a)
                            return c
                }
                return -1
            },
            merge: function (a, b) {
                var c = +b.length
                    , d = 0
                    , e = a.length;
                while (c > d)
                    a[e++] = b[d++];
                if (c !== c)
                    while (void 0 !== b[d])
                        a[e++] = b[d++];
                return a.length = e,
                    a
            },
            grep: function (a, b, c) {
                for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++)
                    d = !b(a[f], f),
                        d !== h && e.push(a[f]);
                return e
            },
            map: function (a, b, c) {
                var d, f = 0, g = a.length, h = s(a), i = [];
                if (h)
                    for (; g > f; f++)
                        d = b(a[f], f, c),
                            null != d && i.push(d);
                else
                    for (f in a)
                        d = b(a[f], f, c),
                            null != d && i.push(d);
                return e.apply([], i)
            },
            guid: 1,
            proxy: function (a, b) {
                var c, e, f;
                return "string" == typeof b && (f = a[b],
                    b = a,
                    a = f),
                    n.isFunction(a) ? (c = d.call(arguments, 2),
                        e = function () {
                            return a.apply(b || this, c.concat(d.call(arguments)))
                        }
                        ,
                        e.guid = a.guid = a.guid || n.guid++ ,
                        e) : void 0
            },
            now: function () {
                return +new Date
            },
            support: l
        }),
        n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (a, b) {
            h["[object " + b + "]"] = b.toLowerCase()
        });
    function s(a) {
        var b = a.length
            , c = n.type(a);
        return "function" === c || n.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a
    }
    var t = function (a) {
        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s = "sizzle" + -new Date, t = a.document, u = 0, v = 0, w = eb(), x = eb(), y = eb(), z = function (a, b) {
            return a === b && (j = !0),
                0
        }, A = "undefined", B = 1 << 31, C = {}.hasOwnProperty, D = [], E = D.pop, F = D.push, G = D.push, H = D.slice, I = D.indexOf || function (a) {
            for (var b = 0, c = this.length; c > b; b++)
                if (this[b] === a)
                    return b;
            return -1
        }
            , J = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", K = "[\\x20\\t\\r\\n\\f]", L = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", M = L.replace("w", "w#"), N = "\\[" + K + "*(" + L + ")" + K + "*(?:([*^$|!~]?=)" + K + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + M + ")|)|)" + K + "*\\]", O = ":(" + L + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + N.replace(3, 8) + ")*)|.*)\\)|)", P = new RegExp("^" + K + "+|((?:^|[^\\\\])(?:\\\\.)*)" + K + "+$", "g"), Q = new RegExp("^" + K + "*," + K + "*"), R = new RegExp("^" + K + "*([>+~]|" + K + ")" + K + "*"), S = new RegExp("=" + K + "*([^\\]'\"]*?)" + K + "*\\]", "g"), T = new RegExp(O), U = new RegExp("^" + M + "$"), V = {
                ID: new RegExp("^#(" + L + ")"),
                CLASS: new RegExp("^\\.(" + L + ")"),
                TAG: new RegExp("^(" + L.replace("w", "w*") + ")"),
                ATTR: new RegExp("^" + N),
                PSEUDO: new RegExp("^" + O),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + K + "*(even|odd|(([+-]|)(\\d*)n|)" + K + "*(?:([+-]|)" + K + "*(\\d+)|))" + K + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + J + ")$", "i"),
                needsContext: new RegExp("^" + K + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + K + "*((?:-\\d)?\\d*)" + K + "*\\)|)(?=[^-]|$)", "i")
            }, W = /^(?:input|select|textarea|button)$/i, X = /^h\d$/i, Y = /^[^{]+\{\s*\[native \w/, Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, $ = /[+~]/, _ = /'|\\/g, ab = new RegExp("\\\\([\\da-f]{1,6}" + K + "?|(" + K + ")|.)", "ig"), bb = function (a, b, c) {
                var d = "0x" + b - 65536;
                return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
            };
        try {
            G.apply(D = H.call(t.childNodes), t.childNodes),
                D[t.childNodes.length].nodeType
        } catch (cb) {
            G = {
                apply: D.length ? function (a, b) {
                    F.apply(a, H.call(b))
                }
                    : function (a, b) {
                        var c = a.length
                            , d = 0;
                        while (a[c++] = b[d++])
                            ;
                        a.length = c - 1
                    }
            }
        }
        function db(a, b, d, e) {
            var f, g, h, i, j, m, p, q, u, v;
            if ((b ? b.ownerDocument || b : t) !== l && k(b),
                b = b || l,
                d = d || [],
                !a || "string" != typeof a)
                return d;
            if (1 !== (i = b.nodeType) && 9 !== i)
                return [];
            if (n && !e) {
                if (f = Z.exec(a))
                    if (h = f[1]) {
                        if (9 === i) {
                            if (g = b.getElementById(h),
                                !g || !g.parentNode)
                                return d;
                            if (g.id === h)
                                return d.push(g),
                                    d
                        } else if (b.ownerDocument && (g = b.ownerDocument.getElementById(h)) && r(b, g) && g.id === h)
                            return d.push(g),
                                d
                    } else {
                        if (f[2])
                            return G.apply(d, b.getElementsByTagName(a)),
                                d;
                        if ((h = f[3]) && c.getElementsByClassName && b.getElementsByClassName)
                            return G.apply(d, b.getElementsByClassName(h)),
                                d
                    }
                if (c.qsa && (!o || !o.test(a))) {
                    if (q = p = s,
                        u = b,
                        v = 9 === i && a,
                        1 === i && "object" !== b.nodeName.toLowerCase()) {
                        m = ob(a),
                            (p = b.getAttribute("id")) ? q = p.replace(_, "\\$&") : b.setAttribute("id", q),
                            q = "[id='" + q + "'] ",
                            j = m.length;
                        while (j--)
                            m[j] = q + pb(m[j]);
                        u = $.test(a) && mb(b.parentNode) || b,
                            v = m.join(",")
                    }
                    if (v)
                        try {
                            return G.apply(d, u.querySelectorAll(v)),
                                d
                        } catch (w) { } finally {
                            p || b.removeAttribute("id")
                        }
                }
            }
            return xb(a.replace(P, "$1"), b, d, e)
        }
        function eb() {
            var a = [];
            function b(c, e) {
                return a.push(c + " ") > d.cacheLength && delete b[a.shift()],
                    b[c + " "] = e
            }
            return b
        }
        function fb(a) {
            return a[s] = !0,
                a
        }
        function gb(a) {
            var b = l.createElement("div");
            try {
                return !!a(b)
            } catch (c) {
                return !1
            } finally {
                b.parentNode && b.parentNode.removeChild(b),
                    b = null
            }
        }
        function hb(a, b) {
            var c = a.split("|")
                , e = a.length;
            while (e--)
                d.attrHandle[c[e]] = b
        }
        function ib(a, b) {
            var c = b && a
                , d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || B) - (~a.sourceIndex || B);
            if (d)
                return d;
            if (c)
                while (c = c.nextSibling)
                    if (c === b)
                        return -1;
            return a ? 1 : -1
        }
        function jb(a) {
            return function (b) {
                var c = b.nodeName.toLowerCase();
                return "input" === c && b.type === a
            }
        }
        function kb(a) {
            return function (b) {
                var c = b.nodeName.toLowerCase();
                return ("input" === c || "button" === c) && b.type === a
            }
        }
        function lb(a) {
            return fb(function (b) {
                return b = +b,
                    fb(function (c, d) {
                        var e, f = a([], c.length, b), g = f.length;
                        while (g--)
                            c[e = f[g]] && (c[e] = !(d[e] = c[e]))
                    })
            })
        }
        function mb(a) {
            return a && typeof a.getElementsByTagName !== A && a
        }
        c = db.support = {},
            f = db.isXML = function (a) {
                var b = a && (a.ownerDocument || a).documentElement;
                return b ? "HTML" !== b.nodeName : !1
            }
            ,
            k = db.setDocument = function (a) {
                var b, e = a ? a.ownerDocument || a : t, g = e.defaultView;
                return e !== l && 9 === e.nodeType && e.documentElement ? (l = e,
                    m = e.documentElement,
                    n = !f(e),
                    g && g !== g.top && (g.addEventListener ? g.addEventListener("unload", function () {
                        k()
                    }, !1) : g.attachEvent && g.attachEvent("onunload", function () {
                        k()
                    })),
                    c.attributes = gb(function (a) {
                        return a.className = "i",
                            !a.getAttribute("className")
                    }),
                    c.getElementsByTagName = gb(function (a) {
                        return a.appendChild(e.createComment("")),
                            !a.getElementsByTagName("*").length
                    }),
                    c.getElementsByClassName = Y.test(e.getElementsByClassName) && gb(function (a) {
                        return a.innerHTML = "<div class='a'></div><div class='a i'></div>",
                            a.firstChild.className = "i",
                            2 === a.getElementsByClassName("i").length
                    }),
                    c.getById = gb(function (a) {
                        return m.appendChild(a).id = s,
                            !e.getElementsByName || !e.getElementsByName(s).length
                    }),
                    c.getById ? (d.find.ID = function (a, b) {
                        if (typeof b.getElementById !== A && n) {
                            var c = b.getElementById(a);
                            return c && c.parentNode ? [c] : []
                        }
                    }
                        ,
                        d.filter.ID = function (a) {
                            var b = a.replace(ab, bb);
                            return function (a) {
                                return a.getAttribute("id") === b
                            }
                        }
                    ) : (delete d.find.ID,
                        d.filter.ID = function (a) {
                            var b = a.replace(ab, bb);
                            return function (a) {
                                var c = typeof a.getAttributeNode !== A && a.getAttributeNode("id");
                                return c && c.value === b
                            }
                        }
                        ),
                    d.find.TAG = c.getElementsByTagName ? function (a, b) {
                        return typeof b.getElementsByTagName !== A ? b.getElementsByTagName(a) : void 0
                    }
                        : function (a, b) {
                            var c, d = [], e = 0, f = b.getElementsByTagName(a);
                            if ("*" === a) {
                                while (c = f[e++])
                                    1 === c.nodeType && d.push(c);
                                return d
                            }
                            return f
                        }
                    ,
                    d.find.CLASS = c.getElementsByClassName && function (a, b) {
                        return typeof b.getElementsByClassName !== A && n ? b.getElementsByClassName(a) : void 0
                    }
                    ,
                    p = [],
                    o = [],
                    (c.qsa = Y.test(e.querySelectorAll)) && (gb(function (a) {
                        a.innerHTML = "<select t=''><option selected=''></option></select>",
                            a.querySelectorAll("[t^='']").length && o.push("[*^$]=" + K + "*(?:''|\"\")"),
                            a.querySelectorAll("[selected]").length || o.push("\\[" + K + "*(?:value|" + J + ")"),
                            a.querySelectorAll(":checked").length || o.push(":checked")
                    }),
                        gb(function (a) {
                            var b = e.createElement("input");
                            b.setAttribute("type", "hidden"),
                                a.appendChild(b).setAttribute("name", "D"),
                                a.querySelectorAll("[name=d]").length && o.push("name" + K + "*[*^$|!~]?="),
                                a.querySelectorAll(":enabled").length || o.push(":enabled", ":disabled"),
                                a.querySelectorAll("*,:x"),
                                o.push(",.*:")
                        })),
                    (c.matchesSelector = Y.test(q = m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) && gb(function (a) {
                        c.disconnectedMatch = q.call(a, "div"),
                            q.call(a, "[s!='']:x"),
                            p.push("!=", O)
                    }),
                    o = o.length && new RegExp(o.join("|")),
                    p = p.length && new RegExp(p.join("|")),
                    b = Y.test(m.compareDocumentPosition),
                    r = b || Y.test(m.contains) ? function (a, b) {
                        var c = 9 === a.nodeType ? a.documentElement : a
                            , d = b && b.parentNode;
                        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
                    }
                        : function (a, b) {
                            if (b)
                                while (b = b.parentNode)
                                    if (b === a)
                                        return !0;
                            return !1
                        }
                    ,
                    z = b ? function (a, b) {
                        if (a === b)
                            return j = !0,
                                0;
                        var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1,
                            1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === e || a.ownerDocument === t && r(t, a) ? -1 : b === e || b.ownerDocument === t && r(t, b) ? 1 : i ? I.call(i, a) - I.call(i, b) : 0 : 4 & d ? -1 : 1)
                    }
                        : function (a, b) {
                            if (a === b)
                                return j = !0,
                                    0;
                            var c, d = 0, f = a.parentNode, g = b.parentNode, h = [a], k = [b];
                            if (!f || !g)
                                return a === e ? -1 : b === e ? 1 : f ? -1 : g ? 1 : i ? I.call(i, a) - I.call(i, b) : 0;
                            if (f === g)
                                return ib(a, b);
                            c = a;
                            while (c = c.parentNode)
                                h.unshift(c);
                            c = b;
                            while (c = c.parentNode)
                                k.unshift(c);
                            while (h[d] === k[d])
                                d++;
                            return d ? ib(h[d], k[d]) : h[d] === t ? -1 : k[d] === t ? 1 : 0
                        }
                    ,
                    e) : l
            }
            ,
            db.matches = function (a, b) {
                return db(a, null, null, b)
            }
            ,
            db.matchesSelector = function (a, b) {
                if ((a.ownerDocument || a) !== l && k(a),
                    b = b.replace(S, "='$1']"),
                    !(!c.matchesSelector || !n || p && p.test(b) || o && o.test(b)))
                    try {
                        var d = q.call(a, b);
                        if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType)
                            return d
                    } catch (e) { }
                return db(b, l, null, [a]).length > 0
            }
            ,
            db.contains = function (a, b) {
                return (a.ownerDocument || a) !== l && k(a),
                    r(a, b)
            }
            ,
            db.attr = function (a, b) {
                (a.ownerDocument || a) !== l && k(a);
                var e = d.attrHandle[b.toLowerCase()]
                    , f = e && C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !n) : void 0;
                return void 0 !== f ? f : c.attributes || !n ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null
            }
            ,
            db.error = function (a) {
                throw new Error("Syntax error, unrecognized expression: " + a)
            }
            ,
            db.uniqueSort = function (a) {
                var b, d = [], e = 0, f = 0;
                if (j = !c.detectDuplicates,
                    i = !c.sortStable && a.slice(0),
                    a.sort(z),
                    j) {
                    while (b = a[f++])
                        b === a[f] && (e = d.push(f));
                    while (e--)
                        a.splice(d[e], 1)
                }
                return i = null,
                    a
            }
            ,
            e = db.getText = function (a) {
                var b, c = "", d = 0, f = a.nodeType;
                if (f) {
                    if (1 === f || 9 === f || 11 === f) {
                        if ("string" == typeof a.textContent)
                            return a.textContent;
                        for (a = a.firstChild; a; a = a.nextSibling)
                            c += e(a)
                    } else if (3 === f || 4 === f)
                        return a.nodeValue
                } else
                    while (b = a[d++])
                        c += e(b);
                return c
            }
            ,
            d = db.selectors = {
                cacheLength: 50,
                createPseudo: fb,
                match: V,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {
                        dir: "parentNode",
                        first: !0
                    },
                    " ": {
                        dir: "parentNode"
                    },
                    "+": {
                        dir: "previousSibling",
                        first: !0
                    },
                    "~": {
                        dir: "previousSibling"
                    }
                },
                preFilter: {
                    ATTR: function (a) {
                        return a[1] = a[1].replace(ab, bb),
                            a[3] = (a[4] || a[5] || "").replace(ab, bb),
                            "~=" === a[2] && (a[3] = " " + a[3] + " "),
                            a.slice(0, 4)
                    },
                    CHILD: function (a) {
                        return a[1] = a[1].toLowerCase(),
                            "nth" === a[1].slice(0, 3) ? (a[3] || db.error(a[0]),
                                a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])),
                                a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && db.error(a[0]),
                            a
                    },
                    PSEUDO: function (a) {
                        var b, c = !a[5] && a[2];
                        return V.CHILD.test(a[0]) ? null : (a[3] && void 0 !== a[4] ? a[2] = a[4] : c && T.test(c) && (b = ob(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b),
                            a[2] = c.slice(0, b)),
                            a.slice(0, 3))
                    }
                },
                filter: {
                    TAG: function (a) {
                        var b = a.replace(ab, bb).toLowerCase();
                        return "*" === a ? function () {
                            return !0
                        }
                            : function (a) {
                                return a.nodeName && a.nodeName.toLowerCase() === b
                            }
                    },
                    CLASS: function (a) {
                        var b = w[a + " "];
                        return b || (b = new RegExp("(^|" + K + ")" + a + "(" + K + "|$)")) && w(a, function (a) {
                            return b.test("string" == typeof a.className && a.className || typeof a.getAttribute !== A && a.getAttribute("class") || "")
                        })
                    },
                    ATTR: function (a, b, c) {
                        return function (d) {
                            var e = db.attr(d, a);
                            return null == e ? "!=" === b : b ? (e += "",
                                "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0
                        }
                    },
                    CHILD: function (a, b, c, d, e) {
                        var f = "nth" !== a.slice(0, 3)
                            , g = "last" !== a.slice(-4)
                            , h = "of-type" === b;
                        return 1 === d && 0 === e ? function (a) {
                            return !!a.parentNode
                        }
                            : function (b, c, i) {
                                var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), t = !i && !h;
                                if (q) {
                                    if (f) {
                                        while (p) {
                                            l = b;
                                            while (l = l[p])
                                                if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType)
                                                    return !1;
                                            o = p = "only" === a && !o && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (o = [g ? q.firstChild : q.lastChild],
                                        g && t) {
                                        k = q[s] || (q[s] = {}),
                                            j = k[a] || [],
                                            n = j[0] === u && j[1],
                                            m = j[0] === u && j[2],
                                            l = n && q.childNodes[n];
                                        while (l = ++n && l && l[p] || (m = n = 0) || o.pop())
                                            if (1 === l.nodeType && ++m && l === b) {
                                                k[a] = [u, n, m];
                                                break
                                            }
                                    } else if (t && (j = (b[s] || (b[s] = {}))[a]) && j[0] === u)
                                        m = j[1];
                                    else
                                        while (l = ++n && l && l[p] || (m = n = 0) || o.pop())
                                            if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (t && ((l[s] || (l[s] = {}))[a] = [u, m]),
                                                l === b))
                                                break;
                                    return m -= e,
                                        m === d || m % d === 0 && m / d >= 0
                                }
                            }
                    },
                    PSEUDO: function (a, b) {
                        var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || db.error("unsupported pseudo: " + a);
                        return e[s] ? e(b) : e.length > 1 ? (c = [a, a, "", b],
                            d.setFilters.hasOwnProperty(a.toLowerCase()) ? fb(function (a, c) {
                                var d, f = e(a, b), g = f.length;
                                while (g--)
                                    d = I.call(a, f[g]),
                                        a[d] = !(c[d] = f[g])
                            }) : function (a) {
                                return e(a, 0, c)
                            }
                        ) : e
                    }
                },
                pseudos: {
                    not: fb(function (a) {
                        var b = []
                            , c = []
                            , d = g(a.replace(P, "$1"));
                        return d[s] ? fb(function (a, b, c, e) {
                            var f, g = d(a, null, e, []), h = a.length;
                            while (h--)
                                (f = g[h]) && (a[h] = !(b[h] = f))
                        }) : function (a, e, f) {
                            return b[0] = a,
                                d(b, null, f, c),
                                !c.pop()
                        }
                    }),
                    has: fb(function (a) {
                        return function (b) {
                            return db(a, b).length > 0
                        }
                    }),
                    contains: fb(function (a) {
                        return function (b) {
                            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1
                        }
                    }),
                    lang: fb(function (a) {
                        return U.test(a || "") || db.error("unsupported lang: " + a),
                            a = a.replace(ab, bb).toLowerCase(),
                            function (b) {
                                var c;
                                do
                                    if (c = n ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang"))
                                        return c = c.toLowerCase(),
                                            c === a || 0 === c.indexOf(a + "-");
                                while ((b = b.parentNode) && 1 === b.nodeType); return !1
                            }
                    }),
                    target: function (b) {
                        var c = a.location && a.location.hash;
                        return c && c.slice(1) === b.id
                    },
                    root: function (a) {
                        return a === m
                    },
                    focus: function (a) {
                        return a === l.activeElement && (!l.hasFocus || l.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)
                    },
                    enabled: function (a) {
                        return a.disabled === !1
                    },
                    disabled: function (a) {
                        return a.disabled === !0
                    },
                    checked: function (a) {
                        var b = a.nodeName.toLowerCase();
                        return "input" === b && !!a.checked || "option" === b && !!a.selected
                    },
                    selected: function (a) {
                        return a.parentNode && a.parentNode.selectedIndex,
                            a.selected === !0
                    },
                    empty: function (a) {
                        for (a = a.firstChild; a; a = a.nextSibling)
                            if (a.nodeType < 6)
                                return !1;
                        return !0
                    },
                    parent: function (a) {
                        return !d.pseudos.empty(a)
                    },
                    header: function (a) {
                        return X.test(a.nodeName)
                    },
                    input: function (a) {
                        return W.test(a.nodeName)
                    },
                    button: function (a) {
                        var b = a.nodeName.toLowerCase();
                        return "input" === b && "button" === a.type || "button" === b
                    },
                    text: function (a) {
                        var b;
                        return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
                    },
                    first: lb(function () {
                        return [0]
                    }),
                    last: lb(function (a, b) {
                        return [b - 1]
                    }),
                    eq: lb(function (a, b, c) {
                        return [0 > c ? c + b : c]
                    }),
                    even: lb(function (a, b) {
                        for (var c = 0; b > c; c += 2)
                            a.push(c);
                        return a
                    }),
                    odd: lb(function (a, b) {
                        for (var c = 1; b > c; c += 2)
                            a.push(c);
                        return a
                    }),
                    lt: lb(function (a, b, c) {
                        for (var d = 0 > c ? c + b : c; --d >= 0;)
                            a.push(d);
                        return a
                    }),
                    gt: lb(function (a, b, c) {
                        for (var d = 0 > c ? c + b : c; ++d < b;)
                            a.push(d);
                        return a
                    })
                }
            },
            d.pseudos.nth = d.pseudos.eq;
        for (b in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        })
            d.pseudos[b] = jb(b);
        for (b in {
            submit: !0,
            reset: !0
        })
            d.pseudos[b] = kb(b);
        function nb() { }
        nb.prototype = d.filters = d.pseudos,
            d.setFilters = new nb;
        function ob(a, b) {
            var c, e, f, g, h, i, j, k = x[a + " "];
            if (k)
                return b ? 0 : k.slice(0);
            h = a,
                i = [],
                j = d.preFilter;
            while (h) {
                (!c || (e = Q.exec(h))) && (e && (h = h.slice(e[0].length) || h),
                    i.push(f = [])),
                    c = !1,
                    (e = R.exec(h)) && (c = e.shift(),
                        f.push({
                            value: c,
                            type: e[0].replace(P, " ")
                        }),
                        h = h.slice(c.length));
                for (g in d.filter)
                    !(e = V[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(),
                        f.push({
                            value: c,
                            type: g,
                            matches: e
                        }),
                        h = h.slice(c.length));
                if (!c)
                    break
            }
            return b ? h.length : h ? db.error(a) : x(a, i).slice(0)
        }
        function pb(a) {
            for (var b = 0, c = a.length, d = ""; c > b; b++)
                d += a[b].value;
            return d
        }
        function qb(a, b, c) {
            var d = b.dir
                , e = c && "parentNode" === d
                , f = v++;
            return b.first ? function (b, c, f) {
                while (b = b[d])
                    if (1 === b.nodeType || e)
                        return a(b, c, f)
            }
                : function (b, c, g) {
                    var h, i, j = [u, f];
                    if (g) {
                        while (b = b[d])
                            if ((1 === b.nodeType || e) && a(b, c, g))
                                return !0
                    } else
                        while (b = b[d])
                            if (1 === b.nodeType || e) {
                                if (i = b[s] || (b[s] = {}),
                                    (h = i[d]) && h[0] === u && h[1] === f)
                                    return j[2] = h[2];
                                if (i[d] = j,
                                    j[2] = a(b, c, g))
                                    return !0
                            }
                }
        }
        function rb(a) {
            return a.length > 1 ? function (b, c, d) {
                var e = a.length;
                while (e--)
                    if (!a[e](b, c, d))
                        return !1;
                return !0
            }
                : a[0]
        }
        function sb(a, b, c, d, e) {
            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)
                (f = a[h]) && (!c || c(f, d, e)) && (g.push(f),
                    j && b.push(h));
            return g
        }
        function tb(a, b, c, d, e, f) {
            return d && !d[s] && (d = tb(d)),
                e && !e[s] && (e = tb(e, f)),
                fb(function (f, g, h, i) {
                    var j, k, l, m = [], n = [], o = g.length, p = f || wb(b || "*", h.nodeType ? [h] : h, []), q = !a || !f && b ? p : sb(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q;
                    if (c && c(q, r, h, i),
                        d) {
                        j = sb(r, n),
                            d(j, [], h, i),
                            k = j.length;
                        while (k--)
                            (l = j[k]) && (r[n[k]] = !(q[n[k]] = l))
                    }
                    if (f) {
                        if (e || a) {
                            if (e) {
                                j = [],
                                    k = r.length;
                                while (k--)
                                    (l = r[k]) && j.push(q[k] = l);
                                e(null, r = [], j, i)
                            }
                            k = r.length;
                            while (k--)
                                (l = r[k]) && (j = e ? I.call(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))
                        }
                    } else
                        r = sb(r === g ? r.splice(o, r.length) : r),
                            e ? e(null, g, r, i) : G.apply(g, r)
                })
        }
        function ub(a) {
            for (var b, c, e, f = a.length, g = d.relative[a[0].type], i = g || d.relative[" "], j = g ? 1 : 0, k = qb(function (a) {
                return a === b
            }, i, !0), l = qb(function (a) {
                return I.call(b, a) > -1
            }, i, !0), m = [function (a, c, d) {
                return !g && (d || c !== h) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d))
            }
            ]; f > j; j++)
                if (c = d.relative[a[j].type])
                    m = [qb(rb(m), c)];
                else {
                    if (c = d.filter[a[j].type].apply(null, a[j].matches),
                        c[s]) {
                        for (e = ++j; f > e; e++)
                            if (d.relative[a[e].type])
                                break;
                        return tb(j > 1 && rb(m), j > 1 && pb(a.slice(0, j - 1).concat({
                            value: " " === a[j - 2].type ? "*" : ""
                        })).replace(P, "$1"), c, e > j && ub(a.slice(j, e)), f > e && ub(a = a.slice(e)), f > e && pb(a))
                    }
                    m.push(c)
                }
            return rb(m)
        }
        function vb(a, b) {
            var c = b.length > 0
                , e = a.length > 0
                , f = function (f, g, i, j, k) {
                    var m, n, o, p = 0, q = "0", r = f && [], s = [], t = h, v = f || e && d.find.TAG("*", k), w = u += null == t ? 1 : Math.random() || .1, x = v.length;
                    for (k && (h = g !== l && g); q !== x && null != (m = v[q]); q++) {
                        if (e && m) {
                            n = 0;
                            while (o = a[n++])
                                if (o(m, g, i)) {
                                    j.push(m);
                                    break
                                }
                            k && (u = w)
                        }
                        c && ((m = !o && m) && p-- ,
                            f && r.push(m))
                    }
                    if (p += q,
                        c && q !== p) {
                        n = 0;
                        while (o = b[n++])
                            o(r, s, g, i);
                        if (f) {
                            if (p > 0)
                                while (q--)
                                    r[q] || s[q] || (s[q] = E.call(j));
                            s = sb(s)
                        }
                        G.apply(j, s),
                            k && !f && s.length > 0 && p + b.length > 1 && db.uniqueSort(j)
                    }
                    return k && (u = w,
                        h = t),
                        r
                };
            return c ? fb(f) : f
        }
        g = db.compile = function (a, b) {
            var c, d = [], e = [], f = y[a + " "];
            if (!f) {
                b || (b = ob(a)),
                    c = b.length;
                while (c--)
                    f = ub(b[c]),
                        f[s] ? d.push(f) : e.push(f);
                f = y(a, vb(e, d))
            }
            return f
        }
            ;
        function wb(a, b, c) {
            for (var d = 0, e = b.length; e > d; d++)
                db(a, b[d], c);
            return c
        }
        function xb(a, b, e, f) {
            var h, i, j, k, l, m = ob(a);
            if (!f && 1 === m.length) {
                if (i = m[0] = m[0].slice(0),
                    i.length > 2 && "ID" === (j = i[0]).type && c.getById && 9 === b.nodeType && n && d.relative[i[1].type]) {
                    if (b = (d.find.ID(j.matches[0].replace(ab, bb), b) || [])[0],
                        !b)
                        return e;
                    a = a.slice(i.shift().value.length)
                }
                h = V.needsContext.test(a) ? 0 : i.length;
                while (h--) {
                    if (j = i[h],
                        d.relative[k = j.type])
                        break;
                    if ((l = d.find[k]) && (f = l(j.matches[0].replace(ab, bb), $.test(i[0].type) && mb(b.parentNode) || b))) {
                        if (i.splice(h, 1),
                            a = f.length && pb(i),
                            !a)
                            return G.apply(e, f),
                                e;
                        break
                    }
                }
            }
            return g(a, m)(f, b, !n, e, $.test(a) && mb(b.parentNode) || b),
                e
        }
        return c.sortStable = s.split("").sort(z).join("") === s,
            c.detectDuplicates = !!j,
            k(),
            c.sortDetached = gb(function (a) {
                return 1 & a.compareDocumentPosition(l.createElement("div"))
            }),
            gb(function (a) {
                return a.innerHTML = "<a href='#'></a>",
                    "#" === a.firstChild.getAttribute("href")
            }) || hb("type|href|height|width", function (a, b, c) {
                return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
            }),
            c.attributes && gb(function (a) {
                return a.innerHTML = "<input/>",
                    a.firstChild.setAttribute("value", ""),
                    "" === a.firstChild.getAttribute("value")
            }) || hb("value", function (a, b, c) {
                return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue
            }),
            gb(function (a) {
                return null == a.getAttribute("disabled")
            }) || hb(J, function (a, b, c) {
                var d;
                return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
            }),
            db
    }(a);
    n.find = t,
        n.expr = t.selectors,
        n.expr[":"] = n.expr.pseudos,
        n.unique = t.uniqueSort,
        n.text = t.getText,
        n.isXMLDoc = t.isXML,
        n.contains = t.contains;
    var u = n.expr.match.needsContext
        , v = /^<(\w+)\s*\/?>(?:<\/\1>|)$/
        , w = /^.[^:#\[\.,]*$/;
    function x(a, b, c) {
        if (n.isFunction(b))
            return n.grep(a, function (a, d) {
                return !!b.call(a, d, a) !== c
            });
        if (b.nodeType)
            return n.grep(a, function (a) {
                return a === b !== c
            });
        if ("string" == typeof b) {
            if (w.test(b))
                return n.filter(b, a, c);
            b = n.filter(b, a)
        }
        return n.grep(a, function (a) {
            return n.inArray(a, b) >= 0 !== c
        })
    }
    n.filter = function (a, b, c) {
        var d = b[0];
        return c && (a = ":not(" + a + ")"),
            1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {
                return 1 === a.nodeType
            }))
    }
        ,
        n.fn.extend({
            find: function (a) {
                var b, c = [], d = this, e = d.length;
                if ("string" != typeof a)
                    return this.pushStack(n(a).filter(function () {
                        for (b = 0; e > b; b++)
                            if (n.contains(d[b], this))
                                return !0
                    }));
                for (b = 0; e > b; b++)
                    n.find(a, d[b], c);
                return c = this.pushStack(e > 1 ? n.unique(c) : c),
                    c.selector = this.selector ? this.selector + " " + a : a,
                    c
            },
            filter: function (a) {
                return this.pushStack(x(this, a || [], !1))
            },
            not: function (a) {
                return this.pushStack(x(this, a || [], !0))
            },
            is: function (a) {
                return !!x(this, "string" == typeof a && u.test(a) ? n(a) : a || [], !1).length
            }
        });
    var y, z = a.document, A = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, B = n.fn.init = function (a, b) {
        var c, d;
        if (!a)
            return this;
        if ("string" == typeof a) {
            if (c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [null, a, null] : A.exec(a),
                !c || !c[1] && b)
                return !b || b.jquery ? (b || y).find(a) : this.constructor(b).find(a);
            if (c[1]) {
                if (b = b instanceof n ? b[0] : b,
                    n.merge(this, n.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : z, !0)),
                    v.test(c[1]) && n.isPlainObject(b))
                    for (c in b)
                        n.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
                return this
            }
            if (d = z.getElementById(c[2]),
                d && d.parentNode) {
                if (d.id !== c[2])
                    return y.find(a);
                this.length = 1,
                    this[0] = d
            }
            return this.context = z,
                this.selector = a,
                this
        }
        return a.nodeType ? (this.context = this[0] = a,
            this.length = 1,
            this) : n.isFunction(a) ? "undefined" != typeof y.ready ? y.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector,
                this.context = a.context),
                n.makeArray(a, this))
    }
        ;
    B.prototype = n.fn,
        y = n(z);
    var C = /^(?:parents|prev(?:Until|All))/
        , D = {
            children: !0,
            contents: !0,
            next: !0,
            prev: !0
        };
    n.extend({
        dir: function (a, b, c) {
            var d = []
                , e = a[b];
            while (e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !n(e).is(c)))
                1 === e.nodeType && d.push(e),
                    e = e[b];
            return d
        },
        sibling: function (a, b) {
            for (var c = []; a; a = a.nextSibling)
                1 === a.nodeType && a !== b && c.push(a);
            return c
        }
    }),
        n.fn.extend({
            has: function (a) {
                var b, c = n(a, this), d = c.length;
                return this.filter(function () {
                    for (b = 0; d > b; b++)
                        if (n.contains(this, c[b]))
                            return !0
                })
            },
            closest: function (a, b) {
                for (var c, d = 0, e = this.length, f = [], g = u.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e > d; d++)
                    for (c = this[d]; c && c !== b; c = c.parentNode)
                        if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {
                            f.push(c);
                            break
                        }
                return this.pushStack(f.length > 1 ? n.unique(f) : f)
            },
            index: function (a) {
                return a ? "string" == typeof a ? n.inArray(this[0], n(a)) : n.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            },
            add: function (a, b) {
                return this.pushStack(n.unique(n.merge(this.get(), n(a, b))))
            },
            addBack: function (a) {
                return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
            }
        });
    function E(a, b) {
        do
            a = a[b];
        while (a && 1 !== a.nodeType); return a
    }
    n.each({
        parent: function (a) {
            var b = a.parentNode;
            return b && 11 !== b.nodeType ? b : null
        },
        parents: function (a) {
            return n.dir(a, "parentNode")
        },
        parentsUntil: function (a, b, c) {
            return n.dir(a, "parentNode", c)
        },
        next: function (a) {
            return E(a, "nextSibling")
        },
        prev: function (a) {
            return E(a, "previousSibling")
        },
        nextAll: function (a) {
            return n.dir(a, "nextSibling")
        },
        prevAll: function (a) {
            return n.dir(a, "previousSibling")
        },
        nextUntil: function (a, b, c) {
            return n.dir(a, "nextSibling", c)
        },
        prevUntil: function (a, b, c) {
            return n.dir(a, "previousSibling", c)
        },
        siblings: function (a) {
            return n.sibling((a.parentNode || {}).firstChild, a)
        },
        children: function (a) {
            return n.sibling(a.firstChild)
        },
        contents: function (a) {
            return n.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : n.merge([], a.childNodes)
        }
    }, function (a, b) {
        n.fn[a] = function (c, d) {
            var e = n.map(this, b, c);
            return "Until" !== a.slice(-5) && (d = c),
                d && "string" == typeof d && (e = n.filter(d, e)),
                this.length > 1 && (D[a] || (e = n.unique(e)),
                    C.test(a) && (e = e.reverse())),
                this.pushStack(e)
        }
    });
    var F = /\S+/g
        , G = {};
    function H(a) {
        var b = G[a] = {};
        return n.each(a.match(F) || [], function (a, c) {
            b[c] = !0
        }),
            b
    }
    n.Callbacks = function (a) {
        a = "string" == typeof a ? G[a] || H(a) : n.extend({}, a);
        var b, c, d, e, f, g, h = [], i = !a.once && [], j = function (l) {
            for (c = a.memory && l,
                d = !0,
                f = g || 0,
                g = 0,
                e = h.length,
                b = !0; h && e > f; f++)
                if (h[f].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
                    c = !1;
                    break
                }
            b = !1,
                h && (i ? i.length && j(i.shift()) : c ? h = [] : k.disable())
        }, k = {
            add: function () {
                if (h) {
                    var d = h.length;
                    !function f(b) {
                        n.each(b, function (b, c) {
                            var d = n.type(c);
                            "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && f(c)
                        })
                    }(arguments),
                        b ? e = h.length : c && (g = d,
                            j(c))
                }
                return this
            },
            remove: function () {
                return h && n.each(arguments, function (a, c) {
                    var d;
                    while ((d = n.inArray(c, h, d)) > -1)
                        h.splice(d, 1),
                            b && (e >= d && e-- ,
                                f >= d && f--)
                }),
                    this
            },
            has: function (a) {
                return a ? n.inArray(a, h) > -1 : !(!h || !h.length)
            },
            empty: function () {
                return h = [],
                    e = 0,
                    this
            },
            disable: function () {
                return h = i = c = void 0,
                    this
            },
            disabled: function () {
                return !h
            },
            lock: function () {
                return i = void 0,
                    c || k.disable(),
                    this
            },
            locked: function () {
                return !i
            },
            fireWith: function (a, c) {
                return !h || d && !i || (c = c || [],
                    c = [a, c.slice ? c.slice() : c],
                    b ? i.push(c) : j(c)),
                    this
            },
            fire: function () {
                return k.fireWith(this, arguments),
                    this
            },
            fired: function () {
                return !!d
            }
        };
        return k
    }
        ,
        n.extend({
            Deferred: function (a) {
                var b = [["resolve", "done", n.Callbacks("once memory"), "resolved"], ["reject", "fail", n.Callbacks("once memory"), "rejected"], ["notify", "progress", n.Callbacks("memory")]]
                    , c = "pending"
                    , d = {
                        state: function () {
                            return c
                        },
                        always: function () {
                            return e.done(arguments).fail(arguments),
                                this
                        },
                        then: function () {
                            var a = arguments;
                            return n.Deferred(function (c) {
                                n.each(b, function (b, f) {
                                    var g = n.isFunction(a[b]) && a[b];
                                    e[f[1]](function () {
                                        var a = g && g.apply(this, arguments);
                                        a && n.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments)
                                    })
                                }),
                                    a = null
                            }).promise()
                        },
                        promise: function (a) {
                            return null != a ? n.extend(a, d) : d
                        }
                    }
                    , e = {};
                return d.pipe = d.then,
                    n.each(b, function (a, f) {
                        var g = f[2]
                            , h = f[3];
                        d[f[1]] = g.add,
                            h && g.add(function () {
                                c = h
                            }, b[1 ^ a][2].disable, b[2][2].lock),
                            e[f[0]] = function () {
                                return e[f[0] + "With"](this === e ? d : this, arguments),
                                    this
                            }
                            ,
                            e[f[0] + "With"] = g.fireWith
                    }),
                    d.promise(e),
                    a && a.call(e, e),
                    e
            },
            when: function (a) {
                var b = 0, c = d.call(arguments), e = c.length, f = 1 !== e || a && n.isFunction(a.promise) ? e : 0, g = 1 === f ? a : n.Deferred(), h = function (a, b, c) {
                    return function (e) {
                        b[a] = this,
                            c[a] = arguments.length > 1 ? d.call(arguments) : e,
                            c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)
                    }
                }, i, j, k;
                if (e > 1)
                    for (i = new Array(e),
                        j = new Array(e),
                        k = new Array(e); e > b; b++)
                        c[b] && n.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
                return f || g.resolveWith(k, c),
                    g.promise()
            }
        });
    var I;
    n.fn.ready = function (a) {
        return n.ready.promise().done(a),
            this
    }
        ,
        n.extend({
            isReady: !1,
            readyWait: 1,
            holdReady: function (a) {
                a ? n.readyWait++ : n.ready(!0)
            },
            ready: function (a) {
                if (a === !0 ? !--n.readyWait : !n.isReady) {
                    if (!z.body)
                        return setTimeout(n.ready);
                    n.isReady = !0,
                        a !== !0 && --n.readyWait > 0 || (I.resolveWith(z, [n]),
                            n.fn.trigger && n(z).trigger("ready").off("ready"))
                }
            }
        });
    function J() {
        z.addEventListener ? (z.removeEventListener("DOMContentLoaded", K, !1),
            a.removeEventListener("load", K, !1)) : (z.detachEvent("onreadystatechange", K),
                a.detachEvent("onload", K))
    }
    function K() {
        (z.addEventListener || "load" === event.type || "complete" === z.readyState) && (J(),
            n.ready())
    }
    n.ready.promise = function (b) {
        if (!I)
            if (I = n.Deferred(),
                "complete" === z.readyState)
                setTimeout(n.ready);
            else if (z.addEventListener)
                z.addEventListener("DOMContentLoaded", K, !1),
                    a.addEventListener("load", K, !1);
            else {
                z.attachEvent("onreadystatechange", K),
                    a.attachEvent("onload", K);
                var c = !1;
                try {
                    c = null == a.frameElement && z.documentElement
                } catch (d) { }
                c && c.doScroll && !function e() {
                    if (!n.isReady) {
                        try {
                            c.doScroll("left")
                        } catch (a) {
                            return setTimeout(e, 50)
                        }
                        J(),
                            n.ready()
                    }
                }()
            }
        return I.promise(b)
    }
        ;
    var L = "undefined", M;
    for (M in n(l))
        break;
    l.ownLast = "0" !== M,
        l.inlineBlockNeedsLayout = !1,
        n(function () {
            var a, b, c = z.getElementsByTagName("body")[0];
            c && (a = z.createElement("div"),
                a.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",
                b = z.createElement("div"),
                c.appendChild(a).appendChild(b),
                typeof b.style.zoom !== L && (b.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1",
                    (l.inlineBlockNeedsLayout = 3 === b.offsetWidth) && (c.style.zoom = 1)),
                c.removeChild(a),
                a = b = null)
        }),
        function () {
            var a = z.createElement("div");
            if (null == l.deleteExpando) {
                l.deleteExpando = !0;
                try {
                    delete a.test
                } catch (b) {
                    l.deleteExpando = !1
                }
            }
            a = null
        }(),
        n.acceptData = function (a) {
            var b = n.noData[(a.nodeName + " ").toLowerCase()]
                , c = +a.nodeType || 1;
            return 1 !== c && 9 !== c ? !1 : !b || b !== !0 && a.getAttribute("classid") === b
        }
        ;
    var N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/
        , O = /([A-Z])/g;
    function P(a, b, c) {
        if (void 0 === c && 1 === a.nodeType) {
            var d = "data-" + b.replace(O, "-$1").toLowerCase();
            if (c = a.getAttribute(d),
                "string" == typeof c) {
                try {
                    c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : N.test(c) ? n.parseJSON(c) : c
                } catch (e) { }
                n.data(a, b, c)
            } else
                c = void 0
        }
        return c
    }
    function Q(a) {
        var b;
        for (b in a)
            if (("data" !== b || !n.isEmptyObject(a[b])) && "toJSON" !== b)
                return !1;
        return !0
    }
    function R(a, b, d, e) {
        if (n.acceptData(a)) {
            var f, g, h = n.expando, i = a.nodeType, j = i ? n.cache : a, k = i ? a[h] : a[h] && h;
            if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b)
                return k || (k = i ? a[h] = c.pop() || n.guid++ : h),
                    j[k] || (j[k] = i ? {} : {
                        toJSON: n.noop
                    }),
                    ("object" == typeof b || "function" == typeof b) && (e ? j[k] = n.extend(j[k], b) : j[k].data = n.extend(j[k].data, b)),
                    g = j[k],
                    e || (g.data || (g.data = {}),
                        g = g.data),
                    void 0 !== d && (g[n.camelCase(b)] = d),
                    "string" == typeof b ? (f = g[b],
                        null == f && (f = g[n.camelCase(b)])) : f = g,
                    f
        }
    }
    function S(a, b, c) {
        if (n.acceptData(a)) {
            var d, e, f = a.nodeType, g = f ? n.cache : a, h = f ? a[n.expando] : n.expando;
            if (g[h]) {
                if (b && (d = c ? g[h] : g[h].data)) {
                    n.isArray(b) ? b = b.concat(n.map(b, n.camelCase)) : b in d ? b = [b] : (b = n.camelCase(b),
                        b = b in d ? [b] : b.split(" ")),
                        e = b.length;
                    while (e--)
                        delete d[b[e]];
                    if (c ? !Q(d) : !n.isEmptyObject(d))
                        return
                }
                (c || (delete g[h].data,
                    Q(g[h]))) && (f ? n.cleanData([a], !0) : l.deleteExpando || g != g.window ? delete g[h] : g[h] = null)
            }
        }
    }
    n.extend({
        cache: {},
        noData: {
            "applet ": !0,
            "embed ": !0,
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function (a) {
            return a = a.nodeType ? n.cache[a[n.expando]] : a[n.expando],
                !!a && !Q(a)
        },
        data: function (a, b, c) {
            return R(a, b, c)
        },
        removeData: function (a, b) {
            return S(a, b)
        },
        _data: function (a, b, c) {
            return R(a, b, c, !0)
        },
        _removeData: function (a, b) {
            return S(a, b, !0)
        }
    }),
        n.fn.extend({
            data: function (a, b) {
                var c, d, e, f = this[0], g = f && f.attributes;
                if (void 0 === a) {
                    if (this.length && (e = n.data(f),
                        1 === f.nodeType && !n._data(f, "parsedAttrs"))) {
                        c = g.length;
                        while (c--)
                            d = g[c].name,
                                0 === d.indexOf("data-") && (d = n.camelCase(d.slice(5)),
                                    P(f, d, e[d]));
                        n._data(f, "parsedAttrs", !0)
                    }
                    return e
                }
                return "object" == typeof a ? this.each(function () {
                    n.data(this, a)
                }) : arguments.length > 1 ? this.each(function () {
                    n.data(this, a, b)
                }) : f ? P(f, a, n.data(f, a)) : void 0
            },
            removeData: function (a) {
                return this.each(function () {
                    n.removeData(this, a)
                })
            }
        }),
        n.extend({
            queue: function (a, b, c) {
                var d;
                return a ? (b = (b || "fx") + "queue",
                    d = n._data(a, b),
                    c && (!d || n.isArray(c) ? d = n._data(a, b, n.makeArray(c)) : d.push(c)),
                    d || []) : void 0
            },
            dequeue: function (a, b) {
                b = b || "fx";
                var c = n.queue(a, b)
                    , d = c.length
                    , e = c.shift()
                    , f = n._queueHooks(a, b)
                    , g = function () {
                        n.dequeue(a, b)
                    };
                "inprogress" === e && (e = c.shift(),
                    d--),
                    e && ("fx" === b && c.unshift("inprogress"),
                        delete f.stop,
                        e.call(a, g, f)),
                    !d && f && f.empty.fire()
            },
            _queueHooks: function (a, b) {
                var c = b + "queueHooks";
                return n._data(a, c) || n._data(a, c, {
                    empty: n.Callbacks("once memory").add(function () {
                        n._removeData(a, b + "queue"),
                            n._removeData(a, c)
                    })
                })
            }
        }),
        n.fn.extend({
            queue: function (a, b) {
                var c = 2;
                return "string" != typeof a && (b = a,
                    a = "fx",
                    c--),
                    arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {
                        var c = n.queue(this, a, b);
                        n._queueHooks(this, a),
                            "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a)
                    })
            },
            dequeue: function (a) {
                return this.each(function () {
                    n.dequeue(this, a)
                })
            },
            clearQueue: function (a) {
                return this.queue(a || "fx", [])
            },
            promise: function (a, b) {
                var c, d = 1, e = n.Deferred(), f = this, g = this.length, h = function () {
                    --d || e.resolveWith(f, [f])
                };
                "string" != typeof a && (b = a,
                    a = void 0),
                    a = a || "fx";
                while (g--)
                    c = n._data(f[g], a + "queueHooks"),
                        c && c.empty && (d++ ,
                            c.empty.add(h));
                return h(),
                    e.promise(b)
            }
        });
    var T = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source
        , U = ["Top", "Right", "Bottom", "Left"]
        , V = function (a, b) {
            return a = b || a,
                "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a)
        }
        , W = n.access = function (a, b, c, d, e, f, g) {
            var h = 0
                , i = a.length
                , j = null == c;
            if ("object" === n.type(c)) {
                e = !0;
                for (h in c)
                    n.access(a, b, h, c[h], !0, f, g)
            } else if (void 0 !== d && (e = !0,
                n.isFunction(d) || (g = !0),
                j && (g ? (b.call(a, d),
                    b = null) : (j = b,
                        b = function (a, b, c) {
                            return j.call(n(a), c)
                        }
                    )),
                b))
                for (; i > h; h++)
                    b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
            return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
        }
        , X = /^(?:checkbox|radio)$/i;
    !function () {
        var a = z.createDocumentFragment()
            , b = z.createElement("div")
            , c = z.createElement("input");
        if (b.setAttribute("className", "t"),
            b.innerHTML = "  <link/><table></table><a href='/a'>a</a>",
            l.leadingWhitespace = 3 === b.firstChild.nodeType,
            l.tbody = !b.getElementsByTagName("tbody").length,
            l.htmlSerialize = !!b.getElementsByTagName("link").length,
            l.html5Clone = "<:nav></:nav>" !== z.createElement("nav").cloneNode(!0).outerHTML,
            c.type = "checkbox",
            c.checked = !0,
            a.appendChild(c),
            l.appendChecked = c.checked,
            b.innerHTML = "<textarea>x</textarea>",
            l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue,
            a.appendChild(b),
            b.innerHTML = "<input type='radio' checked='checked' name='t'/>",
            l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked,
            l.noCloneEvent = !0,
            b.attachEvent && (b.attachEvent("onclick", function () {
                l.noCloneEvent = !1
            }),
                b.cloneNode(!0).click()),
            null == l.deleteExpando) {
            l.deleteExpando = !0;
            try {
                delete b.test
            } catch (d) {
                l.deleteExpando = !1
            }
        }
        a = b = c = null
    }(),
        function () {
            var b, c, d = z.createElement("div");
            for (b in {
                submit: !0,
                change: !0,
                focusin: !0
            })
                c = "on" + b,
                    (l[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"),
                        l[b + "Bubbles"] = d.attributes[c].expando === !1);
            d = null
        }();
    var Y = /^(?:input|select|textarea)$/i
        , Z = /^key/
        , $ = /^(?:mouse|contextmenu)|click/
        , _ = /^(?:focusinfocus|focusoutblur)$/
        , ab = /^([^.]*)(?:\.(.+)|)$/;
    function bb() {
        return !0
    }
    function cb() {
        return !1
    }
    function db() {
        try {
            return z.activeElement
        } catch (a) { }
    }
    n.event = {
        global: {},
        add: function (a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, o, p, q, r = n._data(a);
            if (r) {
                c.handler && (i = c,
                    c = i.handler,
                    e = i.selector),
                    c.guid || (c.guid = n.guid++),
                    (g = r.events) || (g = r.events = {}),
                    (k = r.handle) || (k = r.handle = function (a) {
                        return typeof n === L || a && n.event.triggered === a.type ? void 0 : n.event.dispatch.apply(k.elem, arguments)
                    }
                        ,
                        k.elem = a),
                    b = (b || "").match(F) || [""],
                    h = b.length;
                while (h--)
                    f = ab.exec(b[h]) || [],
                        o = q = f[1],
                        p = (f[2] || "").split(".").sort(),
                        o && (j = n.event.special[o] || {},
                            o = (e ? j.delegateType : j.bindType) || o,
                            j = n.event.special[o] || {},
                            l = n.extend({
                                type: o,
                                origType: q,
                                data: d,
                                handler: c,
                                guid: c.guid,
                                selector: e,
                                needsContext: e && n.expr.match.needsContext.test(e),
                                namespace: p.join(".")
                            }, i),
                            (m = g[o]) || (m = g[o] = [],
                                m.delegateCount = 0,
                                j.setup && j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))),
                            j.add && (j.add.call(a, l),
                                l.handler.guid || (l.handler.guid = c.guid)),
                            e ? m.splice(m.delegateCount++, 0, l) : m.push(l),
                            n.event.global[o] = !0);
                a = null
            }
        },
        remove: function (a, b, c, d, e) {
            var f, g, h, i, j, k, l, m, o, p, q, r = n.hasData(a) && n._data(a);
            if (r && (k = r.events)) {
                b = (b || "").match(F) || [""],
                    j = b.length;
                while (j--)
                    if (h = ab.exec(b[j]) || [],
                        o = q = h[1],
                        p = (h[2] || "").split(".").sort(),
                        o) {
                        l = n.event.special[o] || {},
                            o = (d ? l.delegateType : l.bindType) || o,
                            m = k[o] || [],
                            h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"),
                            i = f = m.length;
                        while (f--)
                            g = m[f],
                                !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (m.splice(f, 1),
                                    g.selector && m.delegateCount-- ,
                                    l.remove && l.remove.call(a, g));
                        i && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle),
                            delete k[o])
                    } else
                        for (o in k)
                            n.event.remove(a, o + b[j], c, d, !0);
                n.isEmptyObject(k) && (delete r.handle,
                    n._removeData(a, "events"))
            }
        },
        trigger: function (b, c, d, e) {
            var f, g, h, i, k, l, m, o = [d || z], p = j.call(b, "type") ? b.type : b, q = j.call(b, "namespace") ? b.namespace.split(".") : [];
            if (h = l = d = d || z,
                3 !== d.nodeType && 8 !== d.nodeType && !_.test(p + n.event.triggered) && (p.indexOf(".") >= 0 && (q = p.split("."),
                    p = q.shift(),
                    q.sort()),
                    g = p.indexOf(":") < 0 && "on" + p,
                    b = b[n.expando] ? b : new n.Event(p, "object" == typeof b && b),
                    b.isTrigger = e ? 2 : 3,
                    b.namespace = q.join("."),
                    b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null,
                    b.result = void 0,
                    b.target || (b.target = d),
                    c = null == c ? [b] : n.makeArray(c, [b]),
                    k = n.event.special[p] || {},
                    e || !k.trigger || k.trigger.apply(d, c) !== !1)) {
                if (!e && !k.noBubble && !n.isWindow(d)) {
                    for (i = k.delegateType || p,
                        _.test(i + p) || (h = h.parentNode); h; h = h.parentNode)
                        o.push(h),
                            l = h;
                    l === (d.ownerDocument || z) && o.push(l.defaultView || l.parentWindow || a)
                }
                m = 0;
                while ((h = o[m++]) && !b.isPropagationStopped())
                    b.type = m > 1 ? i : k.bindType || p,
                        f = (n._data(h, "events") || {})[b.type] && n._data(h, "handle"),
                        f && f.apply(h, c),
                        f = g && h[g],
                        f && f.apply && n.acceptData(h) && (b.result = f.apply(h, c),
                            b.result === !1 && b.preventDefault());
                if (b.type = p,
                    !e && !b.isDefaultPrevented() && (!k._default || k._default.apply(o.pop(), c) === !1) && n.acceptData(d) && g && d[p] && !n.isWindow(d)) {
                    l = d[g],
                        l && (d[g] = null),
                        n.event.triggered = p;
                    try {
                        d[p]()
                    } catch (r) { }
                    n.event.triggered = void 0,
                        l && (d[g] = l)
                }
                return b.result
            }
        },
        dispatch: function (a) {
            a = n.event.fix(a);
            var b, c, e, f, g, h = [], i = d.call(arguments), j = (n._data(this, "events") || {})[a.type] || [], k = n.event.special[a.type] || {};
            if (i[0] = a,
                a.delegateTarget = this,
                !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
                h = n.event.handlers.call(this, a, j),
                    b = 0;
                while ((f = h[b++]) && !a.isPropagationStopped()) {
                    a.currentTarget = f.elem,
                        g = 0;
                    while ((e = f.handlers[g++]) && !a.isImmediatePropagationStopped())
                        (!a.namespace_re || a.namespace_re.test(e.namespace)) && (a.handleObj = e,
                            a.data = e.data,
                            c = ((n.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i),
                            void 0 !== c && (a.result = c) === !1 && (a.preventDefault(),
                                a.stopPropagation()))
                }
                return k.postDispatch && k.postDispatch.call(this, a),
                    a.result
            }
        },
        handlers: function (a, b) {
            var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
            if (h && i.nodeType && (!a.button || "click" !== a.type))
                for (; i != this; i = i.parentNode || this)
                    if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
                        for (e = [],
                            f = 0; h > f; f++)
                            d = b[f],
                                c = d.selector + " ",
                                void 0 === e[c] && (e[c] = d.needsContext ? n(c, this).index(i) >= 0 : n.find(c, this, null, [i]).length),
                                e[c] && e.push(d);
                        e.length && g.push({
                            elem: i,
                            handlers: e
                        })
                    }
            return h < b.length && g.push({
                elem: this,
                handlers: b.slice(h)
            }),
                g
        },
        fix: function (a) {
            if (a[n.expando])
                return a;
            var b, c, d, e = a.type, f = a, g = this.fixHooks[e];
            g || (this.fixHooks[e] = g = $.test(e) ? this.mouseHooks : Z.test(e) ? this.keyHooks : {}),
                d = g.props ? this.props.concat(g.props) : this.props,
                a = new n.Event(f),
                b = d.length;
            while (b--)
                c = d[b],
                    a[c] = f[c];
            return a.target || (a.target = f.srcElement || z),
                3 === a.target.nodeType && (a.target = a.target.parentNode),
                a.metaKey = !!a.metaKey,
                g.filter ? g.filter(a, f) : a
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function (a, b) {
                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode),
                    a
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function (a, b) {
                var c, d, e, f = b.button, g = b.fromElement;
                return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || z,
                    e = d.documentElement,
                    c = d.body,
                    a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0),
                    a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)),
                    !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g),
                    a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0),
                    a
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function () {
                    if (this !== db() && this.focus)
                        try {
                            return this.focus(),
                                !1
                        } catch (a) { }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function () {
                    return this === db() && this.blur ? (this.blur(),
                        !1) : void 0
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function () {
                    return n.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(),
                        !1) : void 0
                },
                _default: function (a) {
                    return n.nodeName(a.target, "a")
                }
            },
            beforeunload: {
                postDispatch: function (a) {
                    void 0 !== a.result && (a.originalEvent.returnValue = a.result)
                }
            }
        },
        simulate: function (a, b, c, d) {
            var e = n.extend(new n.Event, c, {
                type: a,
                isSimulated: !0,
                originalEvent: {}
            });
            d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e),
                e.isDefaultPrevented() && c.preventDefault()
        }
    },
        n.removeEvent = z.removeEventListener ? function (a, b, c) {
            a.removeEventListener && a.removeEventListener(b, c, !1)
        }
            : function (a, b, c) {
                var d = "on" + b;
                a.detachEvent && (typeof a[d] === L && (a[d] = null),
                    a.detachEvent(d, c))
            }
        ,
        n.Event = function (a, b) {
            return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a,
                this.type = a.type,
                this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && (a.returnValue === !1 || a.getPreventDefault && a.getPreventDefault()) ? bb : cb) : this.type = a,
                b && n.extend(this, b),
                this.timeStamp = a && a.timeStamp || n.now(),
                void (this[n.expando] = !0)) : new n.Event(a, b)
        }
        ,
        n.Event.prototype = {
            isDefaultPrevented: cb,
            isPropagationStopped: cb,
            isImmediatePropagationStopped: cb,
            preventDefault: function () {
                var a = this.originalEvent;
                this.isDefaultPrevented = bb,
                    a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1)
            },
            stopPropagation: function () {
                var a = this.originalEvent;
                this.isPropagationStopped = bb,
                    a && (a.stopPropagation && a.stopPropagation(),
                        a.cancelBubble = !0)
            },
            stopImmediatePropagation: function () {
                this.isImmediatePropagationStopped = bb,
                    this.stopPropagation()
            }
        },
        n.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        }, function (a, b) {
            n.event.special[a] = {
                delegateType: b,
                bindType: b,
                handle: function (a) {
                    var c, d = this, e = a.relatedTarget, f = a.handleObj;
                    return (!e || e !== d && !n.contains(d, e)) && (a.type = f.origType,
                        c = f.handler.apply(this, arguments),
                        a.type = b),
                        c
                }
            }
        }),
        l.submitBubbles || (n.event.special.submit = {
            setup: function () {
                return n.nodeName(this, "form") ? !1 : void n.event.add(this, "click._submit keypress._submit", function (a) {
                    var b = a.target
                        , c = n.nodeName(b, "input") || n.nodeName(b, "button") ? b.form : void 0;
                    c && !n._data(c, "submitBubbles") && (n.event.add(c, "submit._submit", function (a) {
                        a._submit_bubble = !0
                    }),
                        n._data(c, "submitBubbles", !0))
                })
            },
            postDispatch: function (a) {
                a._submit_bubble && (delete a._submit_bubble,
                    this.parentNode && !a.isTrigger && n.event.simulate("submit", this.parentNode, a, !0))
            },
            teardown: function () {
                return n.nodeName(this, "form") ? !1 : void n.event.remove(this, "._submit")
            }
        }),
        l.changeBubbles || (n.event.special.change = {
            setup: function () {
                return Y.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (n.event.add(this, "propertychange._change", function (a) {
                    "checked" === a.originalEvent.propertyName && (this._just_changed = !0)
                }),
                    n.event.add(this, "click._change", function (a) {
                        this._just_changed && !a.isTrigger && (this._just_changed = !1),
                            n.event.simulate("change", this, a, !0)
                    })),
                    !1) : void n.event.add(this, "beforeactivate._change", function (a) {
                        var b = a.target;
                        Y.test(b.nodeName) && !n._data(b, "changeBubbles") && (n.event.add(b, "change._change", function (a) {
                            !this.parentNode || a.isSimulated || a.isTrigger || n.event.simulate("change", this.parentNode, a, !0)
                        }),
                            n._data(b, "changeBubbles", !0))
                    })
            },
            handle: function (a) {
                var b = a.target;
                return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0
            },
            teardown: function () {
                return n.event.remove(this, "._change"),
                    !Y.test(this.nodeName)
            }
        }),
        l.focusinBubbles || n.each({
            focus: "focusin",
            blur: "focusout"
        }, function (a, b) {
            var c = function (a) {
                n.event.simulate(b, a.target, n.event.fix(a), !0)
            };
            n.event.special[b] = {
                setup: function () {
                    var d = this.ownerDocument || this
                        , e = n._data(d, b);
                    e || d.addEventListener(a, c, !0),
                        n._data(d, b, (e || 0) + 1)
                },
                teardown: function () {
                    var d = this.ownerDocument || this
                        , e = n._data(d, b) - 1;
                    e ? n._data(d, b, e) : (d.removeEventListener(a, c, !0),
                        n._removeData(d, b))
                }
            }
        }),
        n.fn.extend({
            on: function (a, b, c, d, e) {
                var f, g;
                if ("object" == typeof a) {
                    "string" != typeof b && (c = c || b,
                        b = void 0);
                    for (f in a)
                        this.on(f, b, c, a[f], e);
                    return this
                }
                if (null == c && null == d ? (d = b,
                    c = b = void 0) : null == d && ("string" == typeof b ? (d = c,
                        c = void 0) : (d = c,
                            c = b,
                            b = void 0)),
                    d === !1)
                    d = cb;
                else if (!d)
                    return this;
                return 1 === e && (g = d,
                    d = function (a) {
                        return n().off(a),
                            g.apply(this, arguments)
                    }
                    ,
                    d.guid = g.guid || (g.guid = n.guid++)),
                    this.each(function () {
                        n.event.add(this, a, d, c, b)
                    })
            },
            one: function (a, b, c, d) {
                return this.on(a, b, c, d, 1)
            },
            off: function (a, b, c) {
                var d, e;
                if (a && a.preventDefault && a.handleObj)
                    return d = a.handleObj,
                        n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler),
                        this;
                if ("object" == typeof a) {
                    for (e in a)
                        this.off(e, b, a[e]);
                    return this
                }
                return (b === !1 || "function" == typeof b) && (c = b,
                    b = void 0),
                    c === !1 && (c = cb),
                    this.each(function () {
                        n.event.remove(this, a, c, b)
                    })
            },
            trigger: function (a, b) {
                return this.each(function () {
                    n.event.trigger(a, b, this)
                })
            },
            triggerHandler: function (a, b) {
                var c = this[0];
                return c ? n.event.trigger(a, b, c, !0) : void 0
            }
        });
    function eb(a) {
        var b = fb.split("|")
            , c = a.createDocumentFragment();
        if (c.createElement)
            while (b.length)
                c.createElement(b.pop());
        return c
    }
    var fb = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video"
        , gb = / jQuery\d+="(?:null|\d+)"/g
        , hb = new RegExp("<(?:" + fb + ")[\\s/>]", "i")
        , ib = /^\s+/
        , jb = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi
        , kb = /<([\w:]+)/
        , lb = /<tbody/i
        , mb = /<|&#?\w+;/
        , nb = /<(?:script|style|link)/i
        , ob = /checked\s*(?:[^=]|=\s*.checked.)/i
        , pb = /^$|\/(?:java|ecma)script/i
        , qb = /^true\/(.*)/
        , rb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g
        , sb = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            legend: [1, "<fieldset>", "</fieldset>"],
            area: [1, "<map>", "</map>"],
            param: [1, "<object>", "</object>"],
            thead: [1, "<table>", "</table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: l.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
        }
        , tb = eb(z)
        , ub = tb.appendChild(z.createElement("div"));
    sb.optgroup = sb.option,
        sb.tbody = sb.tfoot = sb.colgroup = sb.caption = sb.thead,
        sb.th = sb.td;
    function vb(a, b) {
        var c, d, e = 0, f = typeof a.getElementsByTagName !== L ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== L ? a.querySelectorAll(b || "*") : void 0;
        if (!f)
            for (f = [],
                c = a.childNodes || a; null != (d = c[e]); e++)
                !b || n.nodeName(d, b) ? f.push(d) : n.merge(f, vb(d, b));
        return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], f) : f
    }
    function wb(a) {
        X.test(a.type) && (a.defaultChecked = a.checked)
    }
    function xb(a, b) {
        return n.nodeName(a, "table") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a
    }
    function yb(a) {
        return a.type = (null !== n.find.attr(a, "type")) + "/" + a.type,
            a
    }
    function zb(a) {
        var b = qb.exec(a.type);
        return b ? a.type = b[1] : a.removeAttribute("type"),
            a
    }
    function Ab(a, b) {
        for (var c, d = 0; null != (c = a[d]); d++)
            n._data(c, "globalEval", !b || n._data(b[d], "globalEval"))
    }
    function Bb(a, b) {
        if (1 === b.nodeType && n.hasData(a)) {
            var c, d, e, f = n._data(a), g = n._data(b, f), h = f.events;
            if (h) {
                delete g.handle,
                    g.events = {};
                for (c in h)
                    for (d = 0,
                        e = h[c].length; e > d; d++)
                        n.event.add(b, c, h[c][d])
            }
            g.data && (g.data = n.extend({}, g.data))
        }
    }
    function Cb(a, b) {
        var c, d, e;
        if (1 === b.nodeType) {
            if (c = b.nodeName.toLowerCase(),
                !l.noCloneEvent && b[n.expando]) {
                e = n._data(b);
                for (d in e.events)
                    n.removeEvent(b, d, e.handle);
                b.removeAttribute(n.expando)
            }
            "script" === c && b.text !== a.text ? (yb(b).text = a.text,
                zb(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML),
                    l.html5Clone && a.innerHTML && !n.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && X.test(a.type) ? (b.defaultChecked = b.checked = a.checked,
                        b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue)
        }
    }
    n.extend({
        clone: function (a, b, c) {
            var d, e, f, g, h, i = n.contains(a.ownerDocument, a);
            if (l.html5Clone || n.isXMLDoc(a) || !hb.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (ub.innerHTML = a.outerHTML,
                ub.removeChild(f = ub.firstChild)),
                !(l.noCloneEvent && l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a)))
                for (d = vb(f),
                    h = vb(a),
                    g = 0; null != (e = h[g]); ++g)
                    d[g] && Cb(e, d[g]);
            if (b)
                if (c)
                    for (h = h || vb(a),
                        d = d || vb(f),
                        g = 0; null != (e = h[g]); g++)
                        Bb(e, d[g]);
                else
                    Bb(a, f);
            return d = vb(f, "script"),
                d.length > 0 && Ab(d, !i && vb(a, "script")),
                d = h = e = null,
                f
        },
        buildFragment: function (a, b, c, d) {
            for (var e, f, g, h, i, j, k, m = a.length, o = eb(b), p = [], q = 0; m > q; q++)
                if (f = a[q],
                    f || 0 === f)
                    if ("object" === n.type(f))
                        n.merge(p, f.nodeType ? [f] : f);
                    else if (mb.test(f)) {
                        h = h || o.appendChild(b.createElement("div")),
                            i = (kb.exec(f) || ["", ""])[1].toLowerCase(),
                            k = sb[i] || sb._default,
                            h.innerHTML = k[1] + f.replace(jb, "<$1></$2>") + k[2],
                            e = k[0];
                        while (e--)
                            h = h.lastChild;
                        if (!l.leadingWhitespace && ib.test(f) && p.push(b.createTextNode(ib.exec(f)[0])),
                            !l.tbody) {
                            f = "table" !== i || lb.test(f) ? "<table>" !== k[1] || lb.test(f) ? 0 : h : h.firstChild,
                                e = f && f.childNodes.length;
                            while (e--)
                                n.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j)
                        }
                        n.merge(p, h.childNodes),
                            h.textContent = "";
                        while (h.firstChild)
                            h.removeChild(h.firstChild);
                        h = o.lastChild
                    } else
                        p.push(b.createTextNode(f));
            h && o.removeChild(h),
                l.appendChecked || n.grep(vb(p, "input"), wb),
                q = 0;
            while (f = p[q++])
                if ((!d || -1 === n.inArray(f, d)) && (g = n.contains(f.ownerDocument, f),
                    h = vb(o.appendChild(f), "script"),
                    g && Ab(h),
                    c)) {
                    e = 0;
                    while (f = h[e++])
                        pb.test(f.type || "") && c.push(f)
                }
            return h = null,
                o
        },
        cleanData: function (a, b) {
            for (var d, e, f, g, h = 0, i = n.expando, j = n.cache, k = l.deleteExpando, m = n.event.special; null != (d = a[h]); h++)
                if ((b || n.acceptData(d)) && (f = d[i],
                    g = f && j[f])) {
                    if (g.events)
                        for (e in g.events)
                            m[e] ? n.event.remove(d, e) : n.removeEvent(d, e, g.handle);
                    j[f] && (delete j[f],
                        k ? delete d[i] : typeof d.removeAttribute !== L ? d.removeAttribute(i) : d[i] = null,
                        c.push(f))
                }
        }
    }),
        n.fn.extend({
            text: function (a) {
                return W(this, function (a) {
                    return void 0 === a ? n.text(this) : this.empty().append((this[0] && this[0].ownerDocument || z).createTextNode(a))
                }, null, a, arguments.length)
            },
            append: function () {
                return this.domManip(arguments, function (a) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var b = xb(this, a);
                        b.appendChild(a)
                    }
                })
            },
            prepend: function () {
                return this.domManip(arguments, function (a) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var b = xb(this, a);
                        b.insertBefore(a, b.firstChild)
                    }
                })
            },
            before: function () {
                return this.domManip(arguments, function (a) {
                    this.parentNode && this.parentNode.insertBefore(a, this)
                })
            },
            after: function () {
                return this.domManip(arguments, function (a) {
                    this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
                })
            },
            remove: function (a, b) {
                for (var c, d = a ? n.filter(a, this) : this, e = 0; null != (c = d[e]); e++)
                    b || 1 !== c.nodeType || n.cleanData(vb(c)),
                        c.parentNode && (b && n.contains(c.ownerDocument, c) && Ab(vb(c, "script")),
                            c.parentNode.removeChild(c));
                return this
            },
            empty: function () {
                for (var a, b = 0; null != (a = this[b]); b++) {
                    1 === a.nodeType && n.cleanData(vb(a, !1));
                    while (a.firstChild)
                        a.removeChild(a.firstChild);
                    a.options && n.nodeName(a, "select") && (a.options.length = 0)
                }
                return this
            },
            clone: function (a, b) {
                return a = null == a ? !1 : a,
                    b = null == b ? a : b,
                    this.map(function () {
                        return n.clone(this, a, b)
                    })
            },
            html: function (a) {
                return W(this, function (a) {
                    var b = this[0] || {}
                        , c = 0
                        , d = this.length;
                    if (void 0 === a)
                        return 1 === b.nodeType ? b.innerHTML.replace(gb, "") : void 0;
                    if (!("string" != typeof a || nb.test(a) || !l.htmlSerialize && hb.test(a) || !l.leadingWhitespace && ib.test(a) || sb[(kb.exec(a) || ["", ""])[1].toLowerCase()])) {
                        a = a.replace(jb, "<$1></$2>");
                        try {
                            for (; d > c; c++)
                                b = this[c] || {},
                                    1 === b.nodeType && (n.cleanData(vb(b, !1)),
                                        b.innerHTML = a);
                            b = 0
                        } catch (e) { }
                    }
                    b && this.empty().append(a)
                }, null, a, arguments.length)
            },
            replaceWith: function () {
                var a = arguments[0];
                return this.domManip(arguments, function (b) {
                    a = this.parentNode,
                        n.cleanData(vb(this)),
                        a && a.replaceChild(b, this)
                }),
                    a && (a.length || a.nodeType) ? this : this.remove()
            },
            detach: function (a) {
                return this.remove(a, !0)
            },
            domManip: function (a, b) {
                a = e.apply([], a);
                var c, d, f, g, h, i, j = 0, k = this.length, m = this, o = k - 1, p = a[0], q = n.isFunction(p);
                if (q || k > 1 && "string" == typeof p && !l.checkClone && ob.test(p))
                    return this.each(function (c) {
                        var d = m.eq(c);
                        q && (a[0] = p.call(this, c, d.html())),
                            d.domManip(a, b)
                    });
                if (k && (i = n.buildFragment(a, this[0].ownerDocument, !1, this),
                    c = i.firstChild,
                    1 === i.childNodes.length && (i = c),
                    c)) {
                    for (g = n.map(vb(i, "script"), yb),
                        f = g.length; k > j; j++)
                        d = i,
                            j !== o && (d = n.clone(d, !0, !0),
                                f && n.merge(g, vb(d, "script"))),
                            b.call(this[j], d, j);
                    if (f)
                        for (h = g[g.length - 1].ownerDocument,
                            n.map(g, zb),
                            j = 0; f > j; j++)
                            d = g[j],
                                pb.test(d.type || "") && !n._data(d, "globalEval") && n.contains(h, d) && (d.src ? n._evalUrl && n._evalUrl(d.src) : n.globalEval((d.text || d.textContent || d.innerHTML || "").replace(rb, "")));
                    i = c = null
                }
                return this
            }
        }),
        n.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function (a, b) {
            n.fn[a] = function (a) {
                for (var c, d = 0, e = [], g = n(a), h = g.length - 1; h >= d; d++)
                    c = d === h ? this : this.clone(!0),
                        n(g[d])[b](c),
                        f.apply(e, c.get());
                return this.pushStack(e)
            }
        });
    var Db, Eb = {};
    function Fb(b, c) {
        var d = n(c.createElement(b)).appendTo(c.body)
            , e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle(d[0]).display : n.css(d[0], "display");
        return d.detach(),
            e
    }
    function Gb(a) {
        var b = z
            , c = Eb[a];
        return c || (c = Fb(a, b),
            "none" !== c && c || (Db = (Db || n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),
                b = (Db[0].contentWindow || Db[0].contentDocument).document,
                b.write(),
                b.close(),
                c = Fb(a, b),
                Db.detach()),
            Eb[a] = c),
            c
    }
    !function () {
        var a, b, c = z.createElement("div"), d = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";
        c.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",
            a = c.getElementsByTagName("a")[0],
            a.style.cssText = "float:left;opacity:.5",
            l.opacity = /^0.5/.test(a.style.opacity),
            l.cssFloat = !!a.style.cssFloat,
            c.style.backgroundClip = "content-box",
            c.cloneNode(!0).style.backgroundClip = "",
            l.clearCloneStyle = "content-box" === c.style.backgroundClip,
            a = c = null,
            l.shrinkWrapBlocks = function () {
                var a, c, e, f;
                if (null == b) {
                    if (a = z.getElementsByTagName("body")[0],
                        !a)
                        return;
                    f = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px",
                        c = z.createElement("div"),
                        e = z.createElement("div"),
                        a.appendChild(c).appendChild(e),
                        b = !1,
                        typeof e.style.zoom !== L && (e.style.cssText = d + ";width:1px;padding:1px;zoom:1",
                            e.innerHTML = "<div></div>",
                            e.firstChild.style.width = "5px",
                            b = 3 !== e.offsetWidth),
                        a.removeChild(c),
                        a = c = e = null
                }
                return b
            }
    }();
    var Hb = /^margin/, Ib = new RegExp("^(" + T + ")(?!px)[a-z%]+$", "i"), Jb, Kb, Lb = /^(top|right|bottom|left)$/;
    a.getComputedStyle ? (Jb = function (a) {
        return a.ownerDocument.defaultView.getComputedStyle(a, null)
    }
        ,
        Kb = function (a, b, c) {
            var d, e, f, g, h = a.style;
            return c = c || Jb(a),
                g = c ? c.getPropertyValue(b) || c[b] : void 0,
                c && ("" !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)),
                    Ib.test(g) && Hb.test(b) && (d = h.width,
                        e = h.minWidth,
                        f = h.maxWidth,
                        h.minWidth = h.maxWidth = h.width = g,
                        g = c.width,
                        h.width = d,
                        h.minWidth = e,
                        h.maxWidth = f)),
                void 0 === g ? g : g + ""
        }
    ) : z.documentElement.currentStyle && (Jb = function (a) {
        return a.currentStyle
    }
        ,
        Kb = function (a, b, c) {
            var d, e, f, g, h = a.style;
            return c = c || Jb(a),
                g = c ? c[b] : void 0,
                null == g && h && h[b] && (g = h[b]),
                Ib.test(g) && !Lb.test(b) && (d = h.left,
                    e = a.runtimeStyle,
                    f = e && e.left,
                    f && (e.left = a.currentStyle.left),
                    h.left = "fontSize" === b ? "1em" : g,
                    g = h.pixelLeft + "px",
                    h.left = d,
                    f && (e.left = f)),
                void 0 === g ? g : g + "" || "auto"
        }
    );
    function Mb(a, b) {
        return {
            get: function () {
                var c = a();
                if (null != c)
                    return c ? void delete this.get : (this.get = b).apply(this, arguments)
            }
        }
    }
    !function () {
        var b, c, d, e, f, g, h = z.createElement("div"), i = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px", j = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";
        h.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",
            b = h.getElementsByTagName("a")[0],
            b.style.cssText = "float:left;opacity:.5",
            l.opacity = /^0.5/.test(b.style.opacity),
            l.cssFloat = !!b.style.cssFloat,
            h.style.backgroundClip = "content-box",
            h.cloneNode(!0).style.backgroundClip = "",
            l.clearCloneStyle = "content-box" === h.style.backgroundClip,
            b = h = null,
            n.extend(l, {
                reliableHiddenOffsets: function () {
                    if (null != c)
                        return c;
                    var a, b, d, e = z.createElement("div"), f = z.getElementsByTagName("body")[0];
                    if (f)
                        return e.setAttribute("className", "t"),
                            e.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",
                            a = z.createElement("div"),
                            a.style.cssText = i,
                            f.appendChild(a).appendChild(e),
                            e.innerHTML = "<table><tr><td></td><td>t</td></tr></table>",
                            b = e.getElementsByTagName("td"),
                            b[0].style.cssText = "padding:0;margin:0;border:0;display:none",
                            d = 0 === b[0].offsetHeight,
                            b[0].style.display = "",
                            b[1].style.display = "none",
                            c = d && 0 === b[0].offsetHeight,
                            f.removeChild(a),
                            e = f = null,
                            c
                },
                boxSizing: function () {
                    return null == d && k(),
                        d
                },
                boxSizingReliable: function () {
                    return null == e && k(),
                        e
                },
                pixelPosition: function () {
                    return null == f && k(),
                        f
                },
                reliableMarginRight: function () {
                    var b, c, d, e;
                    if (null == g && a.getComputedStyle) {
                        if (b = z.getElementsByTagName("body")[0],
                            !b)
                            return;
                        c = z.createElement("div"),
                            d = z.createElement("div"),
                            c.style.cssText = i,
                            b.appendChild(c).appendChild(d),
                            e = d.appendChild(z.createElement("div")),
                            e.style.cssText = d.style.cssText = j,
                            e.style.marginRight = e.style.width = "0",
                            d.style.width = "1px",
                            g = !parseFloat((a.getComputedStyle(e, null) || {}).marginRight),
                            b.removeChild(c)
                    }
                    return g
                }
            });
        function k() {
            var b, c, h = z.getElementsByTagName("body")[0];
            h && (b = z.createElement("div"),
                c = z.createElement("div"),
                b.style.cssText = i,
                h.appendChild(b).appendChild(c),
                c.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;display:block;padding:1px;border:1px;width:4px;margin-top:1%;top:1%",
                n.swap(h, null != h.style.zoom ? {
                    zoom: 1
                } : {}, function () {
                    d = 4 === c.offsetWidth
                }),
                e = !0,
                f = !1,
                g = !0,
                a.getComputedStyle && (f = "1%" !== (a.getComputedStyle(c, null) || {}).top,
                    e = "4px" === (a.getComputedStyle(c, null) || {
                        width: "4px"
                    }).width),
                h.removeChild(b),
                c = h = null)
        }
    }(),
        n.swap = function (a, b, c, d) {
            var e, f, g = {};
            for (f in b)
                g[f] = a.style[f],
                    a.style[f] = b[f];
            e = c.apply(a, d || []);
            for (f in b)
                a.style[f] = g[f];
            return e
        }
        ;
    var Nb = /alpha\([^)]*\)/i
        , Ob = /opacity\s*=\s*([^)]*)/
        , Pb = /^(none|table(?!-c[ea]).+)/
        , Qb = new RegExp("^(" + T + ")(.*)$", "i")
        , Rb = new RegExp("^([+-])=(" + T + ")", "i")
        , Sb = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        }
        , Tb = {
            letterSpacing: 0,
            fontWeight: 400
        }
        , Ub = ["Webkit", "O", "Moz", "ms"];
    function Vb(a, b) {
        if (b in a)
            return b;
        var c = b.charAt(0).toUpperCase() + b.slice(1)
            , d = b
            , e = Ub.length;
        while (e--)
            if (b = Ub[e] + c,
                b in a)
                return b;
        return d
    }
    function Wb(a, b) {
        for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++)
            d = a[g],
                d.style && (f[g] = n._data(d, "olddisplay"),
                    c = d.style.display,
                    b ? (f[g] || "none" !== c || (d.style.display = ""),
                        "" === d.style.display && V(d) && (f[g] = n._data(d, "olddisplay", Gb(d.nodeName)))) : f[g] || (e = V(d),
                            (c && "none" !== c || !e) && n._data(d, "olddisplay", e ? c : n.css(d, "display"))));
        for (g = 0; h > g; g++)
            d = a[g],
                d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
        return a
    }
    function Xb(a, b, c) {
        var d = Qb.exec(b);
        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b
    }
    function Yb(a, b, c, d, e) {
        for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2)
            "margin" === c && (g += n.css(a, c + U[f], !0, e)),
                d ? ("content" === c && (g -= n.css(a, "padding" + U[f], !0, e)),
                    "margin" !== c && (g -= n.css(a, "border" + U[f] + "Width", !0, e))) : (g += n.css(a, "padding" + U[f], !0, e),
                        "padding" !== c && (g += n.css(a, "border" + U[f] + "Width", !0, e)));
        return g
    }
    function Zb(a, b, c) {
        var d = !0
            , e = "width" === b ? a.offsetWidth : a.offsetHeight
            , f = Jb(a)
            , g = l.boxSizing() && "border-box" === n.css(a, "boxSizing", !1, f);
        if (0 >= e || null == e) {
            if (e = Kb(a, b, f),
                (0 > e || null == e) && (e = a.style[b]),
                Ib.test(e))
                return e;
            d = g && (l.boxSizingReliable() || e === a.style[b]),
                e = parseFloat(e) || 0
        }
        return e + Yb(a, b, c || (g ? "border" : "content"), d, f) + "px"
    }
    n.extend({
        cssHooks: {
            opacity: {
                get: function (a, b) {
                    if (b) {
                        var c = Kb(a, "opacity");
                        return "" === c ? "1" : c
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": l.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function (a, b, c, d) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                var e, f, g, h = n.camelCase(b), i = a.style;
                if (b = n.cssProps[h] || (n.cssProps[h] = Vb(i, h)),
                    g = n.cssHooks[b] || n.cssHooks[h],
                    void 0 === c)
                    return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
                if (f = typeof c,
                    "string" === f && (e = Rb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b)),
                        f = "number"),
                    null != c && c === c && ("number" !== f || n.cssNumber[h] || (c += "px"),
                        l.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"),
                        !(g && "set" in g && void 0 === (c = g.set(a, c, d)))))
                    try {
                        i[b] = "",
                            i[b] = c
                    } catch (j) { }
            }
        },
        css: function (a, b, c, d) {
            var e, f, g, h = n.camelCase(b);
            return b = n.cssProps[h] || (n.cssProps[h] = Vb(a.style, h)),
                g = n.cssHooks[b] || n.cssHooks[h],
                g && "get" in g && (f = g.get(a, !0, c)),
                void 0 === f && (f = Kb(a, b, d)),
                "normal" === f && b in Tb && (f = Tb[b]),
                "" === c || c ? (e = parseFloat(f),
                    c === !0 || n.isNumeric(e) ? e || 0 : f) : f
        }
    }),
        n.each(["height", "width"], function (a, b) {
            n.cssHooks[b] = {
                get: function (a, c, d) {
                    return c ? 0 === a.offsetWidth && Pb.test(n.css(a, "display")) ? n.swap(a, Sb, function () {
                        return Zb(a, b, d)
                    }) : Zb(a, b, d) : void 0
                },
                set: function (a, c, d) {
                    var e = d && Jb(a);
                    return Xb(a, c, d ? Yb(a, b, d, l.boxSizing() && "border-box" === n.css(a, "boxSizing", !1, e), e) : 0)
                }
            }
        }),
        l.opacity || (n.cssHooks.opacity = {
            get: function (a, b) {
                return Ob.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : ""
            },
            set: function (a, b) {
                var c = a.style
                    , d = a.currentStyle
                    , e = n.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : ""
                    , f = d && d.filter || c.filter || "";
                c.zoom = 1,
                    (b >= 1 || "" === b) && "" === n.trim(f.replace(Nb, "")) && c.removeAttribute && (c.removeAttribute("filter"),
                        "" === b || d && !d.filter) || (c.filter = Nb.test(f) ? f.replace(Nb, e) : f + " " + e)
            }
        }),
        n.cssHooks.marginRight = Mb(l.reliableMarginRight, function (a, b) {
            return b ? n.swap(a, {
                display: "inline-block"
            }, Kb, [a, "marginRight"]) : void 0
        }),
        n.each({
            margin: "",
            padding: "",
            border: "Width"
        }, function (a, b) {
            n.cssHooks[a + b] = {
                expand: function (c) {
                    for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++)
                        e[a + U[d] + b] = f[d] || f[d - 2] || f[0];
                    return e
                }
            },
                Hb.test(a) || (n.cssHooks[a + b].set = Xb)
        }),
        n.fn.extend({
            css: function (a, b) {
                return W(this, function (a, b, c) {
                    var d, e, f = {}, g = 0;
                    if (n.isArray(b)) {
                        for (d = Jb(a),
                            e = b.length; e > g; g++)
                            f[b[g]] = n.css(a, b[g], !1, d);
                        return f
                    }
                    return void 0 !== c ? n.style(a, b, c) : n.css(a, b)
                }, a, b, arguments.length > 1)
            },
            show: function () {
                return Wb(this, !0)
            },
            hide: function () {
                return Wb(this)
            },
            toggle: function (a) {
                return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function () {
                    V(this) ? n(this).show() : n(this).hide()
                })
            }
        });
    function $b(a, b, c, d, e) {
        return new $b.prototype.init(a, b, c, d, e)
    }
    n.Tween = $b,
        $b.prototype = {
            constructor: $b,
            init: function (a, b, c, d, e, f) {
                this.elem = a,
                    this.prop = c,
                    this.easing = e || "swing",
                    this.options = b,
                    this.start = this.now = this.cur(),
                    this.end = d,
                    this.unit = f || (n.cssNumber[c] ? "" : "px")
            },
            cur: function () {
                var a = $b.propHooks[this.prop];
                return a && a.get ? a.get(this) : $b.propHooks._default.get(this)
            },
            run: function (a) {
                var b, c = $b.propHooks[this.prop];
                return this.pos = b = this.options.duration ? n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a,
                    this.now = (this.end - this.start) * b + this.start,
                    this.options.step && this.options.step.call(this.elem, this.now, this),
                    c && c.set ? c.set(this) : $b.propHooks._default.set(this),
                    this
            }
        },
        $b.prototype.init.prototype = $b.prototype,
        $b.propHooks = {
            _default: {
                get: function (a) {
                    var b;
                    return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = n.css(a.elem, a.prop, ""),
                        b && "auto" !== b ? b : 0) : a.elem[a.prop]
                },
                set: function (a) {
                    n.fx.step[a.prop] ? n.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[n.cssProps[a.prop]] || n.cssHooks[a.prop]) ? n.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now
                }
            }
        },
        $b.propHooks.scrollTop = $b.propHooks.scrollLeft = {
            set: function (a) {
                a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
            }
        },
        n.easing = {
            linear: function (a) {
                return a
            },
            swing: function (a) {
                return .5 - Math.cos(a * Math.PI) / 2
            }
        },
        n.fx = $b.prototype.init,
        n.fx.step = {};
    var _b, ac, bc = /^(?:toggle|show|hide)$/, cc = new RegExp("^(?:([+-])=|)(" + T + ")([a-z%]*)$", "i"), dc = /queueHooks$/, ec = [jc], fc = {
        "*": [function (a, b) {
            var c = this.createTween(a, b)
                , d = c.cur()
                , e = cc.exec(b)
                , f = e && e[3] || (n.cssNumber[a] ? "" : "px")
                , g = (n.cssNumber[a] || "px" !== f && +d) && cc.exec(n.css(c.elem, a))
                , h = 1
                , i = 20;
            if (g && g[3] !== f) {
                f = f || g[3],
                    e = e || [],
                    g = +d || 1;
                do
                    h = h || ".5",
                        g /= h,
                        n.style(c.elem, a, g + f);
                while (h !== (h = c.cur() / d) && 1 !== h && --i)
            }
            return e && (g = c.start = +g || +d || 0,
                c.unit = f,
                c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]),
                c
        }
        ]
    };
    function gc() {
        return setTimeout(function () {
            _b = void 0
        }),
            _b = n.now()
    }
    function hc(a, b) {
        var c, d = {
            height: a
        }, e = 0;
        for (b = b ? 1 : 0; 4 > e; e += 2 - b)
            c = U[e],
                d["margin" + c] = d["padding" + c] = a;
        return b && (d.opacity = d.width = a),
            d
    }
    function ic(a, b, c) {
        for (var d, e = (fc[b] || []).concat(fc["*"]), f = 0, g = e.length; g > f; f++)
            if (d = e[f].call(c, b, a))
                return d
    }
    function jc(a, b, c) {
        var d, e, f, g, h, i, j, k, m = this, o = {}, p = a.style, q = a.nodeType && V(a), r = n._data(a, "fxshow");
        c.queue || (h = n._queueHooks(a, "fx"),
            null == h.unqueued && (h.unqueued = 0,
                i = h.empty.fire,
                h.empty.fire = function () {
                    h.unqueued || i()
                }
            ),
            h.unqueued++ ,
            m.always(function () {
                m.always(function () {
                    h.unqueued-- ,
                        n.queue(a, "fx").length || h.empty.fire()
                })
            })),
            1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [p.overflow, p.overflowX, p.overflowY],
                j = n.css(a, "display"),
                k = Gb(a.nodeName),
                "none" === j && (j = k),
                "inline" === j && "none" === n.css(a, "float") && (l.inlineBlockNeedsLayout && "inline" !== k ? p.zoom = 1 : p.display = "inline-block")),
            c.overflow && (p.overflow = "hidden",
                l.shrinkWrapBlocks() || m.always(function () {
                    p.overflow = c.overflow[0],
                        p.overflowX = c.overflow[1],
                        p.overflowY = c.overflow[2]
                }));
        for (d in b)
            if (e = b[d],
                bc.exec(e)) {
                if (delete b[d],
                    f = f || "toggle" === e,
                    e === (q ? "hide" : "show")) {
                    if ("show" !== e || !r || void 0 === r[d])
                        continue;
                    q = !0
                }
                o[d] = r && r[d] || n.style(a, d)
            }
        if (!n.isEmptyObject(o)) {
            r ? "hidden" in r && (q = r.hidden) : r = n._data(a, "fxshow", {}),
                f && (r.hidden = !q),
                q ? n(a).show() : m.done(function () {
                    n(a).hide()
                }),
                m.done(function () {
                    var b;
                    n._removeData(a, "fxshow");
                    for (b in o)
                        n.style(a, b, o[b])
                });
            for (d in o)
                g = ic(q ? r[d] : 0, d, m),
                    d in r || (r[d] = g.start,
                        q && (g.end = g.start,
                            g.start = "width" === d || "height" === d ? 1 : 0))
        }
    }
    function kc(a, b) {
        var c, d, e, f, g;
        for (c in a)
            if (d = n.camelCase(c),
                e = b[d],
                f = a[c],
                n.isArray(f) && (e = f[1],
                    f = a[c] = f[0]),
                c !== d && (a[d] = f,
                    delete a[c]),
                g = n.cssHooks[d],
                g && "expand" in g) {
                f = g.expand(f),
                    delete a[d];
                for (c in f)
                    c in a || (a[c] = f[c],
                        b[c] = e)
            } else
                b[d] = e
    }
    function lc(a, b, c) {
        var d, e, f = 0, g = ec.length, h = n.Deferred().always(function () {
            delete i.elem
        }), i = function () {
            if (e)
                return !1;
            for (var b = _b || gc(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++)
                j.tweens[g].run(f);
            return h.notifyWith(a, [j, f, c]),
                1 > f && i ? c : (h.resolveWith(a, [j]),
                    !1)
        }, j = h.promise({
            elem: a,
            props: n.extend({}, b),
            opts: n.extend(!0, {
                specialEasing: {}
            }, c),
            originalProperties: b,
            originalOptions: c,
            startTime: _b || gc(),
            duration: c.duration,
            tweens: [],
            createTween: function (b, c) {
                var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                return j.tweens.push(d),
                    d
            },
            stop: function (b) {
                var c = 0
                    , d = b ? j.tweens.length : 0;
                if (e)
                    return this;
                for (e = !0; d > c; c++)
                    j.tweens[c].run(1);
                return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]),
                    this
            }
        }), k = j.props;
        for (kc(k, j.opts.specialEasing); g > f; f++)
            if (d = ec[f].call(j, a, k, j.opts))
                return d;
        return n.map(k, ic, j),
            n.isFunction(j.opts.start) && j.opts.start.call(a, j),
            n.fx.timer(n.extend(i, {
                elem: a,
                anim: j,
                queue: j.opts.queue
            })),
            j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)
    }
    n.Animation = n.extend(lc, {
        tweener: function (a, b) {
            n.isFunction(a) ? (b = a,
                a = ["*"]) : a = a.split(" ");
            for (var c, d = 0, e = a.length; e > d; d++)
                c = a[d],
                    fc[c] = fc[c] || [],
                    fc[c].unshift(b)
        },
        prefilter: function (a, b) {
            b ? ec.unshift(a) : ec.push(a)
        }
    }),
        n.speed = function (a, b, c) {
            var d = a && "object" == typeof a ? n.extend({}, a) : {
                complete: c || !c && b || n.isFunction(a) && a,
                duration: a,
                easing: c && b || b && !n.isFunction(b) && b
            };
            return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default,
                (null == d.queue || d.queue === !0) && (d.queue = "fx"),
                d.old = d.complete,
                d.complete = function () {
                    n.isFunction(d.old) && d.old.call(this),
                        d.queue && n.dequeue(this, d.queue)
                }
                ,
                d
        }
        ,
        n.fn.extend({
            fadeTo: function (a, b, c, d) {
                return this.filter(V).css("opacity", 0).show().end().animate({
                    opacity: b
                }, a, c, d)
            },
            animate: function (a, b, c, d) {
                var e = n.isEmptyObject(a)
                    , f = n.speed(b, c, d)
                    , g = function () {
                        var b = lc(this, n.extend({}, a), f);
                        (e || n._data(this, "finish")) && b.stop(!0)
                    };
                return g.finish = g,
                    e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
            },
            stop: function (a, b, c) {
                var d = function (a) {
                    var b = a.stop;
                    delete a.stop,
                        b(c)
                };
                return "string" != typeof a && (c = b,
                    b = a,
                    a = void 0),
                    b && a !== !1 && this.queue(a || "fx", []),
                    this.each(function () {
                        var b = !0
                            , e = null != a && a + "queueHooks"
                            , f = n.timers
                            , g = n._data(this);
                        if (e)
                            g[e] && g[e].stop && d(g[e]);
                        else
                            for (e in g)
                                g[e] && g[e].stop && dc.test(e) && d(g[e]);
                        for (e = f.length; e--;)
                            f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c),
                                b = !1,
                                f.splice(e, 1));
                        (b || !c) && n.dequeue(this, a)
                    })
            },
            finish: function (a) {
                return a !== !1 && (a = a || "fx"),
                    this.each(function () {
                        var b, c = n._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = n.timers, g = d ? d.length : 0;
                        for (c.finish = !0,
                            n.queue(this, a, []),
                            e && e.stop && e.stop.call(this, !0),
                            b = f.length; b--;)
                            f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0),
                                f.splice(b, 1));
                        for (b = 0; g > b; b++)
                            d[b] && d[b].finish && d[b].finish.call(this);
                        delete c.finish
                    })
            }
        }),
        n.each(["toggle", "show", "hide"], function (a, b) {
            var c = n.fn[b];
            n.fn[b] = function (a, d, e) {
                return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(hc(b, !0), a, d, e)
            }
        }),
        n.each({
            slideDown: hc("show"),
            slideUp: hc("hide"),
            slideToggle: hc("toggle"),
            fadeIn: {
                opacity: "show"
            },
            fadeOut: {
                opacity: "hide"
            },
            fadeToggle: {
                opacity: "toggle"
            }
        }, function (a, b) {
            n.fn[a] = function (a, c, d) {
                return this.animate(b, a, c, d)
            }
        }),
        n.timers = [],
        n.fx.tick = function () {
            var a, b = n.timers, c = 0;
            for (_b = n.now(); c < b.length; c++)
                a = b[c],
                    a() || b[c] !== a || b.splice(c--, 1);
            b.length || n.fx.stop(),
                _b = void 0
        }
        ,
        n.fx.timer = function (a) {
            n.timers.push(a),
                a() ? n.fx.start() : n.timers.pop()
        }
        ,
        n.fx.interval = 13,
        n.fx.start = function () {
            ac || (ac = setInterval(n.fx.tick, n.fx.interval))
        }
        ,
        n.fx.stop = function () {
            clearInterval(ac),
                ac = null
        }
        ,
        n.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        },
        n.fn.delay = function (a, b) {
            return a = n.fx ? n.fx.speeds[a] || a : a,
                b = b || "fx",
                this.queue(b, function (b, c) {
                    var d = setTimeout(b, a);
                    c.stop = function () {
                        clearTimeout(d)
                    }
                })
        }
        ,
        function () {
            var a, b, c, d, e = z.createElement("div");
            e.setAttribute("className", "t"),
                e.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",
                a = e.getElementsByTagName("a")[0],
                c = z.createElement("select"),
                d = c.appendChild(z.createElement("option")),
                b = e.getElementsByTagName("input")[0],
                a.style.cssText = "top:1px",
                l.getSetAttribute = "t" !== e.className,
                l.style = /top/.test(a.getAttribute("style")),
                l.hrefNormalized = "/a" === a.getAttribute("href"),
                l.checkOn = !!b.value,
                l.optSelected = d.selected,
                l.enctype = !!z.createElement("form").enctype,
                c.disabled = !0,
                l.optDisabled = !d.disabled,
                b = z.createElement("input"),
                b.setAttribute("value", ""),
                l.input = "" === b.getAttribute("value"),
                b.value = "t",
                b.setAttribute("type", "radio"),
                l.radioValue = "t" === b.value,
                a = b = c = d = e = null
        }();
    var mc = /\r/g;
    n.fn.extend({
        val: function (a) {
            var b, c, d, e = this[0];
            {
                if (arguments.length)
                    return d = n.isFunction(a),
                        this.each(function (c) {
                            var e;
                            1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a,
                                null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) && (e = n.map(e, function (a) {
                                    return null == a ? "" : a + ""
                                })),
                                b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()],
                                b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e))
                        });
                if (e)
                    return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()],
                        b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value,
                            "string" == typeof c ? c.replace(mc, "") : null == c ? "" : c)
            }
        }
    }),
        n.extend({
            valHooks: {
                option: {
                    get: function (a) {
                        var b = n.find.attr(a, "value");
                        return null != b ? b : n.text(a)
                    }
                },
                select: {
                    get: function (a) {
                        for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)
                            if (c = d[i],
                                !(!c.selected && i !== e || (l.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && n.nodeName(c.parentNode, "optgroup"))) {
                                if (b = n(c).val(),
                                    f)
                                    return b;
                                g.push(b)
                            }
                        return g
                    },
                    set: function (a, b) {
                        var c, d, e = a.options, f = n.makeArray(b), g = e.length;
                        while (g--)
                            if (d = e[g],
                                n.inArray(n.valHooks.option.get(d), f) >= 0)
                                try {
                                    d.selected = c = !0
                                } catch (h) {
                                    d.scrollHeight
                                }
                            else
                                d.selected = !1;
                        return c || (a.selectedIndex = -1),
                            e
                    }
                }
            }
        }),
        n.each(["radio", "checkbox"], function () {
            n.valHooks[this] = {
                set: function (a, b) {
                    return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) >= 0 : void 0
                }
            },
                l.checkOn || (n.valHooks[this].get = function (a) {
                    return null === a.getAttribute("value") ? "on" : a.value
                }
                )
        });
    var nc, oc, pc = n.expr.attrHandle, qc = /^(?:checked|selected)$/i, rc = l.getSetAttribute, sc = l.input;
    n.fn.extend({
        attr: function (a, b) {
            return W(this, n.attr, a, b, arguments.length > 1)
        },
        removeAttr: function (a) {
            return this.each(function () {
                n.removeAttr(this, a)
            })
        }
    }),
        n.extend({
            attr: function (a, b, c) {
                var d, e, f = a.nodeType;
                if (a && 3 !== f && 8 !== f && 2 !== f)
                    return typeof a.getAttribute === L ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(),
                        d = n.attrHooks[b] || (n.expr.match.bool.test(b) ? oc : nc)),
                        void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = n.find.attr(a, b),
                            null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""),
                                c) : void n.removeAttr(a, b))
            },
            removeAttr: function (a, b) {
                var c, d, e = 0, f = b && b.match(F);
                if (f && 1 === a.nodeType)
                    while (c = f[e++])
                        d = n.propFix[c] || c,
                            n.expr.match.bool.test(c) ? sc && rc || !qc.test(c) ? a[d] = !1 : a[n.camelCase("default-" + c)] = a[d] = !1 : n.attr(a, c, ""),
                            a.removeAttribute(rc ? c : d)
            },
            attrHooks: {
                type: {
                    set: function (a, b) {
                        if (!l.radioValue && "radio" === b && n.nodeName(a, "input")) {
                            var c = a.value;
                            return a.setAttribute("type", b),
                                c && (a.value = c),
                                b
                        }
                    }
                }
            }
        }),
        oc = {
            set: function (a, b, c) {
                return b === !1 ? n.removeAttr(a, c) : sc && rc || !qc.test(c) ? a.setAttribute(!rc && n.propFix[c] || c, c) : a[n.camelCase("default-" + c)] = a[c] = !0,
                    c
            }
        },
        n.each(n.expr.match.bool.source.match(/\w+/g), function (a, b) {
            var c = pc[b] || n.find.attr;
            pc[b] = sc && rc || !qc.test(b) ? function (a, b, d) {
                var e, f;
                return d || (f = pc[b],
                    pc[b] = e,
                    e = null != c(a, b, d) ? b.toLowerCase() : null,
                    pc[b] = f),
                    e
            }
                : function (a, b, c) {
                    return c ? void 0 : a[n.camelCase("default-" + b)] ? b.toLowerCase() : null
                }
        }),
        sc && rc || (n.attrHooks.value = {
            set: function (a, b, c) {
                return n.nodeName(a, "input") ? void (a.defaultValue = b) : nc && nc.set(a, b, c)
            }
        }),
        rc || (nc = {
            set: function (a, b, c) {
                var d = a.getAttributeNode(c);
                return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)),
                    d.value = b += "",
                    "value" === c || b === a.getAttribute(c) ? b : void 0
            }
        },
            pc.id = pc.name = pc.coords = function (a, b, c) {
                var d;
                return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null
            }
            ,
            n.valHooks.button = {
                get: function (a, b) {
                    var c = a.getAttributeNode(b);
                    return c && c.specified ? c.value : void 0
                },
                set: nc.set
            },
            n.attrHooks.contenteditable = {
                set: function (a, b, c) {
                    nc.set(a, "" === b ? !1 : b, c)
                }
            },
            n.each(["width", "height"], function (a, b) {
                n.attrHooks[b] = {
                    set: function (a, c) {
                        return "" === c ? (a.setAttribute(b, "auto"),
                            c) : void 0
                    }
                }
            })),
        l.style || (n.attrHooks.style = {
            get: function (a) {
                return a.style.cssText || void 0
            },
            set: function (a, b) {
                return a.style.cssText = b + ""
            }
        });
    var tc = /^(?:input|select|textarea|button|object)$/i
        , uc = /^(?:a|area)$/i;
    n.fn.extend({
        prop: function (a, b) {
            return W(this, n.prop, a, b, arguments.length > 1)
        },
        removeProp: function (a) {
            return a = n.propFix[a] || a,
                this.each(function () {
                    try {
                        this[a] = void 0,
                            delete this[a]
                    } catch (b) { }
                })
        }
    }),
        n.extend({
            propFix: {
                "for": "htmlFor",
                "class": "className"
            },
            prop: function (a, b, c) {
                var d, e, f, g = a.nodeType;
                if (a && 3 !== g && 8 !== g && 2 !== g)
                    return f = 1 !== g || !n.isXMLDoc(a),
                        f && (b = n.propFix[b] || b,
                            e = n.propHooks[b]),
                        void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
            },
            propHooks: {
                tabIndex: {
                    get: function (a) {
                        var b = n.find.attr(a, "tabindex");
                        return b ? parseInt(b, 10) : tc.test(a.nodeName) || uc.test(a.nodeName) && a.href ? 0 : -1
                    }
                }
            }
        }),
        l.hrefNormalized || n.each(["href", "src"], function (a, b) {
            n.propHooks[b] = {
                get: function (a) {
                    return a.getAttribute(b, 4)
                }
            }
        }),
        l.optSelected || (n.propHooks.selected = {
            get: function (a) {
                var b = a.parentNode;
                return b && (b.selectedIndex,
                    b.parentNode && b.parentNode.selectedIndex),
                    null
            }
        }),
        n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
            n.propFix[this.toLowerCase()] = this
        }),
        l.enctype || (n.propFix.enctype = "encoding");
    var vc = /[\t\r\n\f]/g;
    n.fn.extend({
        addClass: function (a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a;
            if (n.isFunction(a))
                return this.each(function (b) {
                    n(this).addClass(a.call(this, b, this.className))
                });
            if (j)
                for (b = (a || "").match(F) || []; i > h; h++)
                    if (c = this[h],
                        d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(vc, " ") : " ")) {
                        f = 0;
                        while (e = b[f++])
                            d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                        g = n.trim(d),
                            c.className !== g && (c.className = g)
                    }
            return this
        },
        removeClass: function (a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a;
            if (n.isFunction(a))
                return this.each(function (b) {
                    n(this).removeClass(a.call(this, b, this.className))
                });
            if (j)
                for (b = (a || "").match(F) || []; i > h; h++)
                    if (c = this[h],
                        d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(vc, " ") : "")) {
                        f = 0;
                        while (e = b[f++])
                            while (d.indexOf(" " + e + " ") >= 0)
                                d = d.replace(" " + e + " ", " ");
                        g = a ? n.trim(d) : "",
                            c.className !== g && (c.className = g)
                    }
            return this
        },
        toggleClass: function (a, b) {
            var c = typeof a;
            return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(n.isFunction(a) ? function (c) {
                n(this).toggleClass(a.call(this, c, this.className, b), b)
            }
                : function () {
                    if ("string" === c) {
                        var b, d = 0, e = n(this), f = a.match(F) || [];
                        while (b = f[d++])
                            e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
                    } else
                        (c === L || "boolean" === c) && (this.className && n._data(this, "__className__", this.className),
                            this.className = this.className || a === !1 ? "" : n._data(this, "__className__") || "")
                }
            )
        },
        hasClass: function (a) {
            for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++)
                if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(vc, " ").indexOf(b) >= 0)
                    return !0;
            return !1
        }
    }),
        n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (a, b) {
            n.fn[b] = function (a, c) {
                return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
            }
        }),
        n.fn.extend({
            hover: function (a, b) {
                return this.mouseenter(a).mouseleave(b || a)
            },
            bind: function (a, b, c) {
                return this.on(a, null, b, c)
            },
            unbind: function (a, b) {
                return this.off(a, null, b)
            },
            delegate: function (a, b, c, d) {
                return this.on(b, a, c, d)
            },
            undelegate: function (a, b, c) {
                return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
            }
        });
    var wc = n.now()
        , xc = /\?/
        , yc = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    n.parseJSON = function (b) {
        if (a.JSON && a.JSON.parse)
            return a.JSON.parse(b + "");
        var c, d = null, e = n.trim(b + "");
        return e && !n.trim(e.replace(yc, function (a, b, e, f) {
            return c && b && (d = 0),
                0 === d ? a : (c = e || b,
                    d += !f - !e,
                    "")
        })) ? Function("return " + e)() : n.error("Invalid JSON: " + b)
    }
        ,
        n.parseXML = function (b) {
            var c, d;
            if (!b || "string" != typeof b)
                return null;
            try {
                a.DOMParser ? (d = new DOMParser,
                    c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"),
                        c.async = "false",
                        c.loadXML(b))
            } catch (e) {
                c = void 0
            }
            return c && c.documentElement && !c.getElementsByTagName("parsererror").length || n.error("Invalid XML: " + b),
                c
        }
        ;
    var zc, Ac, Bc = /#.*$/, Cc = /([?&])_=[^&]*/, Dc = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Ec = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Fc = /^(?:GET|HEAD)$/, Gc = /^\/\//, Hc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Ic = {}, Jc = {}, Kc = "*/".concat("*");
    try {
        Ac = location.href
    } catch (Lc) {
        Ac = z.createElement("a"),
            Ac.href = "",
            Ac = Ac.href
    }
    zc = Hc.exec(Ac.toLowerCase()) || [];
    function Mc(a) {
        return function (b, c) {
            "string" != typeof b && (c = b,
                b = "*");
            var d, e = 0, f = b.toLowerCase().match(F) || [];
            if (n.isFunction(c))
                while (d = f[e++])
                    "+" === d.charAt(0) ? (d = d.slice(1) || "*",
                        (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
        }
    }
    function Nc(a, b, c, d) {
        var e = {}
            , f = a === Jc;
        function g(h) {
            var i;
            return e[h] = !0,
                n.each(a[h] || [], function (a, h) {
                    var j = h(b, c, d);
                    return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j),
                        g(j),
                        !1)
                }),
                i
        }
        return g(b.dataTypes[0]) || !e["*"] && g("*")
    }
    function Oc(a, b) {
        var c, d, e = n.ajaxSettings.flatOptions || {};
        for (d in b)
            void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]);
        return c && n.extend(!0, a, c),
            a
    }
    function Pc(a, b, c) {
        var d, e, f, g, h = a.contents, i = a.dataTypes;
        while ("*" === i[0])
            i.shift(),
                void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type"));
        if (e)
            for (g in h)
                if (h[g] && h[g].test(e)) {
                    i.unshift(g);
                    break
                }
        if (i[0] in c)
            f = i[0];
        else {
            for (g in c) {
                if (!i[0] || a.converters[g + " " + i[0]]) {
                    f = g;
                    break
                }
                d || (d = g)
            }
            f = f || d
        }
        return f ? (f !== i[0] && i.unshift(f),
            c[f]) : void 0
    }
    function Qc(a, b, c, d) {
        var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
        if (k[1])
            for (g in a.converters)
                j[g.toLowerCase()] = a.converters[g];
        f = k.shift();
        while (f)
            if (a.responseFields[f] && (c[a.responseFields[f]] = b),
                !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)),
                i = f,
                f = k.shift())
                if ("*" === f)
                    f = i;
                else if ("*" !== i && i !== f) {
                    if (g = j[i + " " + f] || j["* " + f],
                        !g)
                        for (e in j)
                            if (h = e.split(" "),
                                h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                                g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0],
                                    k.unshift(h[1]));
                                break
                            }
                    if (g !== !0)
                        if (g && a["throws"])
                            b = g(b);
                        else
                            try {
                                b = g(b)
                            } catch (l) {
                                return {
                                    state: "parsererror",
                                    error: g ? l : "No conversion from " + i + " to " + f
                                }
                            }
                }
        return {
            state: "success",
            data: b
        }
    }
    n.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Ac,
            type: "GET",
            isLocal: Ec.test(zc[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Kc,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": n.parseJSON,
                "text xml": n.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function (a, b) {
            return b ? Oc(Oc(a, n.ajaxSettings), b) : Oc(n.ajaxSettings, a)
        },
        ajaxPrefilter: Mc(Ic),
        ajaxTransport: Mc(Jc),
        ajax: function (a, b) {
            "object" == typeof a && (b = a,
                a = void 0),
                b = b || {};
            var c, d, e, f, g, h, i, j, k = n.ajaxSetup({}, b), l = k.context || k, m = k.context && (l.nodeType || l.jquery) ? n(l) : n.event, o = n.Deferred(), p = n.Callbacks("once memory"), q = k.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = {
                readyState: 0,
                getResponseHeader: function (a) {
                    var b;
                    if (2 === t) {
                        if (!j) {
                            j = {};
                            while (b = Dc.exec(f))
                                j[b[1].toLowerCase()] = b[2]
                        }
                        b = j[a.toLowerCase()]
                    }
                    return null == b ? null : b
                },
                getAllResponseHeaders: function () {
                    return 2 === t ? f : null
                },
                setRequestHeader: function (a, b) {
                    var c = a.toLowerCase();
                    return t || (a = s[c] = s[c] || a,
                        r[a] = b),
                        this
                },
                overrideMimeType: function (a) {
                    return t || (k.mimeType = a),
                        this
                },
                statusCode: function (a) {
                    var b;
                    if (a)
                        if (2 > t)
                            for (b in a)
                                q[b] = [q[b], a[b]];
                        else
                            v.always(a[v.status]);
                    return this
                },
                abort: function (a) {
                    var b = a || u;
                    return i && i.abort(b),
                        x(0, b),
                        this
                }
            };
            if (o.promise(v).complete = p.add,
                v.success = v.done,
                v.error = v.fail,
                k.url = ((a || k.url || Ac) + "").replace(Bc, "").replace(Gc, zc[1] + "//"),
                k.type = b.method || b.type || k.method || k.type,
                k.dataTypes = n.trim(k.dataType || "*").toLowerCase().match(F) || [""],
                null == k.crossDomain && (c = Hc.exec(k.url.toLowerCase()),
                    k.crossDomain = !(!c || c[1] === zc[1] && c[2] === zc[2] && (c[3] || ("http:" === c[1] ? "80" : "443")) === (zc[3] || ("http:" === zc[1] ? "80" : "443")))),
                k.data && k.processData && "string" != typeof k.data && (k.data = n.param(k.data, k.traditional)),
                Nc(Ic, k, b, v),
                2 === t)
                return v;
            h = k.global,
                h && 0 === n.active++ && n.event.trigger("ajaxStart"),
                k.type = k.type.toUpperCase(),
                k.hasContent = !Fc.test(k.type),
                e = k.url,
                k.hasContent || (k.data && (e = k.url += (xc.test(e) ? "&" : "?") + k.data,
                    delete k.data),
                    k.cache === !1 && (k.url = Cc.test(e) ? e.replace(Cc, "$1_=" + wc++) : e + (xc.test(e) ? "&" : "?") + "_=" + wc++)),
                k.ifModified && (n.lastModified[e] && v.setRequestHeader("If-Modified-Since", n.lastModified[e]),
                    n.etag[e] && v.setRequestHeader("If-None-Match", n.etag[e])),
                (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType),
                v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Kc + "; q=0.01" : "") : k.accepts["*"]);
            for (d in k.headers)
                v.setRequestHeader(d, k.headers[d]);
            if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t))
                return v.abort();
            u = "abort";
            for (d in {
                success: 1,
                error: 1,
                complete: 1
            })
                v[d](k[d]);
            if (i = Nc(Jc, k, b, v)) {
                v.readyState = 1,
                    h && m.trigger("ajaxSend", [v, k]),
                    k.async && k.timeout > 0 && (g = setTimeout(function () {
                        v.abort("timeout")
                    }, k.timeout));
                try {
                    t = 1,
                        i.send(r, x)
                } catch (w) {
                    if (!(2 > t))
                        throw w;
                    x(-1, w)
                }
            } else
                x(-1, "No Transport");
            function x(a, b, c, d) {
                var j, r, s, u, w, x = b;
                2 !== t && (t = 2,
                    g && clearTimeout(g),
                    i = void 0,
                    f = d || "",
                    v.readyState = a > 0 ? 4 : 0,
                    j = a >= 200 && 300 > a || 304 === a,
                    c && (u = Pc(k, v, c)),
                    u = Qc(k, u, v, j),
                    j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"),
                        w && (n.lastModified[e] = w),
                        w = v.getResponseHeader("etag"),
                        w && (n.etag[e] = w)),
                        204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state,
                            r = u.data,
                            s = u.error,
                            j = !s)) : (s = x,
                                (a || !x) && (x = "error",
                                    0 > a && (a = 0))),
                    v.status = a,
                    v.statusText = (b || x) + "",
                    j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]),
                    v.statusCode(q),
                    q = void 0,
                    h && m.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]),
                    p.fireWith(l, [v, x]),
                    h && (m.trigger("ajaxComplete", [v, k]),
                        --n.active || n.event.trigger("ajaxStop")))
            }
            return v
        },
        getJSON: function (a, b, c) {
            return n.get(a, b, c, "json")
        },
        getScript: function (a, b) {
            return n.get(a, void 0, b, "script")
        }
    }),
        n.each(["get", "post"], function (a, b) {
            n[b] = function (a, c, d, e) {
                return n.isFunction(c) && (e = e || d,
                    d = c,
                    c = void 0),
                    n.ajax({
                        url: a,
                        type: b,
                        dataType: e,
                        data: c,
                        success: d
                    })
            }
        }),
        n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (a, b) {
            n.fn[b] = function (a) {
                return this.on(b, a)
            }
        }),
        n._evalUrl = function (a) {
            return n.ajax({
                url: a,
                type: "GET",
                dataType: "script",
                async: !1,
                global: !1,
                "throws": !0
            })
        }
        ,
        n.fn.extend({
            wrapAll: function (a) {
                if (n.isFunction(a))
                    return this.each(function (b) {
                        n(this).wrapAll(a.call(this, b))
                    });
                if (this[0]) {
                    var b = n(a, this[0].ownerDocument).eq(0).clone(!0);
                    this[0].parentNode && b.insertBefore(this[0]),
                        b.map(function () {
                            var a = this;
                            while (a.firstChild && 1 === a.firstChild.nodeType)
                                a = a.firstChild;
                            return a
                        }).append(this)
                }
                return this
            },
            wrapInner: function (a) {
                return this.each(n.isFunction(a) ? function (b) {
                    n(this).wrapInner(a.call(this, b))
                }
                    : function () {
                        var b = n(this)
                            , c = b.contents();
                        c.length ? c.wrapAll(a) : b.append(a)
                    }
                )
            },
            wrap: function (a) {
                var b = n.isFunction(a);
                return this.each(function (c) {
                    n(this).wrapAll(b ? a.call(this, c) : a)
                })
            },
            unwrap: function () {
                return this.parent().each(function () {
                    n.nodeName(this, "body") || n(this).replaceWith(this.childNodes)
                }).end()
            }
        }),
        n.expr.filters.hidden = function (a) {
            return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !l.reliableHiddenOffsets() && "none" === (a.style && a.style.display || n.css(a, "display"))
        }
        ,
        n.expr.filters.visible = function (a) {
            return !n.expr.filters.hidden(a)
        }
        ;
    var Rc = /%20/g
        , Sc = /\[\]$/
        , Tc = /\r?\n/g
        , Uc = /^(?:submit|button|image|reset|file)$/i
        , Vc = /^(?:input|select|textarea|keygen)/i;
    function Wc(a, b, c, d) {
        var e;
        if (n.isArray(b))
            n.each(b, function (b, e) {
                c || Sc.test(a) ? d(a, e) : Wc(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d)
            });
        else if (c || "object" !== n.type(b))
            d(a, b);
        else
            for (e in b)
                Wc(a + "[" + e + "]", b[e], c, d)
    }
    n.param = function (a, b) {
        var c, d = [], e = function (a, b) {
            b = n.isFunction(b) ? b() : null == b ? "" : b,
                d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
        };
        if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional),
            n.isArray(a) || a.jquery && !n.isPlainObject(a))
            n.each(a, function () {
                e(this.name, this.value)
            });
        else
            for (c in a)
                Wc(c, a[c], b, e);
        return d.join("&").replace(Rc, "+")
    }
        ,
        n.fn.extend({
            serialize: function () {
                return n.param(this.serializeArray())
            },
            serializeArray: function () {
                return this.map(function () {
                    var a = n.prop(this, "elements");
                    return a ? n.makeArray(a) : this
                }).filter(function () {
                    var a = this.type;
                    return this.name && !n(this).is(":disabled") && Vc.test(this.nodeName) && !Uc.test(a) && (this.checked || !X.test(a))
                }).map(function (a, b) {
                    var c = n(this).val();
                    return null == c ? null : n.isArray(c) ? n.map(c, function (a) {
                        return {
                            name: b.name,
                            value: a.replace(Tc, "\r\n")
                        }
                    }) : {
                            name: b.name,
                            value: c.replace(Tc, "\r\n")
                        }
                }).get()
            }
        }),
        n.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function () {
            return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && $c() || _c()
        }
            : $c;
    var Xc = 0
        , Yc = {}
        , Zc = n.ajaxSettings.xhr();
    a.ActiveXObject && n(a).on("unload", function () {
        for (var a in Yc)
            Yc[a](void 0, !0)
    }),
        l.cors = !!Zc && "withCredentials" in Zc,
        Zc = l.ajax = !!Zc,
        Zc && n.ajaxTransport(function (a) {
            if (!a.crossDomain || l.cors) {
                var b;
                return {
                    send: function (c, d) {
                        var e, f = a.xhr(), g = ++Xc;
                        if (f.open(a.type, a.url, a.async, a.username, a.password),
                            a.xhrFields)
                            for (e in a.xhrFields)
                                f[e] = a.xhrFields[e];
                        a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType),
                            a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
                        for (e in c)
                            void 0 !== c[e] && f.setRequestHeader(e, c[e] + "");
                        f.send(a.hasContent && a.data || null),
                            b = function (c, e) {
                                var h, i, j;
                                if (b && (e || 4 === f.readyState))
                                    if (delete Yc[g],
                                        b = void 0,
                                        f.onreadystatechange = n.noop,
                                        e)
                                        4 !== f.readyState && f.abort();
                                    else {
                                        j = {},
                                            h = f.status,
                                            "string" == typeof f.responseText && (j.text = f.responseText);
                                        try {
                                            i = f.statusText
                                        } catch (k) {
                                            i = ""
                                        }
                                        h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404
                                    }
                                j && d(h, i, j, f.getAllResponseHeaders())
                            }
                            ,
                            a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Yc[g] = b : b()
                    },
                    abort: function () {
                        b && b(void 0, !0)
                    }
                }
            }
        });
    function $c() {
        try {
            return new a.XMLHttpRequest
        } catch (b) { }
    }
    function _c() {
        try {
            return new a.ActiveXObject("Microsoft.XMLHTTP")
        } catch (b) { }
    }
    n.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function (a) {
                return n.globalEval(a),
                    a
            }
        }
    }),
        n.ajaxPrefilter("script", function (a) {
            void 0 === a.cache && (a.cache = !1),
                a.crossDomain && (a.type = "GET",
                    a.global = !1)
        }),
        n.ajaxTransport("script", function (a) {
            if (a.crossDomain) {
                var b, c = z.head || n("head")[0] || z.documentElement;
                return {
                    send: function (d, e) {
                        b = z.createElement("script"),
                            b.async = !0,
                            a.scriptCharset && (b.charset = a.scriptCharset),
                            b.src = a.url,
                            b.onload = b.onreadystatechange = function (a, c) {
                                (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null,
                                    b.parentNode && b.parentNode.removeChild(b),
                                    b = null,
                                    c || e(200, "success"))
                            }
                            ,
                            c.insertBefore(b, c.firstChild)
                    },
                    abort: function () {
                        b && b.onload(void 0, !0)
                    }
                }
            }
        });
    var ad = []
        , bd = /(=)\?(?=&|$)|\?\?/;
    n.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function () {
            var a = ad.pop() || n.expando + "_" + wc++;
            return this[a] = !0,
                a
        }
    }),
        n.ajaxPrefilter("json jsonp", function (b, c, d) {
            var e, f, g, h = b.jsonp !== !1 && (bd.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && bd.test(b.data) && "data");
            return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback,
                h ? b[h] = b[h].replace(bd, "$1" + e) : b.jsonp !== !1 && (b.url += (xc.test(b.url) ? "&" : "?") + b.jsonp + "=" + e),
                b.converters["script json"] = function () {
                    return g || n.error(e + " was not called"),
                        g[0]
                }
                ,
                b.dataTypes[0] = "json",
                f = a[e],
                a[e] = function () {
                    g = arguments
                }
                ,
                d.always(function () {
                    a[e] = f,
                        b[e] && (b.jsonpCallback = c.jsonpCallback,
                            ad.push(e)),
                        g && n.isFunction(f) && f(g[0]),
                        g = f = void 0
                }),
                "script") : void 0
        }),
        n.parseHTML = function (a, b, c) {
            if (!a || "string" != typeof a)
                return null;
            "boolean" == typeof b && (c = b,
                b = !1),
                b = b || z;
            var d = v.exec(a)
                , e = !c && [];
            return d ? [b.createElement(d[1])] : (d = n.buildFragment([a], b, e),
                e && e.length && n(e).remove(),
                n.merge([], d.childNodes))
        }
        ;
    var cd = n.fn.load;
    n.fn.load = function (a, b, c) {
        if ("string" != typeof a && cd)
            return cd.apply(this, arguments);
        var d, e, f, g = this, h = a.indexOf(" ");
        return h >= 0 && (d = a.slice(h, a.length),
            a = a.slice(0, h)),
            n.isFunction(b) ? (c = b,
                b = void 0) : b && "object" == typeof b && (f = "POST"),
            g.length > 0 && n.ajax({
                url: a,
                type: f,
                dataType: "html",
                data: b
            }).done(function (a) {
                e = arguments,
                    g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a)
            }).complete(c && function (a, b) {
                g.each(c, e || [a.responseText, b, a])
            }
            ),
            this
    }
        ,
        n.expr.filters.animated = function (a) {
            return n.grep(n.timers, function (b) {
                return a === b.elem
            }).length
        }
        ;
    var dd = a.document.documentElement;
    function ed(a) {
        return n.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1
    }
    n.offset = {
        setOffset: function (a, b, c) {
            var d, e, f, g, h, i, j, k = n.css(a, "position"), l = n(a), m = {};
            "static" === k && (a.style.position = "relative"),
                h = l.offset(),
                f = n.css(a, "top"),
                i = n.css(a, "left"),
                j = ("absolute" === k || "fixed" === k) && n.inArray("auto", [f, i]) > -1,
                j ? (d = l.position(),
                    g = d.top,
                    e = d.left) : (g = parseFloat(f) || 0,
                        e = parseFloat(i) || 0),
                n.isFunction(b) && (b = b.call(a, c, h)),
                null != b.top && (m.top = b.top - h.top + g),
                null != b.left && (m.left = b.left - h.left + e),
                "using" in b ? b.using.call(a, m) : l.css(m)
        }
    },
        n.fn.extend({
            offset: function (a) {
                if (arguments.length)
                    return void 0 === a ? this : this.each(function (b) {
                        n.offset.setOffset(this, a, b)
                    });
                var b, c, d = {
                    top: 0,
                    left: 0
                }, e = this[0], f = e && e.ownerDocument;
                if (f)
                    return b = f.documentElement,
                        n.contains(b, e) ? (typeof e.getBoundingClientRect !== L && (d = e.getBoundingClientRect()),
                            c = ed(f),
                            {
                                top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                                left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
                            }) : d
            },
            position: function () {
                if (this[0]) {
                    var a, b, c = {
                        top: 0,
                        left: 0
                    }, d = this[0];
                    return "fixed" === n.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(),
                        b = this.offset(),
                        n.nodeName(a[0], "html") || (c = a.offset()),
                        c.top += n.css(a[0], "borderTopWidth", !0),
                        c.left += n.css(a[0], "borderLeftWidth", !0)),
                        {
                            top: b.top - c.top - n.css(d, "marginTop", !0),
                            left: b.left - c.left - n.css(d, "marginLeft", !0)
                        }
                }
            },
            offsetParent: function () {
                return this.map(function () {
                    var a = this.offsetParent || dd;
                    while (a && !n.nodeName(a, "html") && "static" === n.css(a, "position"))
                        a = a.offsetParent;
                    return a || dd
                })
            }
        }),
        n.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
        }, function (a, b) {
            var c = /Y/.test(b);
            n.fn[a] = function (d) {
                return W(this, function (a, d, e) {
                    var f = ed(a);
                    return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? n(f).scrollLeft() : e, c ? e : n(f).scrollTop()) : a[d] = e)
                }, a, d, arguments.length, null)
            }
        }),
        n.each(["top", "left"], function (a, b) {
            n.cssHooks[b] = Mb(l.pixelPosition, function (a, c) {
                return c ? (c = Kb(a, b),
                    Ib.test(c) ? n(a).position()[b] + "px" : c) : void 0
            })
        }),
        n.each({
            Height: "height",
            Width: "width"
        }, function (a, b) {
            n.each({
                padding: "inner" + a,
                content: b,
                "": "outer" + a
            }, function (c, d) {
                n.fn[d] = function (d, e) {
                    var f = arguments.length && (c || "boolean" != typeof d)
                        , g = c || (d === !0 || e === !0 ? "margin" : "border");
                    return W(this, function (b, c, d) {
                        var e;
                        return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement,
                            Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g)
                    }, b, f ? d : void 0, f, null)
                }
            })
        }),
        n.fn.size = function () {
            return this.length
        }
        ,
        n.fn.andSelf = n.fn.addBack,
        "function" == typeof define && define.amd && define("jquery", [], function () {
            return n
        });
    var fd = a.jQuery
        , gd = a.$;
    return n.noConflict = function (b) {
        return a.$ === n && (a.$ = gd),
            b && a.jQuery === n && (a.jQuery = fd),
            n
    }
        ,
        typeof b === L && (a.jQuery = a.$ = n),
        n
});
/*!
 * Detectizr v@VERSION
 * http://barisaydinoglu.github.com/Detectizr/
 *
 * Written by Baris Aydinoglu (http://baris.aydinoglu.info) - Copyright 2012
 * Released under the MIT license
 *
 * Date: @DATE
 */
function viewport() {
    var e = window
        , a = 'inner';
    if (!('innerWidth' in window)) {
        a = 'client';
        e = document.documentElement || document.body;
    }
    ; return {
        width: e[a + 'Width']
    };
}
; var windowW = 0;
window.Detectizr = (function (window, navigator, document, undefined) {
    var Detectizr = {}, Modernizr = window.Modernizr, deviceTypes = ["tv", "tablet", "mobile", "desktop"], options = {
        addAllFeaturesAsClass: false,
        detectDevice: true,
        detectDeviceModel: true,
        detectScreen: true,
        detectOS: true,
        detectBrowser: true,
        detectPlugins: true
    }, plugins2detect = [{
        name: "adobereader",
        substrs: ["Adobe", "Acrobat"],
        progIds: ["AcroPDF.PDF", "PDF.PDFCtrl.5"]
    }, {
        name: "flash",
        substrs: ["Shockwave Flash"],
        progIds: ["ShockwaveFlash.ShockwaveFlash.1"]
    }, {
        name: "wmplayer",
        substrs: ["Windows Media"],
        progIds: ["wmplayer.ocx"]
    }, {
        name: "silverlight",
        substrs: ["Silverlight"],
        progIds: ["AgControl.AgControl"]
    }, {
        name: "quicktime",
        substrs: ["QuickTime"],
        progIds: ["QuickTime.QuickTime"]
    }], rclass = /[\t\r\n]/g, docElement = document.documentElement, resizeTimeoutId, oldOrientation;
    function extend(obj, extObj) {
        var a, b, i;
        if (arguments.length > 2) {
            for (a = 1,
                b = arguments.length; a < b; a += 1) {
                extend(obj, arguments[a]);
            }
        } else {
            for (i in extObj) {
                if (extObj.hasOwnProperty(i)) {
                    obj[i] = extObj[i];
                }
            }
        }
        return obj;
    }
    function is(key) {
        return Detectizr.browser.userAgent.indexOf(key) > -1;
    }
    function test(regex) {
        return regex.test(Detectizr.browser.userAgent);
    }
    function exec(regex) {
        return regex.exec(Detectizr.browser.userAgent);
    }
    function trim(value) {
        return value.replace(/^\s+|\s+$/g, "");
    }
    function toCamel(string) {
        if (string === null || string === undefined) {
            return "";
        }
        return String(string).replace(/((\s|\-|\.)+[a-z0-9])/g, function ($1) {
            return $1.toUpperCase().replace(/(\s|\-|\.)/g, "");
        });
    }
    function removeClass(element, value) {
        var class2remove = value || ""
            , cur = element.nodeType === 1 && (element.className ? (" " + element.className + " ").replace(rclass, " ") : "");
        if (cur) {
            while (cur.indexOf(" " + class2remove + " ") >= 0) {
                cur = cur.replace(" " + class2remove + " ", " ");
            }
            element.className = value ? trim(cur) : "";
        }
    }
    function addVersionTest(version, major, minor) {
        if (!!version) {
            version = toCamel(version);
            if (!!major) {
                major = toCamel(major);
                addConditionalTest(version + major, true);
                if (!!minor) {
                    addConditionalTest(version + major + "_" + minor, true);
                }
            }
        }
    }
    function addConditionalTest(feature, test) {
        if (!!feature && !!Modernizr) {
            if (options.addAllFeaturesAsClass) {
                Modernizr.addTest(feature, test);
            } else {
                test = typeof test === "function" ? test() : test;
                if (test) {
                    Modernizr.addTest(feature, true);
                } else {
                    delete Modernizr[feature];
                    removeClass(docElement, feature);
                }
            }
        }
    }
    function setVersion(versionType, versionFull) {
        versionType.version = versionFull;
        var versionArray = versionFull.split(".");
        if (versionArray.length > 0) {
            versionArray = versionArray.reverse();
            versionType.major = versionArray.pop();
            if (versionArray.length > 0) {
                versionType.minor = versionArray.pop();
                if (versionArray.length > 0) {
                    versionArray = versionArray.reverse();
                    versionType.patch = versionArray.join(".");
                } else {
                    versionType.patch = "0";
                }
            } else {
                versionType.minor = "0";
            }
        } else {
            versionType.major = "0";
        }
    }
    function checkOrientation() {
        window.clearTimeout(resizeTimeoutId);
        resizeTimeoutId = window.setTimeout(function () {
            oldOrientation = Detectizr.device.orientation;
            if (windowW != $(window).width()) {
                if (window.innerHeight > window.innerWidth) {
                    Detectizr.device.orientation = "portrait";
                } else {
                    Detectizr.device.orientation = "landscape";
                }
                windowW = $(window).width();
                $(window).trigger('resize');
            }
            addConditionalTest(Detectizr.device.orientation, true);
            if (oldOrientation !== Detectizr.device.orientation) {
                addConditionalTest(oldOrientation, false);
            }
        }, 10);
    }
    function detectPlugin(substrs) {
        var plugins = navigator.plugins, plugin, haystack, pluginFoundText, j, k;
        for (j = plugins.length - 1; j >= 0; j--) {
            plugin = plugins[j];
            haystack = plugin.name + plugin.description;
            pluginFoundText = 0;
            for (k = substrs.length; k >= 0; k--) {
                if (haystack.indexOf(substrs[k]) !== -1) {
                    pluginFoundText += 1;
                }
            }
            if (pluginFoundText === substrs.length) {
                return true;
            }
        }
        return false;
    }
    function detectObject(progIds) {
        var j;
        for (j = progIds.length - 1; j >= 0; j--) {
            try {
                new ActiveXObject(progIds[j]);
            } catch (e) { }
        }
        return false;
    }
    function detect(opt) {
        var i, j, device, os, browser, plugin2detect, pluginFound;
        options = extend({}, options, opt || {});
        if (options.detectDevice) {
            Detectizr.device = {
                type: "",
                model: "",
                orientation: ""
            };
            device = Detectizr.device;
            if (test(/googletv|smarttv|smart-tv|internet.tv|netcast|nettv|appletv|boxee|kylo|roku|dlnadoc|roku|pov_tv|hbbtv|ce\-html/)) {
                device.type = deviceTypes[0];
                device.model = "smartTv";
            } else if (test(/xbox|playstation.3|wii/)) {
                device.type = deviceTypes[0];
                device.model = "gameConsole";
            } else if (test(/ip(a|ro)d/)) {
                device.type = deviceTypes[1];
                device.model = "ipad";
            } else if ((test(/tablet/) && !test(/rx-34/) && !test(/shield/)) || test(/folio/)) {
                device.type = deviceTypes[1];
                device.model = String(exec(/playbook/) || "");
            } else if (test(/linux/) && test(/android/) && !test(/fennec|mobi|htc.magic|htcX06ht|nexus.one|sc-02b|fone.945/)) {
                device.type = deviceTypes[1];
                device.model = "android";
            } else if (test(/kindle/) || (test(/mac.os/) && test(/silk/))) {
                device.type = deviceTypes[1];
                device.model = "kindle";
            } else if (test(/gt-p10|sc-01c|shw-m180s|sgh-t849|sch-i800|shw-m180l|sph-p100|sgh-i987|zt180|htc(.flyer|\_flyer)|sprint.atp51|viewpad7|pandigital(sprnova|nova)|ideos.s7|dell.streak.7|advent.vega|a101it|a70bht|mid7015|next2|nook/) || (test(/mb511/) && test(/rutem/))) {
                device.type = deviceTypes[1];
                device.model = "android";
            } else if (test(/bb10/)) {
                device.type = deviceTypes[2];
                device.model = "blackberry";
            } else {
                device.model = exec(/iphone|ipod|android|blackberry|opera mini|opera mobi|skyfire|maemo|windows phone|palm|iemobile|symbian|symbianos|fennec|j2me/);
                if (device.model !== null) {
                    device.type = deviceTypes[2];
                    device.model = String(device.model);
                } else {
                    device.model = "";
                    if (test(/bolt|fennec|iris|maemo|minimo|mobi|mowser|netfront|novarra|prism|rx-34|skyfire|tear|xv6875|xv6975|google.wireless.transcoder/)) {
                        device.type = deviceTypes[2];
                    } else if (test(/opera/) && test(/windows.nt.5/) && test(/htc|xda|mini|vario|samsung\-gt\-i8000|samsung\-sgh\-i9/)) {
                        device.type = deviceTypes[2];
                    } else if ((test(/windows.(nt|xp|me|9)/) && !test(/phone/)) || test(/win(9|.9|nt)/) || test(/\(windows 8\)/)) {
                        device.type = deviceTypes[3];
                    } else if (test(/macintosh|powerpc/) && !test(/silk/)) {
                        device.type = deviceTypes[3];
                        device.model = "mac";
                    } else if (test(/linux/) && test(/x11/)) {
                        device.type = deviceTypes[3];
                    } else if (test(/solaris|sunos|bsd/)) {
                        device.type = deviceTypes[3];
                    } else if (test(/cros/)) {
                        device.type = deviceTypes[3];
                    } else if (test(/bot|crawler|spider|yahoo|ia_archiver|covario-ids|findlinks|dataparksearch|larbin|mediapartners-google|ng-search|snappy|teoma|jeeves|tineye/) && !test(/mobile/)) {
                        device.type = deviceTypes[3];
                        device.model = "crawler";
                    } else {
                        device.type = deviceTypes[2];
                    }
                }
            }
            for (i = 0,
                j = deviceTypes.length; i < j; i += 1) {
                addConditionalTest(deviceTypes[i], (device.type === deviceTypes[i]));
            }
            if (options.detectDeviceModel) {
                addConditionalTest(toCamel(device.model), true);
            }
        }
        if (options.detectScreen) {
            device.screen = {};
            if (!!Modernizr && !!Modernizr.mq) {
                if (Modernizr.mq("only screen and (max-width: 240px)")) {
                    device.screen.size = "veryVerySmall";
                    addConditionalTest("veryVerySmallScreen", true);
                } else if (Modernizr.mq("only screen and (max-width: 320px)")) {
                    device.screen.size = "verySmall";
                    addConditionalTest("verySmallScreen", true);
                } else if (Modernizr.mq("only screen and (max-width: 480px)")) {
                    device.screen.size = "small";
                    addConditionalTest("smallScreen", true);
                }
                if (device.type === deviceTypes[1] || device.type === deviceTypes[2]) {
                    if (Modernizr.mq("only screen and (-moz-min-device-pixel-ratio: 1.3), only screen and (-o-min-device-pixel-ratio: 2.6/2), only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen  and (min-device-pixel-ratio: 1.3), only screen and (min-resolution: 1.3dppx)")) {
                        device.screen.resolution = "high";
                        addConditionalTest("highresolution", true);
                    }
                }
            }
            if (device.type === deviceTypes[1] || device.type === deviceTypes[2]) {
                window.onresize = function (event) {
                    checkOrientation(event);
                }
                    ;
                checkOrientation();
            } else {
                device.orientation = "landscape";
                addConditionalTest(device.orientation, true);
            }
        }
        if (options.detectOS) {
            Detectizr.os = {};
            os = Detectizr.os;
            if (device.model !== "") {
                if (device.model === "ipad" || device.model === "iphone" || device.model === "ipod") {
                    os.name = "ios";
                    setVersion(os, (test(/os\s([\d_]+)/) ? RegExp.$1 : "").replace(/_/g, "."));
                } else if (device.model === "android") {
                    os.name = "android";
                    setVersion(os, (test(/android\s([\d\.]+)/) ? RegExp.$1 : ""));
                } else if (device.model === "blackberry") {
                    os.name = "blackberry";
                    setVersion(os, (test(/version\/([^\s]+)/) ? RegExp.$1 : ""));
                } else if (device.model === "playbook") {
                    os.name = "blackberry";
                    setVersion(os, (test(/os ([^\s]+)/) ? RegExp.$1.replace(";", "") : ""));
                }
            }
            if (!os.name) {
                if (is("win") || is("16bit")) {
                    os.name = "windows";
                    if (is("windows nt 10")) {
                        setVersion(os, "10");
                    } else if (is("windows nt 6.3")) {
                        setVersion(os, "8.1");
                    } else if (is("windows nt 6.2") || test(/\(windows 8\)/)) {
                        setVersion(os, "8");
                    } else if (is("windows nt 6.1")) {
                        setVersion(os, "7");
                    } else if (is("windows nt 6.0")) {
                        setVersion(os, "vista");
                    } else if (is("windows nt 5.2") || is("windows nt 5.1") || is("windows xp")) {
                        setVersion(os, "xp");
                    } else if (is("windows nt 5.0") || is("windows 2000")) {
                        setVersion(os, "2k");
                    } else if (is("winnt") || is("windows nt")) {
                        setVersion(os, "nt");
                    } else if (is("win98") || is("windows 98")) {
                        setVersion(os, "98");
                    } else if (is("win95") || is("windows 95")) {
                        setVersion(os, "95");
                    }
                } else if (is("mac") || is("darwin")) {
                    os.name = "mac os";
                    if (is("68k") || is("68000")) {
                        setVersion(os, "68k");
                    } else if (is("ppc") || is("powerpc")) {
                        setVersion(os, "ppc");
                    } else if (is("os x")) {
                        setVersion(os, (test(/os\sx\s([\d_]+)/) ? RegExp.$1 : "os x").replace(/_/g, "."));
                    }
                } else if (is("webtv")) {
                    os.name = "webtv";
                } else if (is("x11") || is("inux")) {
                    os.name = "linux";
                } else if (is("sunos")) {
                    os.name = "sun";
                } else if (is("irix")) {
                    os.name = "irix";
                } else if (is("freebsd")) {
                    os.name = "freebsd";
                } else if (is("bsd")) {
                    os.name = "bsd";
                }
            }
            if (!!os.name) {
                addConditionalTest(os.name, true);
                if (!!os.major) {
                    addVersionTest(os.name, os.major);
                    if (!!os.minor) {
                        addVersionTest(os.name, os.major, os.minor);
                    }
                }
            }
            if (test(/\sx64|\sx86|\swin64|\swow64|\samd64/)) {
                os.addressRegisterSize = "64bit";
            } else {
                os.addressRegisterSize = "32bit";
            }
            addConditionalTest(os.addressRegisterSize, true);
        }
        if (options.detectBrowser) {
            browser = Detectizr.browser;
            if (!test(/opera|webtv/) && (test(/msie\s([\d\w\.]+)/) || is("trident"))) {
                browser.engine = "trident";
                browser.name = "ie";
                if (!window.addEventListener && document.documentMode && document.documentMode === 7) {
                    setVersion(browser, "8.compat");
                } else if (test(/trident.*rv[ :](\d+)\./)) {
                    setVersion(browser, RegExp.$1);
                } else {
                    setVersion(browser, (test(/trident\/4\.0/) ? "8" : RegExp.$1));
                }
            } else if (is("firefox")) {
                browser.engine = "gecko";
                browser.name = "firefox";
                setVersion(browser, (test(/firefox\/([\d\w\.]+)/) ? RegExp.$1 : ""));
            } else if (is("gecko/")) {
                browser.engine = "gecko";
            } else if (is("opera")) {
                browser.name = "opera";
                browser.engine = "presto";
                setVersion(browser, (test(/version\/([\d\.]+)/) ? RegExp.$1 : (test(/opera(\s|\/)([\d\.]+)/) ? RegExp.$2 : "")));
            } else if (is("konqueror")) {
                browser.name = "konqueror";
            } else if (is("edge")) {
                browser.engine = "webkit";
                browser.name = "edge";
                setVersion(browser, (test(/edge\/([\d\.]+)/) ? RegExp.$1 : ""));
            } else if (is("chrome")) {
                browser.engine = "webkit";
                browser.name = "chrome";
                setVersion(browser, (test(/chrome\/([\d\.]+)/) ? RegExp.$1 : ""));
            } else if (is("iron")) {
                browser.engine = "webkit";
                browser.name = "iron";
            } else if (is("crios")) {
                browser.name = "chrome";
                browser.engine = "webkit";
                setVersion(browser, (test(/crios\/([\d\.]+)/) ? RegExp.$1 : ""));
            } else if (is("applewebkit/")) {
                browser.name = "safari";
                browser.engine = "webkit";
                setVersion(browser, (test(/version\/([\d\.]+)/) ? RegExp.$1 : ""));
            } else if (is("mozilla/")) {
                browser.engine = "gecko";
            }
            if (!!browser.name) {
                addConditionalTest(browser.name, true);
                if (!!browser.major) {
                    addVersionTest(browser.name, browser.major);
                    if (!!browser.minor) {
                        addVersionTest(browser.name, browser.major, browser.minor);
                    }
                }
            }
            addConditionalTest(browser.engine, true);
            browser.language = navigator.userLanguage || navigator.language;
            addConditionalTest(browser.language, true);
        }
        if (options.detectPlugins) {
            browser.plugins = [];
            for (i = plugins2detect.length - 1; i >= 0; i--) {
                plugin2detect = plugins2detect[i];
                pluginFound = false;
                if (window.ActiveXObject) {
                    pluginFound = detectObject(plugin2detect.progIds);
                } else if (navigator.plugins) {
                    pluginFound = detectPlugin(plugin2detect.substrs);
                }
                if (pluginFound) {
                    browser.plugins.push(plugin2detect.name);
                    addConditionalTest(plugin2detect.name, true);
                }
            }
            if (typeof navigator.javaEnabled === "function" && navigator.javaEnabled()) {
                browser.plugins.push("java");
                addConditionalTest("java", true);
            }
        }
    }
    Detectizr.detect = function (settings) {
        return detect(settings);
    }
        ;
    Detectizr.init = function () {
        if (Detectizr !== undefined) {
            Detectizr.browser = {
                userAgent: (navigator.userAgent || navigator.vendor || window.opera || "").toLowerCase()
            };
            Detectizr.detect();
        }
    }
        ;
    Detectizr.init();
    return Detectizr;
}(this, this.navigator, this.document));
(function ($) {
    var defaults = {
        preloadSelector: true,
        truePercentage: true,
        disableOverlay: false,
        showInContainer: false,
        hideBackground: false,
        hideNonImageElements: false,
        progressiveReveal: false,
        forceSequentialLoad: false,
        silentMode: false,
        debugMode: false,
        useOpacity: true,
        hidePercentage: false,
        loaderText: '',
        animateDuration: 1000,
        fadeOutDuration: 1000,
        showImagesBeforeComplete: true,
        afterEach: function () { },
        beforeComplete: function () { },
        onComplete: function () { }
    };
    var spinnerStepInterval = null
        , spinnerReadyInterval = null
        , spinnerStep = 0
        , spinnerReady = false
        , elementsReady = false;
    var methods = {
        init: function (options) {
            var settings = $.extend({}, defaults, options);
            return this.each(function () {
                var parent = $(this);
                var elementChildren = getAllChildren(parent);
                var imageElements = [];
                var nonImageElements = [];
                var imagesLoaded = 0;
                var totalImages = 0;
                var progressPercentage = 0;
                var totalPercentage = 0;
                var count = 0;
                var minUpdateToValue = 0;
                var preloadContainer = $('<div id="site-preloader"></div>');
                if (!settings.showInContainer) {
                    preloadContainer.appendTo('body');
                    preloadContainer.css('position', 'fixed');
                } else {
                    preloadContainer.appendTo(parent);
                    parent.css('position', 'relative');
                    preloadContainer.css('position', 'absolute');
                }
                if (!settings.disableOverlay) {
                    var preloadOverlay = $('<div class="loader_overlay"></div>').appendTo(preloadContainer);
                } else {
                    preloadContainer.css('height', 'auto');
                }
                $('<div class="spinner"><svg width="100px" height="100px" viewBox="0 0 693 1050" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;"><path d="M497.854,702.57l173.451,134.59l21.16,117.33l-50.76,66.64l-232.754,28.13l-150.428,-53.4l0.062,-5.63l98.569,-39.91l140.705,-192.68l-0.005,-55.07Zm-275.519,238.58l-44.325,14.77l-37.174,-15.01l-140.601,-192.79l-0.235,-59.34l66.487,-51.59l0.177,-148.47l59.278,-59.22l15.012,0l81.383,58.51l35.4,0l81.381,-58.51l15.013,0l59.279,59.22l0.18,148.47l66.486,51.59l-0.239,59.34l-140.597,192.79l-37.176,15.01l-44.325,-14.77l-35.404,0Zm17.703,-473.83l-18.248,0l-182.064,-132.5l20.017,-87.22l-36.699,-247.59l21.446,0l133.453,126.05l124.188,0l133.453,-126.06l21.446,0l-36.697,247.59l20.017,87.23l-182.067,132.49l-18.245,0l0,0.01Z"/></svg></img></div>').appendTo(preloadContainer);
                var preloadLoader = $('<div class="loader"></div>').appendTo(preloadContainer);
                if (!settings.hidePercentage) {
                    var progressNotification = $('<div class="progress_notification">' + settings.loaderText + ' <span class="progress_percentage">' + progressPercentage + '</span>%</div>').appendTo(preloadLoader);
                } else {
                    var progressNotification = $('<div class="progress_notification">' + settings.loaderText + '</div>').appendTo(preloadLoader);
                }
                var progressBar = $('<div class="progress_bar"></div>').appendTo(preloadLoader);
                var progressLoaded = $('<div class="progress_loaded"></div>').appendTo(progressBar);
                if (settings.silentMode) {
                    preloadContainer.hide();
                }
                if (settings.truePercentage) {
                    updateProgressbar(1, 3000);
                }
                if (settings.debugMode) {
                    var startTime = (new Date).getTime();
                    console.groupCollapsed('preloading > ', parent);
                    console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': scanning DOM for image elements...');
                    console.groupCollapsed('image elements');
                }
                elementChildren.forEach(function (child) {
                    if (child.is('img') || child.css('background-image') !== 'none' && child.css('background-image').indexOf('gradient') == -1) {
                        if (!(settings.preloadSelector && settings.showInContainer && child === parent)) {
                            if (!settings.useOpacity) {
                                child.hide();
                            } else {
                                child.css('opacity', '0');
                            }
                        } else if (settings.hideBackground) {
                            child.attr('data-bg', child.css('background-image')).css('background-image', 'none');
                        }
                        var imageElement = {
                            node: child,
                            fileSize: 0
                        };
                        if (settings.debugMode) {
                            console.log(imageElement.node);
                        }
                        imageElements.push(imageElement);
                        totalImages++;
                    } else if (settings.hideNonImageElements) {
                        if (!settings.useOpacity) {
                            child.hide();
                        } else {
                            child.css('opacity', '0');
                        }
                        nonImageElements.push(child);
                    }
                });
                if (settings.debugMode) {
                    console.groupEnd();
                    console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': scanning DOM for image elements DONE');
                }
                if (settings.truePercentage) {
                    if (settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': getting image sizes...');
                        console.groupCollapsed('image sizes');
                    }
                    imageElements.forEach(function (element) {
                        $.ajax({
                            type: 'HEAD',
                            cache: false,
                            url: getImageUrl(element.node),
                            success: function (response, message, object) {
                                element.fileSize = parseInt(object.getResponseHeader('Content-Length'));
                                totalPercentage += element.fileSize;
                                if (settings.debugMode) {
                                    console.log((element.fileSize / 1000).toFixed(2) + ' KB \t' + (totalPercentage / 1000).toFixed(2) + ' KB total');
                                }
                                continueCounting();
                            },
                            error: function (object, response, message) {
                                continueCounting();
                                var markup = '';
                                markup += 'Not all of your images were preloaded!<br>';
                                markup += 'Loader failed getting image sizes.<br><br>';
                                markup += '1. Make sure your images exist.<br>';
                                markup += '2. Make sure your image paths/urls are correct.<br>';
                                markup += '3. If you load images from a remote domain set <code>truePercentage: false</code>.<br><br>';
                                markup += '<button>Close</button>';
                                progressNotification.addClass('error').html(markup);
                                progressBar.addClass('error');
                                settings.fadeOutDuration = 500000;
                                $('#preloader button').click(function () {
                                    preloadContainer.remove();
                                });
                            }
                        });
                        function continueCounting() {
                            count++;
                            if (count === totalImages) {
                                if (settings.debugMode) {
                                    console.groupEnd();
                                    console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': getting image sizes DONE');
                                }
                                startPreloading();
                            }
                        }
                    });
                } else {
                    if (settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': getting image sizes SKIPPED');
                    }
                    totalPercentage = totalImages;
                    startPreloading();
                }
                spinnerStepInterval = setInterval(function () {
                    spinnerStep += 3;
                    if (spinnerStep == 360)
                        spinnerStep = 0;
                    $('.spinner').css({
                        '-webkit-transform': 'rotate(' + 0 + 'deg)',
                        '-moz-transform': 'rotate(' + 0 + 'deg)',
                        'transform': 'rotate(' + 0 + 'deg)',
                    });
                    if ((spinnerStep % 315 == 0 || spinnerStep % 135 == 0 && spinnerStep % 270 != 0) && spinnerStep != 0) {
                        spinnerReady = true;
                    } else {
                        spinnerReady = false;
                    }
                }, 15)
                function startPreloading() {
                    if (settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': preloading image elements...');
                        console.groupCollapsed('intervals');
                    }
                    if (!settings.forceSequentialLoad) {
                        if (imageElements.length) {
                            imageElements.forEach(function (element, index) {
                                var img = $('<img>').attr('src', getImageUrl(element.node));
                                img.load(function () {
                                    updateLoader(element);
                                }).error(function () {
                                    updateLoader(element);
                                    handleLoadingError(img, element);
                                });
                            });
                        } else {
                            $('.spinner span i').css({
                                '-webkit-transform': 'rotate(' + 0 + 'deg)',
                                '-moz-transform': 'rotate(' + 0 + 'deg)',
                                'transform': 'rotate(' + 0 + 'deg)'
                            });
                            spinnerReadyInterval = setInterval(function () {
                                if (spinnerReady) {
                                    clearInterval(spinnerStepInterval)
                                    preloadContainer.animate({
                                        'opacity': '0'
                                    }, settings.fadeOutDuration, function () {
                                        preloadContainer.remove();
                                    });
                                    $('.sections-nav, header, .mouse, .intro-content').removeClass('initial');
                                    clearInterval(spinnerReadyInterval)
                                }
                            }, 10)
                        }
                    } else {
                        (function loadImage(index) {
                            var currentElement = imageElements[index];
                            var img = $('<img>').attr('src', getImageUrl(currentElement.node));
                            img.load(function () {
                                updateLoader(currentElement);
                                if (++index < imageElements.length) {
                                    loadImage(index);
                                }
                            }).error(function () {
                                updateLoader(currentElement);
                                if (++index < imageElements.length) {
                                    loadImage(index);
                                }
                                handleLoadingError(img, currentElement);
                            });
                        }
                        )(0);
                    }
                }
                function handleLoadingError(image, element) {
                    element.node.addClass('preloader_not_found_error');
                }
                function updateLoader(element) {
                    imagesLoaded++;
                    updateProgressPercentage(element);
                    updateProgressbar(progressPercentage, undefined, element);
                    if (settings.progressiveReveal) {
                        revealElement(element.node);
                    }
                    settings.afterEach.call(element.node);
                }
                function updateProgressPercentage(element) {
                    if (settings.truePercentage) {
                        progressPercentage += (element.fileSize / totalPercentage) * 100;
                        if (imagesLoaded === totalImages) {
                            progressPercentage = 100;
                        }
                    } else {
                        progressPercentage = (imagesLoaded / totalPercentage) * 100;
                    }
                }
                function updateProgressbar(value, updateDuration, element) {
                    updateDuration = updateDuration !== undefined ? updateDuration : settings.animateDuration;
                    var totalWidth = 0;
                    var updateTo = value;
                    var remaining = 0;
                    if (updateDuration === undefined && settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': ' + value.toFixed(2) + '%');
                    }
                    if (value < 100) {
                        if (element !== undefined) {
                            if (element.round === undefined) {
                                element.round = 0;
                                updateTo = value / 4 * 3;
                                remaining = value / 4;
                            } else {
                                element.round++;
                                updateTo = value / (4 + element.round) * (3 + element.round);
                                remaining = value / (4 + element.round);
                                updateDuration = 200;
                            }
                        }
                    }
                    if (element === undefined) {
                        element = {};
                    }
                    if (element.round === undefined) {
                        element.round = 0;
                    }
                    if (updateTo > minUpdateToValue) {
                        minUpdateToValue = updateTo;
                    }
                    if (updateTo < minUpdateToValue) {
                        updateTo = minUpdateToValue;
                    }
                    progressLoaded.stop();
                    if (element.round < 30) {
                        progressLoaded.animate({
                            'width': updateTo + '%'
                        }, {
                                duration: updateDuration,
                                easing: 'linear',
                                step: function () {
                                    totalWidth = progressBar.width();
                                    progressNotification.children('span').html(Math.round((progressLoaded.width() / totalWidth) * 100));
                                    var spinnerAngle = (progressLoaded.width() / totalWidth) * 18000 / 100;
                                    $('.spinner span i').css({
                                        '-webkit-transform': 'rotate(' + 0 + 'deg)',
                                        '-moz-transform': 'rotate(' + 0 + 'deg)',
                                        'transform': 'rotate(' + 0 + 'deg)'
                                    });
                                },
                                complete: function () {
                                    progressNotification.children('span').html(Math.round(updateTo));
                                    if (imagesLoaded === totalImages) {
                                        if (settings.debugMode) {
                                            console.groupEnd();
                                            console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': preloading image elements DONE');
                                            console.groupEnd();
                                        }
                                        progressLoaded.delay(100).queue(function () {
                                            if (settings.showImagesBeforeComplete) {
                                                spinnerReadyInterval = setInterval(function () {
                                                    if (spinnerReady) {
                                                        clearInterval(spinnerStepInterval)
                                                        imageElements.forEach(function (element) {
                                                            revealElement(element.node);
                                                        });
                                                        nonImageElements.forEach(function (element) {
                                                            revealElement(element);
                                                        });
                                                        settings.beforeComplete.call(this);
                                                        preloadContainer.animate({
                                                            'opacity': '0'
                                                        }, settings.fadeOutDuration, function () {
                                                            preloadContainer.remove();
                                                            settings.onComplete.call(this);
                                                            $('.sections-nav, header, .mouse, .intro-content').removeClass('initial');
                                                            if ($('html').hasClass('desktop') && $('body').hasClass('single')) {
                                                                noformat.scroll = new Smooth({
                                                                    native: false,
                                                                    section: document.querySelector('.single-holder')
                                                                });
                                                                noformat.scroll.init();
                                                                noformat.single.resize();
                                                            } else if ($('html').hasClass('desktop') && $('body').hasClass('page-template-page-work')) {
                                                                noformat.scroll = new Smooth({
                                                                    native: false,
                                                                    section: document.querySelector('.work-grid')
                                                                });
                                                                noformat.scroll.init();
                                                                noformat.work.resize();
                                                            }
                                                        });
                                                        if ($('body').hasClass('single') && $('html').hasClass('desktop')) {
                                                            noformat.single.contentReady = true;
                                                            if (noformat.single.introVideoReady)
                                                                noformat.single.players[0].play();
                                                        }
                                                        clearInterval(spinnerReadyInterval)
                                                    }
                                                }, 10)
                                            } else {
                                                settings.beforeComplete.call(this);
                                                preloadContainer.animate({
                                                    'opacity': '0'
                                                }, settings.fadeOutDuration, function () {
                                                    imageElements.forEach(function (element) {
                                                        revealElement(element.node);
                                                    });
                                                    nonImageElements.forEach(function (element) {
                                                        revealElement(element);
                                                    });
                                                    preloadContainer.remove();
                                                    settings.onComplete.call(this);
                                                });
                                            }
                                        });
                                    } else {
                                        updateProgressbar(value, updateDuration, element);
                                    }
                                }
                            });
                    }
                }
                function getAllChildren(selector) {
                    var selectorChildren = [];
                    if (selector.children().length > 0) {
                        if (settings.preloadSelector) {
                            selectorChildren.push(selector);
                        }
                        getChildren(selector);
                    } else if (settings.preloadSelector) {
                        selectorChildren.push(selector);
                    }
                    function getChildren(element) {
                        var children = element.children();
                        if (children.length > 0) {
                            children.each(function () {
                                var _this = $(this);
                                selectorChildren.push(_this);
                                if (_this.children().length > 0) {
                                    getChildren(_this);
                                }
                            });
                        }
                    }
                    return selectorChildren;
                }
                function getImageUrl(image) {
                    if (image.css('background-image') !== 'none') {
                        return image.css('background-image').replace(/^url\(["']?/, '').replace(/["']?\)$/, '');
                    } else if (image.css('background-image') === 'none' && image.attr('data-bg')) {
                        return image.attr('data-bg').replace(/^url\(["']?/, '').replace(/["']?\)$/, '');
                    } else {
                        return image.attr('src');
                    }
                }
                function revealElement(element) {
                    if (!settings.useOpacity) {
                        element.show();
                    } else {
                        element.css('opacity', '1');
                    }
                    if (element.attr('data-bg')) {
                        element.css('background-image', element.attr('data-bg'));
                    }
                }
            });
        }
    };
    if (!('forEach' in Array.prototype)) {
        Array.prototype.forEach = function (action, that) {
            for (var i = 0, n = this.length; i < n; i++) {
                if (i in this) {
                    action.call(that, this[i], i, this);
                }
            }
        }
            ;
    }
    $.fn.preloadingSite = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.preloading');
        }
    }
        ;
}
)(jQuery);
(function ($) {
    var defaults = {
        preloadSelector: true,
        truePercentage: false,
        disableOverlay: false,
        showInContainer: false,
        hideBackground: false,
        hideNonImageElements: false,
        progressiveReveal: false,
        forceSequentialLoad: false,
        silentMode: false,
        debugMode: false,
        useOpacity: true,
        hidePercentage: false,
        loaderText: '',
        animateDuration: 1000,
        fadeOutDuration: 1000,
        showImagesBeforeComplete: true,
        afterEach: function () { },
        beforeComplete: function () { },
        onComplete: function () { }
    };
    var methods = {
        init: function (options) {
            var settings = $.extend({}, defaults, options);
            return this.each(function () {
                var parent = $(this);
                var elementChildren = getAllChildren(parent);
                var imageElements = [];
                var nonImageElements = [];
                var imagesLoaded = 0;
                var totalImages = 0;
                var progressPercentage = 0;
                var totalPercentage = 0;
                var count = 0;
                var minUpdateToValue = 0;
                var preloadContainer = $('<div id="preloader"></div>');
                if (!settings.showInContainer) {
                    preloadContainer.appendTo('body');
                    preloadContainer.css('position', 'fixed');
                } else {
                    preloadContainer.appendTo(parent);
                    parent.css('position', 'relative');
                    preloadContainer.css('position', 'absolute');
                }
                if (!settings.disableOverlay) {
                    var preloadOverlay = $('<div class="loader_overlay"></div>').appendTo(preloadContainer);
                } else {
                    preloadContainer.css('height', 'auto');
                }
                var preloadLoader = $('<div class="loader"></div>').appendTo(preloadContainer);
                if (!settings.hidePercentage) {
                    var progressNotification = $('<div class="progress_notification">' + settings.loaderText + ' <span class="progress_percentage">' + progressPercentage + '</span>%</div>').appendTo(preloadLoader);
                } else {
                    var progressNotification = $('<div class="progress_notification">' + settings.loaderText + '</div>').appendTo(preloadLoader);
                }
                var progressBar = $('<div class="progress_bar"></div>').appendTo(preloadLoader);
                var progressLoaded = $('<div class="progress_loaded"></div>').appendTo(progressBar);
                if ($('body').hasClass('home')) {
                    progressColor = $('section.active').data('progress-color');
                    progressLoaded.css('border-bottom-color', progressColor)
                }
                if (settings.silentMode) {
                    preloadContainer.hide();
                }
                if (settings.truePercentage) {
                    updateProgressbar(1, 3000);
                }
                if (settings.debugMode) {
                    var startTime = (new Date).getTime();
                    console.groupCollapsed('preloading > ', parent);
                    console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': scanning DOM for image elements...');
                    console.groupCollapsed('image elements');
                }
                elementChildren.forEach(function (child) {
                    if (child.is('img') || child.css('background-image') !== 'none' && child.css('background-image').indexOf('gradient') == -1) {
                        if (!(settings.preloadSelector && settings.showInContainer && child === parent)) {
                            if (!settings.useOpacity) {
                                child.hide();
                            } else {
                                child.css('opacity', '1');
                            }
                        } else if (settings.hideBackground) {
                            child.attr('data-bg', child.css('background-image')).css('background-image', 'none');
                        }
                        var imageElement = {
                            node: child,
                            fileSize: 0
                        };
                        if (settings.debugMode) {
                            console.log(imageElement.node);
                        }
                        imageElements.push(imageElement);
                        totalImages++;
                    } else if (settings.hideNonImageElements) {
                        if (!settings.useOpacity) {
                            child.hide();
                        } else {
                            child.css('opacity', '0');
                        }
                        nonImageElements.push(child);
                    }
                });
                if (settings.debugMode) {
                    console.groupEnd();
                    console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': scanning DOM for image elements DONE');
                }
                if (settings.truePercentage) {
                    if (settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': getting image sizes...');
                        console.groupCollapsed('image sizes');
                    }
                    imageElements.forEach(function (element) {
                        $.ajax({
                            type: 'HEAD',
                            cache: false,
                            url: getImageUrl(element.node),
                            success: function (response, message, object) {
                                element.fileSize = parseInt(object.getResponseHeader('Content-Length'));
                                totalPercentage += element.fileSize;
                                if (settings.debugMode) {
                                    console.log((element.fileSize / 1000).toFixed(2) + ' KB \t' + (totalPercentage / 1000).toFixed(2) + ' KB total');
                                }
                                continueCounting();
                            },
                            error: function (object, response, message) {
                                continueCounting();
                                var markup = '';
                                markup += 'Not all of your images were preloaded!<br>';
                                markup += 'Loader failed getting image sizes.<br><br>';
                                markup += '1. Make sure your images exist.<br>';
                                markup += '2. Make sure your image paths/urls are correct.<br>';
                                markup += '3. If you load images from a remote domain set <code>truePercentage: false</code>.<br><br>';
                                markup += '<button>Close</button>';
                                progressNotification.addClass('error').html(markup);
                                progressBar.addClass('error');
                                settings.fadeOutDuration = 500000;
                                $('#preloader button').click(function () {
                                    preloadContainer.remove();
                                });
                            }
                        });
                        function continueCounting() {
                            count++;
                            if (count === totalImages) {
                                if (settings.debugMode) {
                                    console.groupEnd();
                                    console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': getting image sizes DONE');
                                }
                                startPreloading();
                            }
                        }
                    });
                } else {
                    if (settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': getting image sizes SKIPPED');
                    }
                    totalPercentage = totalImages;
                    startPreloading();
                }
                function startPreloading() {
                    if (settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': preloading image elements...');
                        console.groupCollapsed('intervals');
                    }
                    if (!settings.forceSequentialLoad) {
                        if (imageElements.length) {
                            imageElements.forEach(function (element, index) {
                                var img = $('<img>').attr('src', getImageUrl(element.node));
                                img.load(function () {
                                    updateLoader(element);
                                }).error(function () {
                                    updateLoader(element);
                                    handleLoadingError(img, element);
                                });
                            });
                        } else {
                            progressLoaded.animate({
                                'width': '100%'
                            }, {
                                    duration: 750,
                                    easing: 'linear',
                                    complete: function () {
                                        settings.beforeComplete.call(this);
                                        settings.onComplete.call(this);
                                        preloadContainer.animate({
                                            'opacity': '0'
                                        }, settings.fadeOutDuration, function () {
                                            preloadContainer.remove();
                                        });
                                    }
                                })
                        }
                    } else {
                        (function loadImage(index) {
                            var currentElement = imageElements[index];
                            var img = $('<img>').attr('src', getImageUrl(currentElement.node));
                            img.load(function () {
                                updateLoader(currentElement);
                                if (++index < imageElements.length) {
                                    loadImage(index);
                                }
                            }).error(function () {
                                updateLoader(currentElement);
                                if (++index < imageElements.length) {
                                    loadImage(index);
                                }
                                handleLoadingError(img, currentElement);
                            });
                        }
                        )(0);
                    }
                }
                function handleLoadingError(image, element) {
                    element.node.addClass('preloader_not_found_error');
                }
                function updateLoader(element) {
                    imagesLoaded++;
                    updateProgressPercentage(element);
                    updateProgressbar(progressPercentage, undefined, element);
                    if (settings.progressiveReveal) {
                        revealElement(element.node);
                    }
                    settings.afterEach.call(element.node);
                }
                function updateProgressPercentage(element) {
                    if (settings.truePercentage) {
                        progressPercentage += (element.fileSize / totalPercentage) * 100;
                        if (imagesLoaded === totalImages) {
                            progressPercentage = 100;
                        }
                    } else {
                        progressPercentage = (imagesLoaded / totalPercentage) * 100;
                    }
                }
                function updateProgressbar(value, updateDuration, element) {
                    updateDuration = updateDuration !== undefined ? updateDuration : settings.animateDuration;
                    var totalWidth = 0;
                    var updateTo = value;
                    var remaining = 0;
                    if (updateDuration === undefined && settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': ' + value.toFixed(2) + '%');
                    }
                    if (value < 100) {
                        if (element !== undefined) {
                            if (element.round === undefined) {
                                element.round = 0;
                                updateTo = value / 4 * 3;
                                remaining = value / 4;
                            } else {
                                element.round++;
                                updateTo = value / (4 + element.round) * (3 + element.round);
                                remaining = value / (4 + element.round);
                                updateDuration = 200;
                            }
                        }
                    }
                    if (element === undefined) {
                        element = {};
                    }
                    if (element.round === undefined) {
                        element.round = 0;
                    }
                    if (updateTo > minUpdateToValue) {
                        minUpdateToValue = updateTo;
                    }
                    if (updateTo < minUpdateToValue) {
                        updateTo = minUpdateToValue;
                    }
                    progressLoaded.stop();
                    if (element.round < 30) {
                        progressLoaded.animate({
                            'width': updateTo + '%'
                        }, {
                                duration: updateDuration,
                                easing: 'linear',
                                step: function () {
                                    totalWidth = progressBar.width();
                                    progressNotification.children('span').html(Math.round((progressLoaded.width() / totalWidth) * 100));
                                },
                                complete: function () {
                                    progressNotification.children('span').html(Math.round(updateTo));
                                    if (imagesLoaded === totalImages) {
                                        if (settings.debugMode) {
                                            console.groupEnd();
                                            console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': preloading image elements DONE');
                                            console.groupEnd();
                                        }
                                        progressLoaded.delay(100).queue(function () {
                                            if (settings.showImagesBeforeComplete) {
                                                imageElements.forEach(function (element) {
                                                    revealElement(element.node);
                                                });
                                                nonImageElements.forEach(function (element) {
                                                    revealElement(element);
                                                });
                                                settings.beforeComplete.call(this);
                                                settings.onComplete.call(this);
                                                preloadContainer.animate({
                                                    'opacity': '0'
                                                }, settings.fadeOutDuration, function () {
                                                    preloadContainer.remove();
                                                });
                                            } else {
                                                settings.beforeComplete.call(this);
                                                preloadContainer.animate({
                                                    'opacity': '0'
                                                }, settings.fadeOutDuration, function () {
                                                    imageElements.forEach(function (element) {
                                                        revealElement(element.node);
                                                    });
                                                    nonImageElements.forEach(function (element) {
                                                        revealElement(element);
                                                    });
                                                    preloadContainer.remove();
                                                    settings.onComplete.call(this);
                                                });
                                            }
                                        });
                                    } else {
                                        updateProgressbar(value, updateDuration, element);
                                    }
                                }
                            });
                    }
                }
                function getAllChildren(selector) {
                    var selectorChildren = [];
                    if (selector.children().length > 0) {
                        if (settings.preloadSelector) {
                            selectorChildren.push(selector);
                        }
                        getChildren(selector);
                    } else if (settings.preloadSelector) {
                        selectorChildren.push(selector);
                    }
                    function getChildren(element) {
                        var children = element.children();
                        if (children.length > 0) {
                            children.each(function () {
                                var _this = $(this);
                                selectorChildren.push(_this);
                                if (_this.children().length > 0) {
                                    getChildren(_this);
                                }
                            });
                        }
                    }
                    return selectorChildren;
                }
                function getImageUrl(image) {
                    if (image.css('background-image') !== 'none') {
                        return image.css('background-image').replace(/^url\(["']?/, '').replace(/["']?\)$/, '');
                    } else if (image.css('background-image') === 'none' && image.attr('data-bg')) {
                        return image.attr('data-bg').replace(/^url\(["']?/, '').replace(/["']?\)$/, '');
                    } else {
                        return image.attr('src');
                    }
                }
                function revealElement(element) {
                    if (!settings.useOpacity) {
                        element.show();
                    } else {
                        element.css('opacity', '1');
                    }
                    if (element.attr('data-bg')) {
                        element.css('background-image', element.attr('data-bg'));
                    }
                }
            });
        }
    };
    if (!('forEach' in Array.prototype)) {
        Array.prototype.forEach = function (action, that) {
            for (var i = 0, n = this.length; i < n; i++) {
                if (i in this) {
                    action.call(that, this[i], i, this);
                }
            }
        }
            ;
    }
    $.fn.preloading = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.preloading');
        }
    }
        ;
}
)(jQuery);
(function ($) {
    var defaults = {
        preloadSelector: true,
        truePercentage: false,
        disableOverlay: false,
        showInContainer: false,
        hideBackground: false,
        hideNonImageElements: false,
        progressiveReveal: false,
        forceSequentialLoad: true,
        silentMode: false,
        debugMode: false,
        useOpacity: true,
        hidePercentage: false,
        loaderText: '',
        animateDuration: 1000,
        fadeOutDuration: 1000,
        showImagesBeforeComplete: true,
        afterEach: function () { },
        beforeComplete: function () { },
        onComplete: function () { }
    };
    var methods = {
        init: function (options) {
            var settings = $.extend({}, defaults, options);
            return this.each(function () {
                var parent = $(this);
                var elementChildren = getAllChildren(parent);
                var imageElements = [];
                var nonImageElements = [];
                var imagesLoaded = 0;
                var totalImages = 0;
                var progressPercentage = 0;
                var totalPercentage = 0;
                var count = 0;
                var minUpdateToValue = 0;
                var preloadContainer = $('<div id="single-preloader"></div>');
                if (!settings.showInContainer) {
                    preloadContainer.prependTo('section.active');
                    preloadContainer.css('position', 'absolute');
                } else {
                    preloadContainer.appendTo(parent);
                    parent.css('position', 'relative');
                    preloadContainer.css('position', 'absolute');
                }
                if (!settings.disableOverlay) {
                    var preloadOverlay = $('<div class="loader_overlay"></div>').appendTo(preloadContainer);
                } else {
                    preloadContainer.css('height', 'auto');
                }
                var preloadLoader = $('<div class="loader"></div>').appendTo(preloadContainer);
                if (!settings.hidePercentage) {
                    var progressNotification = $('<div class="progress_notification">' + settings.loaderText + ' <span class="progress_percentage">' + progressPercentage + '</span>%</div>').appendTo(preloadLoader);
                } else {
                    var progressNotification = $('<div class="progress_notification">' + settings.loaderText + '</div>').appendTo(preloadLoader);
                }
                var progressBar = $('<div class="progress_bar"></div>').appendTo(preloadLoader);
                var progressLoaded = $('<div class="progress_loaded"></div>').appendTo(progressBar);
                if (settings.silentMode) {
                    preloadContainer.hide();
                }
                if (settings.truePercentage) {
                    updateProgressbar(1, 3000);
                }
                if (settings.debugMode) {
                    var startTime = (new Date).getTime();
                    console.groupCollapsed('preloading > ', parent);
                    console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': scanning DOM for image elements...');
                    console.groupCollapsed('image elements');
                }
                elementChildren.forEach(function (child) {
                    if (child.is('img') || child.css('background-image') !== 'none' && child.css('background-image').indexOf('gradient') == -1) {
                        if (!(settings.preloadSelector && settings.showInContainer && child === parent)) {
                            if (!settings.useOpacity) {
                                child.hide();
                            } else {
                                child.css('opacity', '1');
                            }
                        } else if (settings.hideBackground) {
                            child.attr('data-bg', child.css('background-image')).css('background-image', 'none');
                        }
                        var imageElement = {
                            node: child,
                            fileSize: 0
                        };
                        if (settings.debugMode) {
                            console.log(imageElement.node);
                        }
                        imageElements.push(imageElement);
                        totalImages++;
                    } else if (settings.hideNonImageElements) {
                        if (!settings.useOpacity) {
                            child.hide();
                        } else {
                            child.css('opacity', '0');
                        }
                        nonImageElements.push(child);
                    }
                });
                if (settings.debugMode) {
                    console.groupEnd();
                    console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': scanning DOM for image elements DONE');
                }
                if (settings.truePercentage) {
                    if (settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': getting image sizes...');
                        console.groupCollapsed('image sizes');
                    }
                    imageElements.forEach(function (element) {
                        $.ajax({
                            type: 'HEAD',
                            cache: false,
                            url: getImageUrl(element.node),
                            success: function (response, message, object) {
                                element.fileSize = parseInt(object.getResponseHeader('Content-Length'));
                                totalPercentage += element.fileSize;
                                if (settings.debugMode) {
                                    console.log((element.fileSize / 1000).toFixed(2) + ' KB \t' + (totalPercentage / 1000).toFixed(2) + ' KB total');
                                }
                                continueCounting();
                            },
                            error: function (object, response, message) {
                                continueCounting();
                                var markup = '';
                                markup += 'Not all of your images were preloaded!<br>';
                                markup += 'Loader failed getting image sizes.<br><br>';
                                markup += '1. Make sure your images exist.<br>';
                                markup += '2. Make sure your image paths/urls are correct.<br>';
                                markup += '3. If you load images from a remote domain set <code>truePercentage: false</code>.<br><br>';
                                markup += '<button>Close</button>';
                                progressNotification.addClass('error').html(markup);
                                progressBar.addClass('error');
                                settings.fadeOutDuration = 500000;
                                $('#preloader button').click(function () {
                                    preloadContainer.remove();
                                });
                            }
                        });
                        function continueCounting() {
                            count++;
                            if (count === totalImages) {
                                if (settings.debugMode) {
                                    console.groupEnd();
                                    console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': getting image sizes DONE');
                                }
                                startPreloading();
                            }
                        }
                    });
                } else {
                    if (settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': getting image sizes SKIPPED');
                    }
                    totalPercentage = totalImages;
                    startPreloading();
                }
                function startPreloading() {
                    if (settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': preloading image elements...');
                        console.groupCollapsed('intervals');
                    }
                    if (!settings.forceSequentialLoad) {
                        imageElements.forEach(function (element, index) {
                            var img = $('<img>').attr('src', getImageUrl(element.node));
                            img.load(function () {
                                updateLoader(element);
                            }).error(function () {
                                updateLoader(element);
                                handleLoadingError(img, element);
                            });
                        });
                    } else {
                        (function loadImage(index) {
                            var currentElement = imageElements[index];
                            var img = $('<img>').attr('src', getImageUrl(currentElement.node));
                            img.load(function () {
                                updateLoader(currentElement);
                                if (++index < imageElements.length) {
                                    loadImage(index);
                                }
                            }).error(function () {
                                updateLoader(currentElement);
                                if (++index < imageElements.length) {
                                    loadImage(index);
                                }
                                handleLoadingError(img, currentElement);
                            });
                        }
                        )(0);
                    }
                }
                function handleLoadingError(image, element) {
                    element.node.addClass('preloader_not_found_error');
                }
                function updateLoader(element) {
                    imagesLoaded++;
                    updateProgressPercentage(element);
                    updateProgressbar(progressPercentage, undefined, element);
                    if (settings.progressiveReveal) {
                        revealElement(element.node);
                    }
                    settings.afterEach.call(element.node);
                }
                function updateProgressPercentage(element) {
                    if (settings.truePercentage) {
                        progressPercentage += (element.fileSize / totalPercentage) * 100;
                        if (imagesLoaded === totalImages) {
                            progressPercentage = 100;
                        }
                    } else {
                        progressPercentage = (imagesLoaded / totalPercentage) * 100;
                    }
                }
                function updateProgressbar(value, updateDuration, element) {
                    updateDuration = updateDuration !== undefined ? updateDuration : settings.animateDuration;
                    var totalWidth = 0;
                    var updateTo = value;
                    var remaining = 0;
                    if (updateDuration === undefined && settings.debugMode) {
                        console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': ' + value.toFixed(2) + '%');
                    }
                    if (value < 100) {
                        if (element !== undefined) {
                            if (element.round === undefined) {
                                element.round = 0;
                                updateTo = value / 4 * 3;
                                remaining = value / 4;
                            } else {
                                element.round++;
                                updateTo = value / (4 + element.round) * (3 + element.round);
                                remaining = value / (4 + element.round);
                                updateDuration = 200;
                            }
                        }
                    }
                    if (element === undefined) {
                        element = {};
                    }
                    if (element.round === undefined) {
                        element.round = 0;
                    }
                    if (updateTo > minUpdateToValue) {
                        minUpdateToValue = updateTo;
                    }
                    if (updateTo < minUpdateToValue) {
                        updateTo = minUpdateToValue;
                    }
                    progressLoaded.stop();
                    if (element.round < 30) {
                        progressLoaded.animate({
                            'height': updateTo + '%'
                        }, {
                                duration: updateDuration,
                                easing: 'linear',
                                step: function () {
                                    totalWidth = progressBar.height();
                                    progressNotification.children('span').html(Math.round((progressLoaded.height() / totalWidth) * 100));
                                },
                                complete: function () {
                                    progressNotification.children('span').html(Math.round(updateTo));
                                    if (imagesLoaded === totalImages) {
                                        if (settings.debugMode) {
                                            console.groupEnd();
                                            console.log((((new Date).getTime() - startTime) / 1000).toFixed(3) + ': preloading image elements DONE');
                                            console.groupEnd();
                                        }
                                        progressLoaded.delay(100).queue(function () {
                                            if (settings.showImagesBeforeComplete) {
                                                imageElements.forEach(function (element) {
                                                    revealElement(element.node);
                                                });
                                                nonImageElements.forEach(function (element) {
                                                    revealElement(element);
                                                });
                                                settings.beforeComplete.call(this);
                                                settings.onComplete.call(this);
                                                preloadContainer.animate({
                                                    'opacity': '0'
                                                }, settings.fadeOutDuration, function () {
                                                    preloadContainer.remove();
                                                });
                                            } else {
                                                settings.beforeComplete.call(this);
                                                preloadContainer.animate({
                                                    'opacity': '0'
                                                }, settings.fadeOutDuration, function () {
                                                    imageElements.forEach(function (element) {
                                                        revealElement(element.node);
                                                    });
                                                    nonImageElements.forEach(function (element) {
                                                        revealElement(element);
                                                    });
                                                    preloadContainer.remove();
                                                    settings.onComplete.call(this);
                                                });
                                            }
                                        });
                                    } else {
                                        updateProgressbar(value, updateDuration, element);
                                    }
                                }
                            });
                    }
                }
                function getAllChildren(selector) {
                    var selectorChildren = [];
                    if (selector.children().length > 0) {
                        if (settings.preloadSelector) {
                            selectorChildren.push(selector);
                        }
                        getChildren(selector);
                    } else if (settings.preloadSelector) {
                        selectorChildren.push(selector);
                    }
                    function getChildren(element) {
                        var children = element.children();
                        if (children.length > 0) {
                            children.each(function () {
                                var _this = $(this);
                                selectorChildren.push(_this);
                                if (_this.children().length > 0) {
                                    getChildren(_this);
                                }
                            });
                        }
                    }
                    return selectorChildren;
                }
                function getImageUrl(image) {
                    if (image.css('background-image') !== 'none') {
                        return image.css('background-image').replace(/^url\(["']?/, '').replace(/["']?\)$/, '');
                    } else if (image.css('background-image') === 'none' && image.attr('data-bg')) {
                        return image.attr('data-bg').replace(/^url\(["']?/, '').replace(/["']?\)$/, '');
                    } else {
                        return image.attr('src');
                    }
                }
                function revealElement(element) {
                    if (!settings.useOpacity) {
                        element.show();
                    } else {
                        element.css('opacity', '1');
                    }
                    if (element.attr('data-bg')) {
                        element.css('background-image', element.attr('data-bg'));
                    }
                }
            });
        }
    };
    if (!('forEach' in Array.prototype)) {
        Array.prototype.forEach = function (action, that) {
            for (var i = 0, n = this.length; i < n; i++) {
                if (i in this) {
                    action.call(that, this[i], i, this);
                }
            }
        }
            ;
    }
    $.fn.preloadingSingle = function (method) {
        if (methods[method]) {
            return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return methods.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.preloading');
        }
    }
        ;
}
)(jQuery);
(function (factory) {
    if (typeof define === "function" && define.amd) {
        define(["jquery"], function ($) {
            return factory($)
        })
    } else if (typeof module === "object" && typeof module.exports === "object") {
        exports = factory(require("jquery"))
    } else {
        factory(jQuery)
    }
}
)(function ($) {
    $.easing["jswing"] = $.easing["swing"];
    var pow = Math.pow
        , sqrt = Math.sqrt
        , sin = Math.sin
        , cos = Math.cos
        , PI = Math.PI
        , c1 = 1.70158
        , c2 = c1 * 1.525
        , c3 = c1 + 1
        , c4 = 2 * PI / 3
        , c5 = 2 * PI / 4.5;
    function bounceOut(x) {
        var n1 = 7.5625
            , d1 = 2.75;
        if (x < 1 / d1) {
            return n1 * x * x
        } else if (x < 2 / d1) {
            return n1 * (x -= 1.5 / d1) * x + .75
        } else if (x < 2.5 / d1) {
            return n1 * (x -= 2.25 / d1) * x + .9375
        } else {
            return n1 * (x -= 2.625 / d1) * x + .984375
        }
    }
    $.extend($.easing, {
        def: "easeOutQuad",
        swing: function (x) {
            return $.easing[$.easing.def](x)
        },
        easeInQuad: function (x) {
            return x * x
        },
        easeOutQuad: function (x) {
            return 1 - (1 - x) * (1 - x)
        },
        easeInOutQuad: function (x) {
            return x < .5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2
        },
        easeInCubic: function (x) {
            return x * x * x
        },
        easeOutCubic: function (x) {
            return 1 - pow(1 - x, 3)
        },
        easeInOutCubic: function (x) {
            return x < .5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2
        },
        easeInQuart: function (x) {
            return x * x * x * x
        },
        easeOutQuart: function (x) {
            return 1 - pow(1 - x, 4)
        },
        easeInOutQuart: function (x) {
            return x < .5 ? 8 * x * x * x * x : 1 - pow(-2 * x + 2, 4) / 2
        },
        easeInQuint: function (x) {
            return x * x * x * x * x
        },
        easeOutQuint: function (x) {
            return 1 - pow(1 - x, 5)
        },
        easeInOutQuint: function (x) {
            return x < .5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2
        },
        easeInSine: function (x) {
            return 1 - cos(x * PI / 2)
        },
        easeOutSine: function (x) {
            return sin(x * PI / 2)
        },
        easeInOutSine: function (x) {
            return -(cos(PI * x) - 1) / 2
        },
        easeInExpo: function (x) {
            return x === 0 ? 0 : pow(2, 10 * x - 10)
        },
        easeOutExpo: function (x) {
            return x === 1 ? 1 : 1 - pow(2, -10 * x)
        },
        easeInOutExpo: function (x) {
            return x === 0 ? 0 : x === 1 ? 1 : x < .5 ? pow(2, 20 * x - 10) / 2 : (2 - pow(2, -20 * x + 10)) / 2
        },
        easeInCirc: function (x) {
            return 1 - sqrt(1 - pow(x, 2))
        },
        easeOutCirc: function (x) {
            return sqrt(1 - pow(x - 1, 2))
        },
        easeInOutCirc: function (x) {
            return x < .5 ? (1 - sqrt(1 - pow(2 * x, 2))) / 2 : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2
        },
        easeInElastic: function (x) {
            return x === 0 ? 0 : x === 1 ? 1 : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4)
        },
        easeOutElastic: function (x) {
            return x === 0 ? 0 : x === 1 ? 1 : pow(2, -10 * x) * sin((x * 10 - .75) * c4) + 1
        },
        easeInOutElastic: function (x) {
            return x === 0 ? 0 : x === 1 ? 1 : x < .5 ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2 : pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5) / 2 + 1
        },
        easeInBack: function (x) {
            return c3 * x * x * x - c1 * x * x
        },
        easeOutBack: function (x) {
            return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2)
        },
        easeInOutBack: function (x) {
            return x < .5 ? pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2
        },
        easeInBounce: function (x) {
            return 1 - bounceOut(1 - x)
        },
        easeOutBounce: bounceOut,
        easeInOutBounce: function (x) {
            return x < .5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2
        }
    })
});
(function ($) {
    var historyGlobal = {
        defaults: {
            swapBox: '',
            loadBox: '',
            swapTriggerBox: '',
            swapTrigger: '.history-btn',
            direction: '',
            inDuration: 1200,
            outDuration: 1200,
            inEasing: 'easeInSine',
            outEasing: 'easeInSine',
            bouncingBoxes: '',
            bouncingBoxHandling: 'fade',
            preloadImages: false,
            positionType: 'fixed',
            moveSwapBoxClasses: '',
            history: false,
            outerWidth: true,
            loadErrorMessage: 'The requested page was not found.',
            loadErrorBacklinkText: 'Go back to the last page',
        },
        listenToPopState: function (settings, $swapTrigger) {
            $(window).off('popstate').on('popstate', function (e) {
                var $swapBoxIn;
                switch (settings.direction) {
                    case 'left-to-right':
                        $swapBoxIn = 'history-swap-box-in-l-pushstate';
                        break;
                    case 'right-to-left':
                        $swapBoxIn = 'history-swap-box-in-r-pushstate';
                        break;
                    case 'top-to-bottom':
                        $swapBoxIn = 'history-swap-box-in-b-pushstate';
                        break;
                    case 'bottom-to-top':
                        $swapBoxIn = 'history-swap-box-in-b-pushstate';
                        break;
                    case '':
                        $swapBoxIn = 'history-swap-box-in-pushstate';
                        break;
                    default:
                        alert('History Error: \n The defined direction ' + settings.direction + ' does not exist.');
                        return false;
                        break;
                }
                historyPageSwap.swapHistoryPage(settings, $swapTrigger, $swapBoxIn);
                e.stopPropagation();
            });
        }
    };
    var historyPageSwap = {
        defaults: function ($this, options) {
            psSettings = $this.data('history-window');
            if (typeof (psSettings) == 'undefined') {
                psSettings = $.extend({}, historyGlobal.defaults, options);
                $this.data('history-window', psSettings);
            } else {
                psSettings = $.extend(psSettings, options);
            }
            return psSettings;
        },
        init: function (options) {
            var hasPushstate = (window.history && history.pushState);
            return this.each(function () {
                historyPageSwap.defaults($(this), options);
                var $swapBox = $(psSettings.swapBox)
                    , swapTriggerBox = psSettings.swapTriggerBox
                    , swapTrigger = psSettings.swapTrigger
                    , pageSwap = true;
                if (hasPushstate && $('html').not('[data-history-initialised]')) {
                    $('html').attr('data-history-initialised', 'true');
                    historyGlobal.listenToPopState(psSettings, $(swapTriggerBox + ' ' + swapTrigger));
                }
                historyMethods.trigger(psSettings, hasPushstate, swapTriggerBox, swapTrigger, pageSwap);
            });
        },
        swapHistoryPage: function (psSettings, $swapTrigger, swapBoxIn) {
            if ($('html').is('[data-history-history-pushed]')) {
                var href = location.pathname;
                $swapTrigger = $swapTrigger.filter('[href="' + href + '"]');
                historyMethods.historyLoadPage(psSettings, $swapTrigger, href, swapBoxIn);
            }
        },
        destroy: function ($this) {
            $(document).off('click', psSettings.swapTriggerBox + ' ' + psSettings.swapTrigger);
            return $(this).each(function () {
                var $this = $(this);
                $this.removeData('history-window');
            });
        },
    };
    var historySelectorSwap = {
        defaults: function ($this, options) {
            settings = $this.data('history');
            if (typeof (settings) == 'undefined') {
                settings = $.extend({}, historyGlobal.defaults, options);
                $this.data('history', settings);
            } else {
                settings = $.extend(settings, options);
            }
            return settings;
        },
        init: function (options) {
            var hasPushstate = (window.history && history.pushState);
            return this.each(function () {
                historySelectorSwap.defaults($(this), options);
                settings.swapBox = $(this);
                var swapTriggerBox = settings.swapTriggerBox, swapTrigger = settings.swapTrigger, pageSwap;
                if (settings.history == true) {
                    var pageSwap = true;
                    if (hasPushstate && $('html').not('[data-history-initialised]')) {
                        $('html').attr('data-history-initialised', 'true');
                        historyGlobal.listenToPopState(psSettings, $(swapTriggerBox + ' ' + swapTrigger));
                    }
                } else {
                    var pageSwap = false;
                }
                historyMethods.trigger(settings, true, swapTriggerBox, swapTrigger, pageSwap);
            });
        },
        destroy: function ($this) {
            $(document).off('click', settings.swapTriggerBox + ' ' + settings.swapTrigger);
            return $(this).each(function () {
                var $this = $(this);
                $this.removeData('history');
            });
        },
    };
    var historyMethods = {
        trigger: function (settings, hasPushstate, swapTriggerBox, swapTrigger, pageSwap) {
            if (hasPushstate) {
                function is_touch_device() {
                    var el = document.createElement('div');
                    el.setAttribute('ongesturestart', 'return;');
                    return typeof el.ongesturestart === "function";
                }
                ; if (is_touch_device()) {
                    $(document).on('touchend', '.ajaxPageSwitchBacklink', function () {
                        window.history.back();
                    }).off('touchend', swapTriggerBox + ' ' + swapTrigger).on('touchend', swapTriggerBox + ' ' + swapTrigger, function (e) {
                        e.preventDefault();
                        var $swapTrigger = $(this);
                        if (!$('html').hasClass('mobile') || !($swapTrigger.parent('h3').length && $swapTrigger.parents('.case-study').length)) {
                            $('<div class="history-overlay" />').appendTo('body');
                            $('.history-overlay').css({
                                'position': 'fixed',
                                'left': '0px',
                                'top': '0px',
                                'zIndex': '9999',
                                'width': '100%',
                                'height': '100%'
                            });
                            historyMethods.historyDefineSwapBoxIn(settings, $swapTrigger, hasPushstate, pageSwap);
                        }
                    });
                } else {
                    $(document).on('click', '.ajaxPageSwitchBacklink', function () {
                        window.history.back();
                    }).off('click', swapTriggerBox + ' ' + swapTrigger).on('click', swapTriggerBox + ' ' + swapTrigger, function (e) {
                        e.preventDefault();
                        var $swapTrigger = $(this);
                        $('<div class="history-overlay" />').appendTo('body');
                        $('.history-overlay').css({
                            'position': 'fixed',
                            'left': '0px',
                            'top': '0px',
                            'zIndex': '9999',
                            'width': '100%',
                            'height': '100%'
                        });
                        historyMethods.historyDefineSwapBoxIn(settings, $swapTrigger, hasPushstate, pageSwap);
                    });
                }
            }
        },
        historyDefineSwapBoxIn: function (settings, $swapTrigger, hasPushstate, pageSwap) {
            switch (settings.direction) {
                case 'left-to-right':
                case 'right-to-left':
                case 'top-to-bottom':
                case 'bottom-to-top':
                case '':
                    $swapBoxIn = 'history-swap-box-in';
                    if (!$('.history-swap-box-in').length) {
                        var item = $(this);
                        historyMethods.historyCollectLoadPageInfo(settings, $swapTrigger, hasPushstate, $swapBoxIn, pageSwap);
                    } else {
                        return false;
                    }
                    break;
                default:
                    alert('History Error: \n The defined direction ' + settings.direction + ' does not exist.');
                    return false;
                    break;
            }
        },
        historyCollectLoadPageInfo: function (settings, $swapTrigger, hasPushstate, $swapBoxIn, pageSwap) {
            var url = $swapTrigger.attr('href');
            var $swapBoxIn;
            switch (settings.direction) {
                case 'left-to-right':
                    $swapBoxIn = 'history-swap-box-in-l';
                    break;
                case 'right-to-left':
                    $swapBoxIn = 'history-swap-box-in-r';
                    break;
                case 'top-to-bottom':
                    $swapBoxIn = 'history-swap-box-in-t';
                    break;
                case 'bottom-to-top':
                    $swapBoxIn = 'history-swap-box-in-b';
                    break;
                case '':
                    $swapBoxIn = 'history-swap-box-in';
                    break;
                default:
                    alert('History Error: \n The defined direction ' + settings.direction + ' does not exist.');
                    return false;
                    break;
            }
            historyMethods.historyLoadPage(settings, $swapTrigger, url, $swapBoxIn, pageSwap);
            if (pageSwap) {
                history.pushState({
                    'url': url
                }, null, url);
                $('html').attr('data-history-history-pushed', 'true');
            }
        },
        historyLoadPage: function (settings, $swapTrigger, href, swapBoxIn, pageSwap) {
            var $swapBox = $(settings.swapBox);
            if (href != '') {
                var delayedAjax = $swapBox.hasClass('home') && $swapTrigger.parents('section').hasClass('case-study') ? 500 : 0
                    , delayed = 0;
                if (delayedAjax != 0) {
                    setTimeout(function () {
                        $swapTrigger.parents('section').addClass('clicked').find('.layer').each(function () {
                            var curr = $(this)
                                , left = curr.position().left - $(window).width() / 2
                                , top = curr.position().top - $(window).height() / 2;
                            left = left < 0 ? curr.position().left + curr.width() / 2 < $(window).width() / 2 ? -200 : 200 : 200
                            top = top < 0 ? curr.position().top + curr.height() / 2 < $(window).height() / 2 ? -200 : 200 : 200
                            $(this).css({
                                'marginTop': top,
                                'marginLeft': left
                            })
                        });
                    }, delayed);
                }
                ; if ($('header').hasClass('opened'))
                    $('.nav-trigger').trigger('click');
                setTimeout(function () {
                    historyMethods.historyAddSwapBoxIn(settings, swapBoxIn);
                    $.ajax({
                        type: 'GET',
                        url: href,
                        data: {},
                        beforeSend: function () {
                            historyMethods.historyCreateLoadBox();
                        },
                        error: function (data, xhrStatusText, xhrStatus) {
                            $swapBox.html(settings.loadErrorMessage + '<p>' + xhrStatusText + ': <strong>' + xhrStatus + '</strong></p><p><a class="ajaxPageSwitchBacklink">' + settings.loadErrorBacklinkText + '</a></p>');
                        },
                        success: function (data) {
                            $(settings.swapTriggerBox).find('*').filter('.active').removeClass('active');
                            $swapTrigger.addClass('active');
                            if (settings.bouncingBoxes) {
                                if (settings.bouncingBoxHandling == 'fade') {
                                    historyMethods.historyFadeSiblings(settings, $swapTrigger, data, swapBoxIn, pageSwap);
                                } else if (settings.bouncingBoxHandling == 'slide') {
                                    historyMethods.historySlideSiblings(settings, $swapTrigger, data, $swapBox, swapBoxIn, pageSwap);
                                }
                            } else {
                                historyMethods.historyPositionAndPrepare(settings, $swapTrigger, data, swapBoxIn, pageSwap);
                            }
                        },
                        dataType: 'html',
                    });
                }, delayedAjax);
            } else {
                alert('No target defined! Please check the references (i.e. normally href) of the swapTriggers.');
            }
        },
        historyAddSwapBoxIn: function (settings, swapBoxIn) {
            var $swapBox = $(settings.swapBox)
                , swapBoxClass = $swapBox.attr('class')
                , swapBoxTagName = $swapBox.prop("tagName");
            $(document).find('.history-swap-box-in').remove();
            if (settings.moveSwapBoxClasses) {
                $swapBox.after('<' + swapBoxTagName.toLowerCase() + ' class="history-swap-box-in ' + (typeof swapBoxClass != 'undefined' ? swapBoxClass : '') + '" id="' + swapBoxIn + '"></' + swapBoxTagName.toLowerCase() + '>');
            } else {
                $swapBox.after('<' + swapBoxTagName.toLowerCase() + ' class="history-swap-box-in" id="' + swapBoxIn + '"></' + swapBoxTagName.toLowerCase() + '>');
            }
            $swapBox.siblings('.history-swap-box-in').hide();
        },
        historyFadeSiblings: function (settings, $swapTrigger, data, swapBoxIn, pageSwap) {
            $(document).find(settings.bouncingBoxes).animate({
                opacity: 0
            }, 50, function () {
                historyMethods.historyPositionAndPrepare(settings, $swapTrigger, data, swapBoxIn, pageSwap);
            });
        },
        historySlideSiblings: function (settings, $swapTrigger, data, swapBox, swapBoxIn, pageSwap) {
            swapBox.siblings('history-ghost-box').remove();
            swapBox.wrap('<div class="history-ghost-box" style="height: ' + swapBox.outerHeight(true) + 'px"></div>');
            historyMethods.historyPositionAndPrepare(settings, $swapTrigger, data, swapBoxIn);
        },
        historyPositionAndPrepare: function (settings, $swapTrigger, data, swapBoxIn, pageSwap) {
            var $swapBox = $(settings.swapBox)
                , swapBoxId = $swapBox.attr('id')
                , swapBoxInHeader = $(data).filter('header')
                , mainOffset = $swapBox.offset()
                , mainWidth = $swapBox.width()
                , mainMarginLeft = $swapBox.css('margin-left')
                , mainMarginRight = $swapBox.css('margin-left')
                , swapBoxLeftAbsolute = mainOffset.left + parseFloat(mainMarginLeft);
            swapBoxRightAbsolute = mainOffset.left + parseFloat(mainMarginLeft) + mainWidth - parseFloat(mainMarginRight),
                $swapBoxIn = $('#' + swapBoxIn),
                loadSelector = $swapTrigger.attr('data-history-load-selector');
            if (settings.outerWidth) {
                var mainWidth = $swapBox.outerWidth();
            }
            var htmlId = data.match(/<\/*html\s+.*id="([^"].*)".*>/)
                , bodyId = data.match(/<\/*body\s+.*id="([^"].*)".*>/)
                , htmlClass = data.match(/<\/*html\s+.*class="([^"].*)".*>/)
                , bodyClass = data.match(/<\/*body\s+.*class="([^"].*)".*>/)
                , pageTitle = data.match(/<\/*title>(.*)<\/title>/);
            $swapBox.addClass('history-swap-box-out').css({
                position: 'fixed',
                top: mainOffset.top,
                left: swapBoxLeftAbsolute,
                marginLeft: 0,
                width: mainWidth,
            });
            if (swapBoxInContents = $(data).filter('#' + swapBoxId).html() != undefined) {
                if (settings.loadBox) {
                    var swapBoxInContainer = $(data).filter(settings.loadBox);
                } else if (loadSelector) {
                    var swapBoxInContainer = $(data).filter(loadSelector);
                } else {
                    var swapBoxInContainer = $(data).filter('#' + swapBoxId);
                }
                swapBoxInContents = swapBoxInContainer.html();
                var swapBoxInClasses = swapBoxInContainer.attr('class');
            } else {
                if (settings.loadBox) {
                    var swapBoxInContainer = $(data).find(settings.loadBox);
                } else if (loadSelector) {
                    var swapBoxInContainer = $(data).find(loadSelector);
                } else {
                    var swapBoxInContainer = $(data).find('#' + swapBoxId);
                }
                swapBoxInContents = swapBoxInContainer.html();
                var swapBoxInClasses = swapBoxInContainer.attr('class');
            }
            $swapBoxIn.addClass(swapBoxInClasses).css({
                position: settings.positionType,
                marginLeft: 0,
                top: mainOffset.top,
                left: swapBoxLeftAbsolute,
            }).html(swapBoxInContents);
            noformat.single.introVideoReady = noformat.single.contentReady = false;
            if ($swapTrigger.parents('section').hasClass('case-study')) {
                $swapBoxIn.find('.single-intro').preloadingSingle({
                    truePercentage: false,
                    beforeComplete: function () { },
                    onComplete: function () {
                        $('.intro-video-spinner span i').addClass('activated');
                        $(document).trigger('historyLoadCallback');
                        historyMethods.historySwapContent(settings, swapBoxIn, $swapTrigger, mainOffset, swapBoxLeftAbsolute, mainWidth, htmlId, bodyId, htmlClass, bodyClass, pageTitle, pageSwap, swapBoxInHeader);
                    }
                });
            } else {
                if ($swapBoxIn.find('.single-intro').length) {
                    $swapBoxIn.find('.single-intro').preloading({
                        truePercentage: false,
                        beforeComplete: function () { },
                        onComplete: function () {
                            $('.intro-video-spinner span i').addClass('activated');
                            $(document).trigger('historyLoadCallback');
                            historyMethods.historySwapContent(settings, swapBoxIn, $swapTrigger, mainOffset, swapBoxLeftAbsolute, mainWidth, htmlId, bodyId, htmlClass, bodyClass, pageTitle, pageSwap, swapBoxInHeader);
                        }
                    });
                } else {
                    $swapBoxIn.preloading({
                        beforeComplete: function () { },
                        onComplete: function () {
                            $(document).trigger('historyLoadCallback');
                            historyMethods.historySwapContent(settings, swapBoxIn, $swapTrigger, mainOffset, swapBoxLeftAbsolute, mainWidth, htmlId, bodyId, htmlClass, bodyClass, pageTitle, pageSwap, swapBoxInHeader);
                        }
                    });
                }
            }
            ;
        },
        historySwapContent: function (settings, swapBoxIn, $swapTrigger, mainOffset, swapBoxLeftAbsolute, mainWidth, htmlId, bodyId, htmlClass, bodyClass, pageTitle, pageSwap, swapBoxInHeader) {
            var $swapBox = $(settings.swapBox)
                , swapBoxId = $swapBox.attr('id')
                , $swapBoxIn = $('#' + swapBoxIn)
                , swapBoxInHeight = $swapBoxIn.outerHeight()
                , swapBoxInWidth = $swapBoxIn.outerWidth()
                , swapBoxHeight = $swapBox.outerHeight()
                , viewportHeight = $(window).outerHeight()
                , viewportWidth = $(window).outerWidth()
                , hash = $swapTrigger.prop('hash');
            clearTimeout(loadTimer);
            historyMethods.historyRemoveLoadBox();
            if ($('html').hasClass('mobile'))
                $('header').removeClass('header-up sticky-header');
            $('header nav').find('.history-btn').removeClass('active');
            var currUrl = window.location;
            $('header nav .main li a[href="' + currUrl + '"]').addClass('active');
            $swapBoxIn.css({
                width: mainWidth
            });
            var swapBoxOutAnimProperties = {}
                , swapBoxInAnimProperties = {};
            var swapBoxOutAnimValue;
            switch (swapBoxIn) {
                case 'history-swap-box-in-t':
                case 'history-swap-box-in-t-pushstate':
                    break;
                case 'history-swap-box-in-b-pushstate':
                case 'history-swap-box-in-b':
                    $swapBoxIn.css('top', swapBoxHeight);
                    swapBoxOutAnimValue = -swapBoxHeight;
                    break;
                case 'history-swap-box-in-r-pushstate':
                case 'history-swap-box-in-l':
                    $swapBoxIn.css('left', -viewportWidth);
                    swapBoxOutAnimValue = viewportWidth;
                    break;
                case 'history-swap-box-in-l-pushstate':
                case 'history-swap-box-in-r':
                    $swapBoxIn.css('left', viewportWidth);
                    swapBoxOutAnimValue = -viewportWidth;
                    break;
                default:
                    alert('History Error: \n The swapBoxIn class is in an undefined format: ' + swapBoxIn + '.');
                    return false;
                    break;
            }
            noformat.windowW = null;
            if (swapBoxIn == 'history-swap-box-in-b-pushstate' || swapBoxIn == 'history-swap-box-in-b') {
                var additionValue = (swapBoxHeight * settings.inDuration / 1000)
                    , finalVal = additionValue / 100
                    , finalInDuration = settings.inDuration + finalVal
                    , finalOutDuration = settings.outDuration;
                swapBoxInAnimProperties = {
                    top: mainOffset.top
                };
                swapBoxOutAnimProperties = {
                    top: swapBoxOutAnimValue
                };
                $('body').css('overflow-y', 'scroll');
                var swapBoxInFullHeight = $swapBoxIn.outerHeight(true);
                if ($swapBox.parent('.history-ghost-box')) {
                    $ghostBox = $swapBox.parent('.history-ghost-box');
                    $ghostBox.animate({
                        height: swapBoxInFullHeight,
                    });
                }
                $swapBoxIn.find('.sections-nav, header, .mouse, .intro-content').removeClass('initial');
                $('<div class="red-overlay" />').appendTo('body').stop().animate({
                    'top': '0'
                }, {
                        duration: 600,
                        easing: 'easeInCubic',
                        complete: function () {
                            $swapBox.remove();
                            $('body').css('background-color', '');
                            $('header').css('margin-top', '0px').removeClass('sticky-header');
                            $(this).stop().animate({
                                'top': '-100%'
                            }, {
                                    duration: 600,
                                    easing: 'easeOutCubic'
                                });
                            $swapBoxIn.stop().show().animate(swapBoxInAnimProperties, 600, 'easeOutCubic', function () {
                                $ghostBox.remove();
                                $(this).css({
                                    display: '',
                                    left: '',
                                    marginLeft: '',
                                    position: '',
                                    top: '',
                                    width: ''
                                }).attr('id', swapBoxId).removeClass('history-swap-box-in');
                                $('.red-overlay').remove();
                                $(document).scrollTop(0);
                                if ($swapBoxIn.hasClass('about')) {
                                    var weAreArray = ['strategists-list', 'designers-list', 'developers-list', 'inventors-list', 'artists-list', 'storytellers-list'];
                                    for (var i = 0; i < 4; i++) {
                                        var curr = weAreArray[Math.floor(Math.random() * weAreArray.length)];
                                        $('.we-are .text em[data-list="' + curr + '"]').addClass('blink');
                                        weAreArray.splice($.inArray(curr, weAreArray), 1);
                                    }
                                    $('.we-are .text .blink').each(function (i) {
                                        var el = $(this);
                                        setTimeout(function () {
                                            el.addClass('hovered');
                                            setTimeout(function () {
                                                el.removeClass('hovered');
                                            }, 250)
                                        }, i * 150);
                                    })
                                }
                                historyMethods.animationCallback(hash, settings, pageSwap);
                            });
                            historyMethods.historySwitchClasses(htmlId, bodyId, htmlClass, bodyClass, pageTitle);
                            if ($('html').hasClass('desktop')) {
                                noformat.single.contentReady = true;
                                if (noformat.single.introVideoReady) {
                                    noformat.single.players[0].play();
                                }
                            }
                            noformat.init();
                        }
                    })
                swapBoxInHeader.hasClass('light') ? $('header').addClass('light') : $('header').removeClass('light');
            } else {
                var clonedIntro = $swapBoxIn.find('.single-intro').clone(true, true);
                clonedIntro.find('article').remove();
                clonedIntro.find('.video-wrapper').remove();
                clonedIntro.find('.bgr-holder').css('display', 'block');
                $swapBoxIn.find('.bgr-holder').css('display', 'block');
                $swapBoxIn.find('.single-intro article').css('opacity', '0');
                $swapBoxIn.find('.single-intro .video-wrapper').css('opacity', '0');
                $swapBoxIn.find('.single-intro .vimeovideo-play-large').css({
                    'opacity': '0',
                    'visibility': 'hidden'
                });
                clonedIntro.css({
                    'position': 'absolute',
                    'left': '0px',
                    'top': '0px',
                    'width': '100%',
                    'height': $(window).height() * 0.85,
                    'zIndex': '9999',
                    'opacity': '0',
                    '-webkit-transform': 'translate3d(0, 0, 0)',
                    '-moz-transform': 'translate3d(0, 0, 0)',
                    'transform': 'translate3d(0, 0, 0)',
                    '-webkit-transition': 'all 600ms 0ms ease-in-out',
                    '-moz-transition': 'all 600ms 0ms ease-in-out',
                    'transition': 'all 600ms 0ms ease-in-out',
                    'backfaceVisibility': 'hidden'
                });
                $swapTrigger.parents('section').find('.media-holder span').css({
                    'opacity': '0',
                    '-webkit-transition': 'all 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)',
                    '-moz-transition': 'all 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)',
                    'transition': 'all 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)'
                })
                $swapTrigger.parents('section').find('.media-holder').append(clonedIntro).css({
                    '-webkit-transition': 'all 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)',
                    '-moz-transition': 'all 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)',
                    'transition': 'all 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)'
                });
                $swapTrigger.parents('section').find('article').css({
                    '-webkit-transform': 'translate3d(-50%,' + -noformat.windowH + 'px, 0)',
                    '-moz-transform': 'translate3d(-50%,' + -noformat.windowH + 'px, 0)',
                    'transform': 'translate3d(-50%,' + -noformat.windowH + 'px, 0)',
                    '-webkit-transition': '-webkit-transform 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)',
                    '-moz-transition': '-moz-transform 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)',
                    'transition': 'transform 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)',
                    'will-change': 'transform'
                });
                $swapTrigger.parents('section').find('.parallax').parallax('disable');
                $swapTrigger.parents('section').find('.parallax').css({
                    '-webkit-transform': 'translate3d(-50%,' + -noformat.windowH * 2 + 'px, 0)',
                    '-moz-transform': 'translate3d(-50%,' + -noformat.windowH * 2 + 'px, 0)',
                    'transform': 'translate3d(-50%,' + -noformat.windowH * 2 + 'px, 0)',
                    '-webkit-transition': '-webkit-transform 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)',
                    '-moz-transition': '-moz-transform 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)',
                    'transition': 'transform 1000ms 0ms cubic-bezier(0.645, 0.045, 0.355, 1.000)',
                    'will-change': 'transform'
                });
                setTimeout(function () {
                    clonedIntro.css('opacity', '1');
                    $swapTrigger.parents('section').removeClass('clicked');
                    setTimeout(function () {
                        historyMethods.historySwitchClasses(htmlId, bodyId, htmlClass, bodyClass, pageTitle);
                        $swapBox.remove();
                        noformat.init();
                        $swapBoxIn.css({
                            display: '',
                            left: '',
                            marginLeft: '',
                            position: '',
                            top: '',
                            width: '',
                        }).attr('id', swapBoxId).removeClass('history-swap-box-in');
                        historyMethods.animationCallback(hash, settings, pageSwap);
                        $swapBoxIn.find('.single-intro .video-wrapper').css('opacity', '1');
                        $swapBoxIn.find('.single-intro article').stop().animate({
                            'opacity': '1'
                        }, 1000);
                        $swapBoxIn.find('.single-intro .vimeovideo-play-large').css({
                            'opacity': '0',
                            'visibility': 'hidden'
                        });
                        noformat.single.contentReady = true;
                        if (noformat.single.introVideoReady) {
                            noformat.single.players[0].play();
                        }
                        $(window).trigger('resize');
                    }, 950);
                    swapBoxInHeader.hasClass('light') ? $('header').addClass('light') : $('header').removeClass('light');
                }, 10);
            }
        },
        animationCallback: function (hash, settings, pageSwap) {
            if (hash) {
                $('html:not(:animated),body:not(:animated)').animate({
                    scrollTop: $(hash).offset().top
                }, 'normal');
            }
            $('.history-overlay').remove();
            historyMethods.historyCheckForSiblings(settings, pageSwap);
        },
        historyCheckForSiblings: function (settings, pageSwap) {
            if (settings.bouncingBoxes) {
                $(document).find(settings.bouncingBoxes).animate({
                    opacity: 1
                }, 400, function () {
                    (1 ? historyMethods.historySwapCallback() : historyMethods.historySwapSectionCallback());
                });
            } else {
                (1 ? historyMethods.historySwapCallback() : historyMethods.historySwapSectionCallback());
            }
        },
        historySwitchClasses: function (htmlId, bodyId, htmlClass, bodyClass, pageTitle) {
            $('body').attr({
                'class': '',
                'id': '',
            });
            (bodyId ? $('body').attr('id', bodyId[1]) : '');
            (bodyClass ? $('body').addClass(bodyClass[1]) : '');
            (pageTitle ? $('title').text(pageTitle[1]) : '');
        },
        historyCreateLoadBox: function () {
            if (!$('#history-loading-box').length) {
                loadTimer = setTimeout(function () {
                    $('html').append('<div id="history-loading-box"><div class="history-loading"></div></div>');
                    $('#history-loading-box').fadeIn('fast');
                }, 200);
            } else {
                historyMethods.historyRemoveLoadBox();
                historyMethods.historyCreateLoadBox();
            }
        },
        historyRemoveLoadBox: function () {
            $('#history-loading-box').fadeOut('fast').remove();
        },
        historySwapCallback: function () {
            $('body').css({
                overflowX: 'auto'
            });
            $(document).trigger('historySwapCallback');
        },
        historySwapSectionCallback: function () {
            $(document).trigger('historySwapSectionCallback');
        },
    };
    $.history = function (method) {
        if (historyPageSwap[method]) {
            return historyPageSwap[method].apply($(window), Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return historyPageSwap.init.apply($(window), arguments, false);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.history');
        }
    }
        ;
    $.fn.history = function (method) {
        if (historySelectorSwap[method]) {
            return historySelectorSwap[method].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof method === 'object' || !method) {
            return historySelectorSwap.init.apply(this, arguments);
        } else {
            $.error('Method ' + method + ' does not exist on jQuery.history');
        }
    }
        ;
}
)(jQuery);
(function (factory) {
    if (typeof define === 'function' && define.amd && define.amd.jQuery) {
        define(['jquery'], factory);
    } else if (typeof module !== 'undefined' && module.exports) {
        factory(require("jquery"));
    } else {
        factory(jQuery);
    }
}(function ($) {
    "use strict";
    var VERSION = "1.6.18"
        , LEFT = "left"
        , RIGHT = "right"
        , UP = "up"
        , DOWN = "down"
        , IN = "in"
        , OUT = "out"
        , NONE = "none"
        , AUTO = "auto"
        , SWIPE = "swipe"
        , PINCH = "pinch"
        , TAP = "tap"
        , DOUBLE_TAP = "doubletap"
        , LONG_TAP = "longtap"
        , HOLD = "hold"
        , HORIZONTAL = "horizontal"
        , VERTICAL = "vertical"
        , ALL_FINGERS = "all"
        , DOUBLE_TAP_THRESHOLD = 10
        , PHASE_START = "start"
        , PHASE_MOVE = "move"
        , PHASE_END = "end"
        , PHASE_CANCEL = "cancel"
        , SUPPORTS_TOUCH = 'ontouchstart' in window
        , SUPPORTS_POINTER_IE10 = window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !SUPPORTS_TOUCH
        , SUPPORTS_POINTER = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !SUPPORTS_TOUCH
        , PLUGIN_NS = 'TouchSwipe';
    var defaults = {
        fingers: 1,
        threshold: 75,
        cancelThreshold: null,
        pinchThreshold: 20,
        maxTimeThreshold: null,
        fingerReleaseThreshold: 250,
        longTapThreshold: 500,
        doubleTapThreshold: 200,
        swipe: null,
        swipeLeft: null,
        swipeRight: null,
        swipeUp: null,
        swipeDown: null,
        swipeStatus: null,
        pinchIn: null,
        pinchOut: null,
        pinchStatus: null,
        click: null,
        tap: null,
        doubleTap: null,
        longTap: null,
        hold: null,
        triggerOnTouchEnd: true,
        triggerOnTouchLeave: false,
        allowPageScroll: "auto",
        fallbackToMouseEvents: false,
        excludedElements: ".noSwipe",
        preventDefaultEvents: true
    };
    $.fn.swipe = function (method) {
        var $this = $(this)
            , plugin = $this.data(PLUGIN_NS);
        if (plugin && typeof method === 'string') {
            if (plugin[method]) {
                return plugin[method].apply(plugin, Array.prototype.slice.call(arguments, 1));
            } else {
                $.error('Method ' + method + ' does not exist on jQuery.swipe');
            }
        } else if (plugin && typeof method === 'object') {
            plugin['option'].apply(plugin, arguments);
        } else if (!plugin && (typeof method === 'object' || !method)) {
            return init.apply(this, arguments);
        }
        return $this;
    }
        ;
    $.fn.swipe.version = VERSION;
    $.fn.swipe.defaults = defaults;
    $.fn.swipe.phases = {
        PHASE_START: PHASE_START,
        PHASE_MOVE: PHASE_MOVE,
        PHASE_END: PHASE_END,
        PHASE_CANCEL: PHASE_CANCEL
    };
    $.fn.swipe.directions = {
        LEFT: LEFT,
        RIGHT: RIGHT,
        UP: UP,
        DOWN: DOWN,
        IN: IN,
        OUT: OUT
    };
    $.fn.swipe.pageScroll = {
        NONE: NONE,
        HORIZONTAL: HORIZONTAL,
        VERTICAL: VERTICAL,
        AUTO: AUTO
    };
    $.fn.swipe.fingers = {
        ONE: 1,
        TWO: 2,
        THREE: 3,
        FOUR: 4,
        FIVE: 5,
        ALL: ALL_FINGERS
    };
    function init(options) {
        if (options && (options.allowPageScroll === undefined && (options.swipe !== undefined || options.swipeStatus !== undefined))) {
            options.allowPageScroll = NONE;
        }
        if (options.click !== undefined && options.tap === undefined) {
            options.tap = options.click;
        }
        if (!options) {
            options = {};
        }
        options = $.extend({}, $.fn.swipe.defaults, options);
        return this.each(function () {
            var $this = $(this);
            var plugin = $this.data(PLUGIN_NS);
            if (!plugin) {
                plugin = new TouchSwipe(this, options);
                $this.data(PLUGIN_NS, plugin);
            }
        });
    }
    function TouchSwipe(element, options) {
        var options = $.extend({}, options);
        var useTouchEvents = (SUPPORTS_TOUCH || SUPPORTS_POINTER || !options.fallbackToMouseEvents)
            , START_EV = useTouchEvents ? (SUPPORTS_POINTER ? (SUPPORTS_POINTER_IE10 ? 'MSPointerDown' : 'pointerdown') : 'touchstart') : 'mousedown'
            , MOVE_EV = useTouchEvents ? (SUPPORTS_POINTER ? (SUPPORTS_POINTER_IE10 ? 'MSPointerMove' : 'pointermove') : 'touchmove') : 'mousemove'
            , END_EV = useTouchEvents ? (SUPPORTS_POINTER ? (SUPPORTS_POINTER_IE10 ? 'MSPointerUp' : 'pointerup') : 'touchend') : 'mouseup'
            , LEAVE_EV = useTouchEvents ? (SUPPORTS_POINTER ? 'mouseleave' : null) : 'mouseleave'
            , CANCEL_EV = (SUPPORTS_POINTER ? (SUPPORTS_POINTER_IE10 ? 'MSPointerCancel' : 'pointercancel') : 'touchcancel');
        var distance = 0
            , direction = null
            , currentDirection = null
            , duration = 0
            , startTouchesDistance = 0
            , endTouchesDistance = 0
            , pinchZoom = 1
            , pinchDistance = 0
            , pinchDirection = 0
            , maximumsMap = null;
        var $element = $(element);
        var phase = "start";
        var fingerCount = 0;
        var fingerData = {};
        var startTime = 0
            , endTime = 0
            , previousTouchEndTime = 0
            , fingerCountAtRelease = 0
            , doubleTapStartTime = 0;
        var singleTapTimeout = null
            , holdTimeout = null;
        try {
            $element.bind(START_EV, touchStart);
            $element.bind(CANCEL_EV, touchCancel);
        } catch (e) {
            $.error('events not supported ' + START_EV + ',' + CANCEL_EV + ' on jQuery.swipe');
        }
        this.enable = function () {
            this.disable();
            $element.bind(START_EV, touchStart);
            $element.bind(CANCEL_EV, touchCancel);
            return $element;
        }
            ;
        this.disable = function () {
            removeListeners();
            return $element;
        }
            ;
        this.destroy = function () {
            removeListeners();
            $element.data(PLUGIN_NS, null);
            $element = null;
        }
            ;
        this.option = function (property, value) {
            if (typeof property === 'object') {
                options = $.extend(options, property);
            } else if (options[property] !== undefined) {
                if (value === undefined) {
                    return options[property];
                } else {
                    options[property] = value;
                }
            } else if (!property) {
                return options;
            } else {
                $.error('Option ' + property + ' does not exist on jQuery.swipe.options');
            }
            return null;
        }
        function touchStart(jqEvent) {
            if (getTouchInProgress()) {
                return;
            }
            if ($(jqEvent.target).closest(options.excludedElements, $element).length > 0) {
                return;
            }
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            if (event.pointerType && event.pointerType == "mouse" && options.fallbackToMouseEvents == false) {
                return;
            }
            ; var ret, touches = event.touches, evt = touches ? touches[0] : event;
            phase = PHASE_START;
            if (touches) {
                fingerCount = touches.length;
            } else if (options.preventDefaultEvents !== false) {
                jqEvent.preventDefault();
            }
            distance = 0;
            direction = null;
            currentDirection = null;
            pinchDirection = null;
            duration = 0;
            startTouchesDistance = 0;
            endTouchesDistance = 0;
            pinchZoom = 1;
            pinchDistance = 0;
            maximumsMap = createMaximumsData();
            cancelMultiFingerRelease();
            createFingerData(0, evt);
            if (!touches || (fingerCount === options.fingers || options.fingers === ALL_FINGERS) || hasPinches()) {
                startTime = getTimeStamp();
                if (fingerCount == 2) {
                    createFingerData(1, touches[1]);
                    startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start);
                }
                if (options.swipeStatus || options.pinchStatus) {
                    ret = triggerHandler(event, phase);
                }
            } else {
                ret = false;
            }
            if (ret === false) {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase);
                return ret;
            } else {
                if (options.hold) {
                    holdTimeout = setTimeout($.proxy(function () {
                        $element.trigger('hold', [event.target]);
                        if (options.hold) {
                            ret = options.hold.call($element, event, event.target);
                        }
                    }, this), options.longTapThreshold);
                }
                setTouchInProgress(true);
            }
            return null;
        }
        ; function touchMove(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            if (phase === PHASE_END || phase === PHASE_CANCEL || inMultiFingerRelease())
                return;
            var ret, touches = event.touches, evt = touches ? touches[0] : event;
            var currentFinger = updateFingerData(evt);
            endTime = getTimeStamp();
            if (touches) {
                fingerCount = touches.length;
            }
            if (options.hold) {
                clearTimeout(holdTimeout);
            }
            phase = PHASE_MOVE;
            if (fingerCount == 2) {
                if (startTouchesDistance == 0) {
                    createFingerData(1, touches[1]);
                    startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start);
                } else {
                    updateFingerData(touches[1]);
                    endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end);
                    pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end);
                }
                pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance);
                pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance);
            }
            if ((fingerCount === options.fingers || options.fingers === ALL_FINGERS) || !touches || hasPinches()) {
                direction = calculateDirection(currentFinger.start, currentFinger.end);
                currentDirection = calculateDirection(currentFinger.last, currentFinger.end);
                validateDefaultEvent(jqEvent, currentDirection);
                distance = calculateDistance(currentFinger.start, currentFinger.end);
                duration = calculateDuration();
                setMaxDistance(direction, distance);
                ret = triggerHandler(event, phase);
                if (!options.triggerOnTouchEnd || options.triggerOnTouchLeave) {
                    var inBounds = true;
                    if (options.triggerOnTouchLeave) {
                        var bounds = getbounds(this);
                        inBounds = isInBounds(currentFinger.end, bounds);
                    }
                    if (!options.triggerOnTouchEnd && inBounds) {
                        phase = getNextPhase(PHASE_MOVE);
                    } else if (options.triggerOnTouchLeave && !inBounds) {
                        phase = getNextPhase(PHASE_END);
                    }
                    if (phase == PHASE_CANCEL || phase == PHASE_END) {
                        triggerHandler(event, phase);
                    }
                }
            } else {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase);
            }
            if (ret === false) {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase);
            }
        }
        function touchEnd(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent
                , touches = event.touches;
            if (touches) {
                if (touches.length && !inMultiFingerRelease()) {
                    startMultiFingerRelease(event);
                    return true;
                } else if (touches.length && inMultiFingerRelease()) {
                    return true;
                }
            }
            if (inMultiFingerRelease()) {
                fingerCount = fingerCountAtRelease;
            }
            endTime = getTimeStamp();
            duration = calculateDuration();
            if (didSwipeBackToCancel() || !validateSwipeDistance()) {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase);
            } else if (options.triggerOnTouchEnd || (options.triggerOnTouchEnd === false && phase === PHASE_MOVE)) {
                if (options.preventDefaultEvents !== false) {
                    jqEvent.preventDefault();
                }
                phase = PHASE_END;
                triggerHandler(event, phase);
            } else if (!options.triggerOnTouchEnd && hasTap()) {
                phase = PHASE_END;
                triggerHandlerForGesture(event, phase, TAP);
            } else if (phase === PHASE_MOVE) {
                phase = PHASE_CANCEL;
                triggerHandler(event, phase);
            }
            setTouchInProgress(false);
            return null;
        }
        function touchCancel() {
            fingerCount = 0;
            endTime = 0;
            startTime = 0;
            startTouchesDistance = 0;
            endTouchesDistance = 0;
            pinchZoom = 1;
            cancelMultiFingerRelease();
            setTouchInProgress(false);
        }
        function touchLeave(jqEvent) {
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            if (options.triggerOnTouchLeave) {
                phase = getNextPhase(PHASE_END);
                triggerHandler(event, phase);
            }
        }
        function removeListeners() {
            $element.unbind(START_EV, touchStart);
            $element.unbind(CANCEL_EV, touchCancel);
            $element.unbind(MOVE_EV, touchMove);
            $element.unbind(END_EV, touchEnd);
            if (LEAVE_EV) {
                $element.unbind(LEAVE_EV, touchLeave);
            }
            setTouchInProgress(false);
        }
        function getNextPhase(currentPhase) {
            var nextPhase = currentPhase;
            var validTime = validateSwipeTime();
            var validDistance = validateSwipeDistance();
            var didCancel = didSwipeBackToCancel();
            if (!validTime || didCancel) {
                nextPhase = PHASE_CANCEL;
            } else if (validDistance && currentPhase == PHASE_MOVE && (!options.triggerOnTouchEnd || options.triggerOnTouchLeave)) {
                nextPhase = PHASE_END;
            } else if (!validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave) {
                nextPhase = PHASE_CANCEL;
            }
            return nextPhase;
        }
        function triggerHandler(event, phase) {
            var ret, touches = event.touches;
            if (didSwipe() || hasSwipes()) {
                ret = triggerHandlerForGesture(event, phase, SWIPE);
            }
            if ((didPinch() || hasPinches()) && ret !== false) {
                ret = triggerHandlerForGesture(event, phase, PINCH);
            }
            if (didDoubleTap() && ret !== false) {
                ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP);
            } else if (didLongTap() && ret !== false) {
                ret = triggerHandlerForGesture(event, phase, LONG_TAP);
            } else if (didTap() && ret !== false) {
                ret = triggerHandlerForGesture(event, phase, TAP);
            }
            if (phase === PHASE_CANCEL) {
                touchCancel(event);
            }
            if (phase === PHASE_END) {
                if (touches) {
                    if (!touches.length) {
                        touchCancel(event);
                    }
                } else {
                    touchCancel(event);
                }
            }
            return ret;
        }
        function triggerHandlerForGesture(event, phase, gesture) {
            var ret;
            if (gesture == SWIPE) {
                $element.trigger('swipeStatus', [phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection]);
                if (options.swipeStatus) {
                    ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount, fingerData, currentDirection);
                    if (ret === false)
                        return false;
                }
                if (phase == PHASE_END && validateSwipe()) {
                    clearTimeout(singleTapTimeout);
                    clearTimeout(holdTimeout);
                    $element.trigger('swipe', [direction, distance, duration, fingerCount, fingerData, currentDirection]);
                    if (options.swipe) {
                        ret = options.swipe.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection);
                        if (ret === false)
                            return false;
                    }
                    switch (direction) {
                        case LEFT:
                            $element.trigger('swipeLeft', [direction, distance, duration, fingerCount, fingerData, currentDirection]);
                            if (options.swipeLeft) {
                                ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection);
                            }
                            break;
                        case RIGHT:
                            $element.trigger('swipeRight', [direction, distance, duration, fingerCount, fingerData, currentDirection]);
                            if (options.swipeRight) {
                                ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection);
                            }
                            break;
                        case UP:
                            $element.trigger('swipeUp', [direction, distance, duration, fingerCount, fingerData, currentDirection]);
                            if (options.swipeUp) {
                                ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection);
                            }
                            break;
                        case DOWN:
                            $element.trigger('swipeDown', [direction, distance, duration, fingerCount, fingerData, currentDirection]);
                            if (options.swipeDown) {
                                ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount, fingerData, currentDirection);
                            }
                            break;
                    }
                }
            }
            if (gesture == PINCH) {
                $element.trigger('pinchStatus', [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]);
                if (options.pinchStatus) {
                    ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData);
                    if (ret === false)
                        return false;
                }
                if (phase == PHASE_END && validatePinch()) {
                    switch (pinchDirection) {
                        case IN:
                            $element.trigger('pinchIn', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]);
                            if (options.pinchIn) {
                                ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData);
                            }
                            break;
                        case OUT:
                            $element.trigger('pinchOut', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData]);
                            if (options.pinchOut) {
                                ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom, fingerData);
                            }
                            break;
                    }
                }
            }
            if (gesture == TAP) {
                if (phase === PHASE_CANCEL || phase === PHASE_END) {
                    clearTimeout(singleTapTimeout);
                    clearTimeout(holdTimeout);
                    if (hasDoubleTap() && !inDoubleTap()) {
                        doubleTapStartTime = getTimeStamp();
                        singleTapTimeout = setTimeout($.proxy(function () {
                            doubleTapStartTime = null;
                            $element.trigger('tap', [event.target]);
                            if (options.tap) {
                                ret = options.tap.call($element, event, event.target);
                            }
                        }, this), options.doubleTapThreshold);
                    } else {
                        doubleTapStartTime = null;
                        $element.trigger('tap', [event.target]);
                        if (options.tap) {
                            ret = options.tap.call($element, event, event.target);
                        }
                    }
                }
            } else if (gesture == DOUBLE_TAP) {
                if (phase === PHASE_CANCEL || phase === PHASE_END) {
                    clearTimeout(singleTapTimeout);
                    clearTimeout(holdTimeout);
                    doubleTapStartTime = null;
                    $element.trigger('doubletap', [event.target]);
                    if (options.doubleTap) {
                        ret = options.doubleTap.call($element, event, event.target);
                    }
                }
            } else if (gesture == LONG_TAP) {
                if (phase === PHASE_CANCEL || phase === PHASE_END) {
                    clearTimeout(singleTapTimeout);
                    doubleTapStartTime = null;
                    $element.trigger('longtap', [event.target]);
                    if (options.longTap) {
                        ret = options.longTap.call($element, event, event.target);
                    }
                }
            }
            return ret;
        }
        function validateSwipeDistance() {
            var valid = true;
            if (options.threshold !== null) {
                valid = distance >= options.threshold;
            }
            return valid;
        }
        function didSwipeBackToCancel() {
            var cancelled = false;
            if (options.cancelThreshold !== null && direction !== null) {
                cancelled = (getMaxDistance(direction) - distance) >= options.cancelThreshold;
            }
            return cancelled;
        }
        function validatePinchDistance() {
            if (options.pinchThreshold !== null) {
                return pinchDistance >= options.pinchThreshold;
            }
            return true;
        }
        function validateSwipeTime() {
            var result;
            if (options.maxTimeThreshold) {
                if (duration >= options.maxTimeThreshold) {
                    result = false;
                } else {
                    result = true;
                }
            } else {
                result = true;
            }
            return result;
        }
        function validateDefaultEvent(jqEvent, direction) {
            if (options.preventDefaultEvents === false) {
                return;
            }
            if (options.allowPageScroll === NONE) {
                jqEvent.preventDefault();
            } else {
                var auto = options.allowPageScroll === AUTO;
                switch (direction) {
                    case LEFT:
                        if ((options.swipeLeft && auto) || (!auto && options.allowPageScroll != HORIZONTAL)) {
                            jqEvent.preventDefault();
                        }
                        break;
                    case RIGHT:
                        if ((options.swipeRight && auto) || (!auto && options.allowPageScroll != HORIZONTAL)) {
                            jqEvent.preventDefault();
                        }
                        break;
                    case UP:
                        if ((options.swipeUp && auto) || (!auto && options.allowPageScroll != VERTICAL)) {
                            jqEvent.preventDefault();
                        }
                        break;
                    case DOWN:
                        if ((options.swipeDown && auto) || (!auto && options.allowPageScroll != VERTICAL)) {
                            jqEvent.preventDefault();
                        }
                        break;
                    case NONE:
                        break;
                }
            }
        }
        function validatePinch() {
            var hasCorrectFingerCount = validateFingers();
            var hasEndPoint = validateEndPoint();
            var hasCorrectDistance = validatePinchDistance();
            return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;
        }
        function hasPinches() {
            return !!(options.pinchStatus || options.pinchIn || options.pinchOut);
        }
        function didPinch() {
            return !!(validatePinch() && hasPinches());
        }
        function validateSwipe() {
            var hasValidTime = validateSwipeTime();
            var hasValidDistance = validateSwipeDistance();
            var hasCorrectFingerCount = validateFingers();
            var hasEndPoint = validateEndPoint();
            var didCancel = didSwipeBackToCancel();
            var valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
            return valid;
        }
        function hasSwipes() {
            return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown);
        }
        function didSwipe() {
            return !!(validateSwipe() && hasSwipes());
        }
        function validateFingers() {
            return ((fingerCount === options.fingers || options.fingers === ALL_FINGERS) || !SUPPORTS_TOUCH);
        }
        function validateEndPoint() {
            return fingerData[0].end.x !== 0;
        }
        function hasTap() {
            return !!(options.tap);
        }
        function hasDoubleTap() {
            return !!(options.doubleTap);
        }
        function hasLongTap() {
            return !!(options.longTap);
        }
        function validateDoubleTap() {
            if (doubleTapStartTime == null) {
                return false;
            }
            var now = getTimeStamp();
            return (hasDoubleTap() && ((now - doubleTapStartTime) <= options.doubleTapThreshold));
        }
        function inDoubleTap() {
            return validateDoubleTap();
        }
        function validateTap() {
            return ((fingerCount === 1 || !SUPPORTS_TOUCH) && (isNaN(distance) || distance < options.threshold));
        }
        function validateLongTap() {
            return ((duration > options.longTapThreshold) && (distance < DOUBLE_TAP_THRESHOLD));
        }
        function didTap() {
            return !!(validateTap() && hasTap());
        }
        function didDoubleTap() {
            return !!(validateDoubleTap() && hasDoubleTap());
        }
        function didLongTap() {
            return !!(validateLongTap() && hasLongTap());
        }
        function startMultiFingerRelease(event) {
            previousTouchEndTime = getTimeStamp();
            fingerCountAtRelease = event.touches.length + 1;
        }
        function cancelMultiFingerRelease() {
            previousTouchEndTime = 0;
            fingerCountAtRelease = 0;
        }
        function inMultiFingerRelease() {
            var withinThreshold = false;
            if (previousTouchEndTime) {
                var diff = getTimeStamp() - previousTouchEndTime
                if (diff <= options.fingerReleaseThreshold) {
                    withinThreshold = true;
                }
            }
            return withinThreshold;
        }
        function getTouchInProgress() {
            return !!($element.data(PLUGIN_NS + '_intouch') === true);
        }
        function setTouchInProgress(val) {
            if (!$element) {
                return;
            }
            if (val === true) {
                $element.bind(MOVE_EV, touchMove);
                $element.bind(END_EV, touchEnd);
                if (LEAVE_EV) {
                    $element.bind(LEAVE_EV, touchLeave);
                }
            } else {
                $element.unbind(MOVE_EV, touchMove, false);
                $element.unbind(END_EV, touchEnd, false);
                if (LEAVE_EV) {
                    $element.unbind(LEAVE_EV, touchLeave, false);
                }
            }
            $element.data(PLUGIN_NS + '_intouch', val === true);
        }
        function createFingerData(id, evt) {
            var f = {
                start: {
                    x: 0,
                    y: 0
                },
                last: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 0
                }
            };
            f.start.x = f.last.x = f.end.x = evt.pageX || evt.clientX;
            f.start.y = f.last.y = f.end.y = evt.pageY || evt.clientY;
            fingerData[id] = f;
            return f;
        }
        function updateFingerData(evt) {
            var id = evt.identifier !== undefined ? evt.identifier : 0;
            var f = getFingerData(id);
            if (f === null) {
                f = createFingerData(id, evt);
            }
            f.last.x = f.end.x;
            f.last.y = f.end.y;
            f.end.x = evt.pageX || evt.clientX;
            f.end.y = evt.pageY || evt.clientY;
            return f;
        }
        function getFingerData(id) {
            return fingerData[id] || null;
        }
        function setMaxDistance(direction, distance) {
            if (direction == NONE)
                return;
            distance = Math.max(distance, getMaxDistance(direction));
            maximumsMap[direction].distance = distance;
        }
        function getMaxDistance(direction) {
            if (maximumsMap[direction])
                return maximumsMap[direction].distance;
            return undefined;
        }
        function createMaximumsData() {
            var maxData = {};
            maxData[LEFT] = createMaximumVO(LEFT);
            maxData[RIGHT] = createMaximumVO(RIGHT);
            maxData[UP] = createMaximumVO(UP);
            maxData[DOWN] = createMaximumVO(DOWN);
            return maxData;
        }
        function createMaximumVO(dir) {
            return {
                direction: dir,
                distance: 0
            }
        }
        function calculateDuration() {
            return endTime - startTime;
        }
        function calculateTouchesDistance(startPoint, endPoint) {
            var diffX = Math.abs(startPoint.x - endPoint.x);
            var diffY = Math.abs(startPoint.y - endPoint.y);
            return Math.round(Math.sqrt(diffX * diffX + diffY * diffY));
        }
        function calculatePinchZoom(startDistance, endDistance) {
            var percent = (endDistance / startDistance) * 1;
            return percent.toFixed(2);
        }
        function calculatePinchDirection() {
            if (pinchZoom < 1) {
                return OUT;
            } else {
                return IN;
            }
        }
        function calculateDistance(startPoint, endPoint) {
            return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
        }
        function calculateAngle(startPoint, endPoint) {
            var x = startPoint.x - endPoint.x;
            var y = endPoint.y - startPoint.y;
            var r = Math.atan2(y, x);
            var angle = Math.round(r * 180 / Math.PI);
            if (angle < 0) {
                angle = 360 - Math.abs(angle);
            }
            return angle;
        }
        function calculateDirection(startPoint, endPoint) {
            if (comparePoints(startPoint, endPoint)) {
                return NONE;
            }
            var angle = calculateAngle(startPoint, endPoint);
            if ((angle <= 45) && (angle >= 0)) {
                return LEFT;
            } else if ((angle <= 360) && (angle >= 315)) {
                return LEFT;
            } else if ((angle >= 135) && (angle <= 225)) {
                return RIGHT;
            } else if ((angle > 45) && (angle < 135)) {
                return DOWN;
            } else {
                return UP;
            }
        }
        function getTimeStamp() {
            var now = new Date();
            return now.getTime();
        }
        function getbounds(el) {
            el = $(el);
            var offset = el.offset();
            var bounds = {
                left: offset.left,
                right: offset.left + el.outerWidth(),
                top: offset.top,
                bottom: offset.top + el.outerHeight()
            }
            return bounds;
        }
        function isInBounds(point, bounds) {
            return (point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom);
        }
        ; function comparePoints(pointA, pointB) {
            return (pointA.x == pointB.x && pointA.y == pointB.y);
        }
    }
}));
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory;
    } else {
        factory(jQuery);
    }
}(function ($) {
    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'], toBind = ('onwheel' in document || document.documentMode >= 9) ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'], slice = Array.prototype.slice, nullLowestDeltaTimeout, lowestDelta;
    if ($.event.fixHooks) {
        for (var i = toFix.length; i;) {
            $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
        }
    }
    var special = $.event.special.mousewheel = {
        version: '3.1.12',
        setup: function () {
            if (this.addEventListener) {
                for (var i = toBind.length; i;) {
                    this.addEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = handler;
            }
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },
        teardown: function () {
            if (this.removeEventListener) {
                for (var i = toBind.length; i;) {
                    this.removeEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = null;
            }
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },
        getLineHeight: function (elem) {
            var $elem = $(elem)
                , $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },
        getPageHeight: function (elem) {
            return $(elem).height();
        },
        settings: {
            adjustOldDeltas: true,
            normalizeOffset: true
        }
    };
    $.fn.extend({
        mousewheel: function (fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },
        unmousewheel: function (fn) {
            return this.unbind('mousewheel', fn);
        }
    });
    function handler(event) {
        var orgEvent = event || window.event
            , args = slice.call(arguments, 1)
            , delta = 0
            , deltaX = 0
            , deltaY = 0
            , absDelta = 0
            , offsetX = 0
            , offsetY = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';
        if ('detail' in orgEvent) {
            deltaY = orgEvent.detail * -1;
        }
        if ('wheelDelta' in orgEvent) {
            deltaY = orgEvent.wheelDelta;
        }
        if ('wheelDeltaY' in orgEvent) {
            deltaY = orgEvent.wheelDeltaY;
        }
        if ('wheelDeltaX' in orgEvent) {
            deltaX = orgEvent.wheelDeltaX * -1;
        }
        if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }
        delta = deltaY === 0 ? deltaX : deltaY;
        if ('deltaY' in orgEvent) {
            deltaY = orgEvent.deltaY * -1;
            delta = deltaY;
        }
        if ('deltaX' in orgEvent) {
            deltaX = orgEvent.deltaX;
            if (deltaY === 0) {
                delta = deltaX * -1;
            }
        }
        if (deltaY === 0 && deltaX === 0) {
            return;
        }
        if (orgEvent.deltaMode === 1) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if (orgEvent.deltaMode === 2) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }
        absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
        if (!lowestDelta || absDelta < lowestDelta) {
            lowestDelta = absDelta;
            if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
                lowestDelta /= 40;
            }
        }
        if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
            delta /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }
        delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
        deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
        deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);
        if (special.settings.normalizeOffset && this.getBoundingClientRect) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        event.deltaMode = 0;
        args.unshift(event, delta, deltaX, deltaY);
        if (nullLowestDeltaTimeout) {
            clearTimeout(nullLowestDeltaTimeout);
        }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
        return ($.event.dispatch || $.event.handle).apply(this, args);
    }
    function nullLowestDelta() {
        lowestDelta = null;
    }
    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }
}));
(function ($) {
    $.fn.fullpage = function (options) {
        defaults = {
            scrollingSpeed: 700,
            scrollingDelay: 700,
            activeDelay: 950,
            onLeave: null,
            afterLoad: null
        };
        var $this = $(this)
            , $children = $this.children('.section')
            , $childrenCount = $children.length
            , windowH = $(window).height()
            , running = false
            , animTimeout = null;
        options = $.extend({}, defaults, options);
        $('.sections-nav').empty();
        for (var i = 0; i < $childrenCount; i++) {
            $('.sections-nav').append('<li><a href="#"></a></li>');
            if (i == 0)
                $('.sections-nav li').eq(i).children('a').addClass('active');
        }
        ; var init = function () {
            $this.css({
                '-webkit-transition': '-webkit-transform ' + options.scrollingSpeed + 'ms ' + options.scrollingDelay + 'ms ease',
                '-moz-transition': '-moz-transform ' + options.scrollingSpeed + 'ms ' + options.scrollingDelay + 'ms ease',
                'transition': 'transform ' + options.scrollingSpeed + 'ms ' + options.scrollingDelay + 'ms ease',
                'backfaceVisibility': 'hidden'
            });
            $children.css('height', windowH);
            $this.mousewheel(function (event) {
                var curr = $this.children('.active').index();
                if (event.deltaY <= 0) {
                    if (curr < $childrenCount - 1) {
                        move(curr, curr + 1, 'down');
                    }
                } else {
                    if (curr > 0) {
                        move(curr, curr - 1, 'up');
                    }
                }
            });
            if (!$('html').hasClass('mobile')) {
                $this.swipe({
                    swipe: function (event, direction, distance, duration, fingerCount, fingerData) {
                        var curr = $this.children('.active').index();
                        if (direction == 'up') {
                            if (curr < $childrenCount - 1) {
                                move(curr, curr + 1, 'down');
                            }
                        } else if (direction == 'down') {
                            if (curr > 0) {
                                move(curr, curr - 1, 'up');
                            }
                        }
                    }
                });
            } else if ($('body').hasClass('home')) {
                $this.swipe({
                    swipe: function (event, direction, distance, duration, fingerCount, fingerData) {
                        var curr = $this.children('.active').index();
                        if (direction == 'up') {
                            if (curr < $childrenCount - 1) {
                                move(curr, curr + 1, 'down');
                            }
                        } else if (direction == 'down') {
                            if (curr > 0) {
                                move(curr, curr - 1, 'up');
                            }
                        }
                    }
                });
            }
            $('.discover-btn').click(function (e) {
                e.preventDefault();
                var curr = $this.children('.active').index();
                move(curr, curr + 1, 'down');
            });
            $('.sections-nav li a').click(function (e) {
                e.preventDefault();
                if (!$(this).hasClass('active')) {
                    var index = $('.sections-nav li a.active').parent().index()
                        , nextIndex = $(this).parent().index()
                        , direction = index > nextIndex ? 'up' : 'down';
                    move(index, nextIndex, direction);
                    $('.sections-nav li a.active').removeClass('active');
                    $(this).addClass('active');
                }
                ;
            });
            $(document).keydown(function (e) {
                var index = $this.children('.active').index();
                switch (e.which) {
                    case 38:
                        if (index > 0) {
                            move(index, index - 1, 'up');
                        }
                        ; break;
                    case 40:
                    case 32:
                        if (index < $childrenCount - 1) {
                            move(index, index + 1, 'down');
                        }
                        break;
                    default:
                        return;
                }
                e.preventDefault();
            });
            function move(index, nextIndex, direction) {
                if (!running && !$('.history-swap-box-in').length && !$('section.active').hasClass('clicked')) {
                    running = true;
                    options.onLeave(index + 1, nextIndex + 1, direction);
                    var currBgColor = $('.sections-holder section').eq(nextIndex).data('bg-color');
                    $('body, footer .bottom').css('background-color', currBgColor);
                    if ($('header').hasClass('opened'))
                        $('.nav-trigger').trigger('click');
                    $('.sections-holder section').eq(nextIndex).data('color-scheme') == 'light' ? $('header, .sections-nav').removeClass('light') : $('header, .sections-nav').addClass('light');
                    $('.sections-nav li a.active').removeClass('active');
                    $('.sections-nav li').eq(nextIndex).children('a').addClass('active')
                    $this.children('.active').removeClass('active');
                    $children.eq(nextIndex).addClass('active');
                    if (nextIndex == $childrenCount - 1) {
                        var offset = -nextIndex * windowH + windowH - $children.eq(nextIndex).outerHeight(true);
                        $this.css({
                            '-webkit-transform': 'translate3d(0px, ' + offset + 'px, 0px)',
                            '-moz-transform': 'translate3d(0px, ' + offset + 'px, 0px)',
                            'transform': 'translate3d(0px, ' + offset + 'px, 0px)'
                        })
                    } else {
                        $this.css({
                            '-webkit-transform': 'translate3d(0px, ' + -nextIndex * windowH + 'px, 0px)',
                            '-moz-transform': 'translate3d(0px, ' + -nextIndex * windowH + 'px, 0px)',
                            'transform': 'translate3d(0px, ' + -nextIndex * windowH + 'px, 0px)'
                        })
                    }
                    animTimeout = setTimeout(function () {
                        options.afterLoad(nextIndex + 1);
                        running = false;
                        clearTimeout(animTimeout);
                        animTimeout = null;
                    }, options.scrollingSpeed + options.activeDelay)
                }
            }
        };
        init();
        $(window).resize(function () {
            windowH = $(window).height();
            $children.css('height', windowH);
            var nextIndex = $('.sections-nav li a.active').parent().index();
            if (nextIndex == $childrenCount - 1) {
                var offset = -nextIndex * windowH + windowH - $children.eq(nextIndex).outerHeight(true);
                $this.css({
                    '-webkit-transform': 'translate3d(0px, ' + offset + 'px, 0px)',
                    '-moz-transform': 'translate3d(0px, ' + offset + 'px, 0px)',
                    'transform': 'translate3d(0px, ' + offset + 'px, 0px)'
                })
            } else {
                $this.css({
                    '-webkit-transform': 'translate3d(0px, ' + -nextIndex * windowH + 'px, 0px)',
                    '-moz-transform': 'translate3d(0px, ' + -nextIndex * windowH + 'px, 0px)',
                    'transform': 'translate3d(0px, ' + -nextIndex * windowH + 'px, 0px)'
                })
            }
        });
    }
        ;
}
)(jQuery);
; (function ($, window, document, undefined) {
    'use strict';
    var NAME = 'parallax';
    var MAGIC_NUMBER = 30;
    var DEFAULTS = {
        relativeInput: false,
        clipRelativeInput: false,
        calibrationThreshold: 100,
        calibrationDelay: 500,
        supportDelay: 1000,
        calibrateX: false,
        calibrateY: true,
        invertX: true,
        invertY: true,
        limitX: false,
        limitY: false,
        scalarX: 20.0,
        scalarY: 15.0,
        frictionX: 0.1,
        frictionY: 0.1,
        originX: 0.5,
        originY: 0.5
    };
    function Plugin(element, options) {
        this.element = element;
        this.$context = $(element).data('api', this);
        this.$layers = this.$context.find('.layer');
        var data = {
            calibrateX: this.$context.data('calibrate-x') || null,
            calibrateY: this.$context.data('calibrate-y') || null,
            invertX: this.$context.data('invert-x') || null,
            invertY: this.$context.data('invert-y') || null,
            limitX: parseFloat(this.$context.data('limit-x')) || null,
            limitY: parseFloat(this.$context.data('limit-y')) || null,
            scalarX: parseFloat(this.$context.data('scalar-x')) || null,
            scalarY: parseFloat(this.$context.data('scalar-y')) || null,
            frictionX: parseFloat(this.$context.data('friction-x')) || null,
            frictionY: parseFloat(this.$context.data('friction-y')) || null,
            originX: parseFloat(this.$context.data('origin-x')) || null,
            originY: parseFloat(this.$context.data('origin-y')) || null
        };
        for (var key in data) {
            if (data[key] === null)
                delete data[key];
        }
        $.extend(this, DEFAULTS, options, data);
        this.calibrationTimer = null;
        this.calibrationFlag = true;
        this.enabled = false;
        this.depths = [];
        this.raf = null;
        this.bounds = null;
        this.ex = 0;
        this.ey = 0;
        this.ew = 0;
        this.eh = 0;
        this.ecx = 0;
        this.ecy = 0;
        this.erx = 0;
        this.ery = 0;
        this.cx = 0;
        this.cy = 0;
        this.ix = 0;
        this.iy = 0;
        this.mx = 0;
        this.my = 0;
        this.vx = 0;
        this.vy = 0;
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onDeviceOrientation = this.onDeviceOrientation.bind(this);
        this.onOrientationTimer = this.onOrientationTimer.bind(this);
        this.onCalibrationTimer = this.onCalibrationTimer.bind(this);
        this.onAnimationFrame = this.onAnimationFrame.bind(this);
        this.onWindowResize = this.onWindowResize.bind(this);
        this.initialise();
    }
    Plugin.prototype.transformSupport = function (value) {
        var element = document.createElement('div');
        var propertySupport = false;
        var propertyValue = null;
        var featureSupport = false;
        var cssProperty = null;
        var jsProperty = null;
        for (var i = 0, l = this.vendors.length; i < l; i++) {
            if (this.vendors[i] !== null) {
                cssProperty = this.vendors[i][0] + 'transform';
                jsProperty = this.vendors[i][1] + 'Transform';
            } else {
                cssProperty = 'transform';
                jsProperty = 'transform';
            }
            if (element.style[jsProperty] !== undefined) {
                propertySupport = true;
                break;
            }
        }
        switch (value) {
            case '2D':
                featureSupport = propertySupport;
                break;
            case '3D':
                if (propertySupport) {
                    var body = document.body || document.createElement('body');
                    var documentElement = document.documentElement;
                    var documentOverflow = documentElement.style.overflow;
                    if (!document.body) {
                        documentElement.style.overflow = 'hidden';
                        documentElement.appendChild(body);
                        body.style.overflow = 'hidden';
                        body.style.background = '';
                    }
                    body.appendChild(element);
                    element.style[jsProperty] = 'translate3d(1px,1px,1px)';
                    propertyValue = window.getComputedStyle(element).getPropertyValue(cssProperty);
                    featureSupport = propertyValue !== undefined && propertyValue.length > 0 && propertyValue !== "none";
                    documentElement.style.overflow = documentOverflow;
                    body.removeChild(element);
                }
                break;
        }
        return featureSupport;
    }
        ;
    Plugin.prototype.ww = null;
    Plugin.prototype.wh = null;
    Plugin.prototype.wcx = null;
    Plugin.prototype.wcy = null;
    Plugin.prototype.wrx = null;
    Plugin.prototype.wry = null;
    Plugin.prototype.portrait = null;
    Plugin.prototype.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
    Plugin.prototype.vendors = [null, ['-webkit-', 'webkit'], ['-moz-', 'Moz'], ['-o-', 'O'], ['-ms-', 'ms']];
    Plugin.prototype.motionSupport = !!window.DeviceMotionEvent;
    Plugin.prototype.orientationSupport = !window.DeviceOrientationEvent;
    Plugin.prototype.orientationStatus = 0;
    Plugin.prototype.transform2DSupport = Plugin.prototype.transformSupport('2D');
    Plugin.prototype.transform3DSupport = Plugin.prototype.transformSupport('3D');
    Plugin.prototype.propertyCache = {};
    Plugin.prototype.initialise = function () {
        if (this.$context.css('position') === 'static') {
            this.$context.css({
                position: 'relative'
            });
        }
        this.accelerate(this.$context);
        this.updateLayers();
        this.updateDimensions();
        this.enable();
        this.queueCalibration(this.calibrationDelay);
    }
        ;
    Plugin.prototype.updateLayers = function () {
        this.$layers = this.$context.find('.layer');
        this.depths = [];
        this.$layers.css({
            position: 'absolute',
            display: 'block',
            left: 0,
            top: 0
        });
        this.$layers.first().css({
            position: 'relative'
        });
        this.accelerate(this.$layers);
        this.$layers.each($.proxy(function (index, element) {
            this.depths.push($(element).data('depth') || 0);
        }, this));
    }
        ;
    Plugin.prototype.updateDimensions = function () {
        this.ww = window.innerWidth;
        this.wh = window.innerHeight;
        this.wcx = this.ww * this.originX;
        this.wcy = this.wh * this.originY;
        this.wrx = Math.max(this.wcx, this.ww - this.wcx);
        this.wry = Math.max(this.wcy, this.wh - this.wcy);
    }
        ;
    Plugin.prototype.updateBounds = function () {
        this.bounds = this.element.getBoundingClientRect();
        this.ex = this.bounds.left;
        this.ey = this.bounds.top;
        this.ew = this.bounds.width;
        this.eh = this.bounds.height;
        this.ecx = this.ew * this.originX;
        this.ecy = this.eh * this.originY;
        this.erx = Math.max(this.ecx, this.ew - this.ecx);
        this.ery = Math.max(this.ecy, this.eh - this.ecy);
    }
        ;
    Plugin.prototype.queueCalibration = function (delay) {
        clearTimeout(this.calibrationTimer);
        this.calibrationTimer = setTimeout(this.onCalibrationTimer, delay);
    }
        ;
    Plugin.prototype.enable = function () {
        if (!this.enabled) {
            this.enabled = true;
            if ($('html').hasClass('tablet') || $('html').hasClass('mobile')) {
                this.portrait = null;
                this.$context.attr('data-mode', 'orientation');
                window.addEventListener('deviceorientation', this.onDeviceOrientation);
                setTimeout(this.onOrientationTimer, this.supportDelay);
            } else {
                this.cx = 0;
                this.cy = 0;
                this.portrait = false;
                this.$context.attr('data-mode', 'cursor');
                window.addEventListener('mousemove', this.onMouseMove);
            }
            window.addEventListener('resize', this.onWindowResize);
            this.raf = requestAnimationFrame(this.onAnimationFrame);
        }
    }
        ;
    Plugin.prototype.disable = function () {
        if (this.enabled) {
            this.enabled = false;
            if (this.orientationSupport) {
                window.removeEventListener('deviceorientation', this.onDeviceOrientation);
            } else {
                window.removeEventListener('mousemove', this.onMouseMove);
            }
            window.removeEventListener('resize', this.onWindowResize);
            cancelAnimationFrame(this.raf);
        }
    }
        ;
    Plugin.prototype.calibrate = function (x, y) {
        this.calibrateX = x === undefined ? this.calibrateX : x;
        this.calibrateY = y === undefined ? this.calibrateY : y;
    }
        ;
    Plugin.prototype.invert = function (x, y) {
        this.invertX = x === undefined ? this.invertX : x;
        this.invertY = y === undefined ? this.invertY : y;
    }
        ;
    Plugin.prototype.friction = function (x, y) {
        this.frictionX = x === undefined ? this.frictionX : x;
        this.frictionY = y === undefined ? this.frictionY : y;
    }
        ;
    Plugin.prototype.scalar = function (x, y) {
        this.scalarX = x === undefined ? this.scalarX : x;
        this.scalarY = y === undefined ? this.scalarY : y;
    }
        ;
    Plugin.prototype.limit = function (x, y) {
        this.limitX = x === undefined ? this.limitX : x;
        this.limitY = y === undefined ? this.limitY : y;
    }
        ;
    Plugin.prototype.origin = function (x, y) {
        this.originX = x === undefined ? this.originX : x;
        this.originY = y === undefined ? this.originY : y;
    }
        ;
    Plugin.prototype.clamp = function (value, min, max) {
        value = Math.max(value, min);
        value = Math.min(value, max);
        return value;
    }
        ;
    Plugin.prototype.css = function (element, property, value) {
        var jsProperty = this.propertyCache[property];
        if (!jsProperty) {
            for (var i = 0, l = this.vendors.length; i < l; i++) {
                if (this.vendors[i] !== null) {
                    jsProperty = $.camelCase(this.vendors[i][1] + '-' + property);
                } else {
                    jsProperty = property;
                }
                if (element.style[jsProperty] !== undefined) {
                    this.propertyCache[property] = jsProperty;
                    break;
                }
            }
        }
        element.style[jsProperty] = value;
    }
        ;
    Plugin.prototype.accelerate = function ($element) {
        for (var i = 0, l = $element.length; i < l; i++) {
            var element = $element[i];
            this.css(element, 'transform-style', 'preserve-3d');
            this.css(element, 'backface-visibility', 'hidden');
        }
    }
        ;
    Plugin.prototype.setPosition = function (element, x, y) {
        x += 'px';
        y += 'px';
        if (this.transform3DSupport) {
            this.css(element, 'transform', 'translate3d(' + x + ',' + y + ',0)');
        } else if (this.transform2DSupport) {
            this.css(element, 'transform', 'translate(' + x + ',' + y + ')');
        } else {
            element.style.left = x;
            element.style.top = y;
        }
    }
        ;
    Plugin.prototype.onOrientationTimer = function (event) {
        if (this.orientationSupport && this.orientationStatus === 0) {
            this.disable();
            this.orientationSupport = false;
            this.enable();
        }
    }
        ;
    Plugin.prototype.onCalibrationTimer = function (event) {
        this.calibrationFlag = true;
    }
        ;
    Plugin.prototype.onWindowResize = function (event) {
        this.updateDimensions();
    }
        ;
    Plugin.prototype.onAnimationFrame = function () {
        this.updateBounds();
        var dx = this.ix - this.cx;
        var dy = this.iy - this.cy;
        if ((Math.abs(dx) > this.calibrationThreshold) || (Math.abs(dy) > this.calibrationThreshold)) {
            this.queueCalibration(0);
        }
        if (this.portrait) {
            this.mx = this.calibrateX ? dy : this.iy;
            this.my = this.calibrateY ? dx : this.ix;
        } else {
            this.mx = this.calibrateX ? dx : this.ix;
            this.my = this.calibrateY ? dy : this.iy;
        }
        this.mx *= this.ew * (this.scalarX / 100);
        this.my *= this.eh * (this.scalarY / 100);
        if (!isNaN(parseFloat(this.limitX))) {
            this.mx = this.clamp(this.mx, -this.limitX, this.limitX);
        }
        if (!isNaN(parseFloat(this.limitY))) {
            this.my = this.clamp(this.my, -this.limitY, this.limitY);
        }
        this.vx += (this.mx - this.vx) * this.frictionX;
        this.vy += (this.my - this.vy) * this.frictionY;
        for (var i = 0, l = this.$layers.length; i < l; i++) {
            var depth = this.depths[i];
            var layer = this.$layers[i];
            var xOffset = this.vx * depth * (this.invertX ? -1 : 1);
            var yOffset = this.vy * depth * (this.invertY ? -1 : 1);
            this.setPosition(layer, xOffset, yOffset);
        }
        this.raf = requestAnimationFrame(this.onAnimationFrame);
    }
        ;
    Plugin.prototype.onDeviceOrientation = function (event) {
        if (!this.desktop && event.beta !== null && event.gamma !== null) {
            this.orientationStatus = 1;
            var x = (event.beta || 0) / 15;
            var y = (event.gamma || 0) / 15;
            var portrait = window.innerHeight > window.innerWidth;
            if (this.portrait !== portrait) {
                this.portrait = portrait;
                this.calibrationFlag = true;
            }
            if (this.calibrationFlag) {
                this.calibrationFlag = false;
                this.cx = x;
                this.cy = y;
            }
            this.ix = x;
            this.iy = y;
        }
    }
        ;
    Plugin.prototype.onMouseMove = function (event) {
        var clientX = event.clientX;
        var clientY = event.clientY;
        if (!this.orientationSupport && this.relativeInput) {
            if (this.clipRelativeInput) {
                clientX = Math.max(clientX, this.ex);
                clientX = Math.min(clientX, this.ex + this.ew);
                clientY = Math.max(clientY, this.ey);
                clientY = Math.min(clientY, this.ey + this.eh);
            }
            this.ix = (clientX - this.ex - this.ecx) / this.erx;
            this.iy = (clientY - this.ey - this.ecy) / this.ery;
        } else {
            this.ix = (clientX - this.wcx) / this.wrx;
            this.iy = (clientY - this.wcy) / this.wry;
        }
    }
        ;
    var API = {
        enable: Plugin.prototype.enable,
        disable: Plugin.prototype.disable,
        updateLayers: Plugin.prototype.updateLayers,
        calibrate: Plugin.prototype.calibrate,
        friction: Plugin.prototype.friction,
        invert: Plugin.prototype.invert,
        scalar: Plugin.prototype.scalar,
        limit: Plugin.prototype.limit,
        origin: Plugin.prototype.origin
    };
    $.fn[NAME] = function (value) {
        var args = arguments;
        return this.each(function () {
            var $this = $(this);
            var plugin = $this.data(NAME);
            if (!plugin) {
                plugin = new Plugin(this, value);
                $this.data(NAME, plugin);
            }
            if (API[value]) {
                plugin[value].apply(plugin, Array.prototype.slice.call(args, 1));
            }
        });
    }
        ;
}
)(window.jQuery || window.Zepto, window, document);
; (function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        }
            ;
    }
    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        }
            ;
    }
}());
var VirtualScroll = (function (document) {
    var vs = {};
    var numListeners, listeners = [], initialized = false;
    var touchStartX, touchStartY;
    var touchMult = 2;
    var firefoxMult = 15;
    var keyStep = 120;
    var mouseMult = 1;
    var bodyTouchAction;
    var hasWheelEvent = 'onwheel' in document;
    var hasMouseWheelEvent = 'onmousewheel' in document;
    var hasTouch = 'ontouchstart' in document;
    var hasTouchWin = navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1;
    var hasPointer = !!window.navigator.msPointerEnabled;
    var hasKeyDown = 'onkeydown' in document;
    var isFirefox = navigator.userAgent.indexOf('Firefox') > -1;
    var event = {
        y: 0,
        x: 0,
        deltaX: 0,
        deltaY: 0,
        originalEvent: null
    };
    vs.on = function (f) {
        if (!initialized)
            initListeners();
        listeners.push(f);
        numListeners = listeners.length;
    }
    vs.options = function (opt) {
        keyStep = opt.keyStep || 120;
        firefoxMult = opt.firefoxMult || 15;
        touchMult = opt.touchMult || 2;
        mouseMult = opt.mouseMult || 1;
    }
    vs.off = function (f) {
        listeners.splice(f, 1);
        numListeners = listeners.length;
        if (numListeners <= 0)
            destroyListeners();
    }
    var notify = function (e) {
        event.x += event.deltaX;
        event.y += event.deltaY;
        event.originalEvent = e;
        for (var i = 0; i < numListeners; i++) {
            listeners[i](event);
        }
    }
    var onWheel = function (e) {
        event.deltaX = e.wheelDeltaX || e.deltaX * -1;
        event.deltaY = e.wheelDeltaY || e.deltaY * -1;
        if (isFirefox && e.deltaMode == 1) {
            event.deltaX *= firefoxMult;
            event.deltaY *= firefoxMult;
        }
        event.deltaX *= mouseMult;
        event.deltaY *= mouseMult;
        notify(e);
    }
    var onMouseWheel = function (e) {
        event.deltaX = (e.wheelDeltaX) ? e.wheelDeltaX : 0;
        event.deltaY = (e.wheelDeltaY) ? e.wheelDeltaY : e.wheelDelta;
        notify(e);
    }
    var onTouchStart = function (e) {
        var t = (e.targetTouches) ? e.targetTouches[0] : e;
        touchStartX = t.pageX;
        touchStartY = t.pageY;
    }
    var onTouchMove = function (e) {
        var t = (e.targetTouches) ? e.targetTouches[0] : e;
        event.deltaX = (t.pageX - touchStartX) * touchMult;
        event.deltaY = (t.pageY - touchStartY) * touchMult;
        touchStartX = t.pageX;
        touchStartY = t.pageY;
        notify(e);
    }
    var onKeyDown = function (e) {
        event.deltaX = event.deltaY = 0;
        switch (e.keyCode) {
            case 37:
                event.deltaX = -keyStep;
                break;
            case 39:
                event.deltaX = keyStep;
                break;
            case 38:
                event.deltaY = keyStep;
                break;
            case 40:
                event.deltaY = -keyStep;
                break;
        }
        notify(e);
    }
    var initListeners = function () {
        if (hasWheelEvent)
            document.addEventListener("wheel", onWheel);
        if (hasMouseWheelEvent)
            document.addEventListener("mousewheel", onMouseWheel);
        if (hasTouch) {
            document.addEventListener("touchstart", onTouchStart);
            document.addEventListener("touchmove", onTouchMove);
        }
        if (hasPointer && hasTouchWin) {
            bodyTouchAction = document.body.style.msTouchAction;
            document.body.style.msTouchAction = "none";
            document.addEventListener("MSPointerDown", onTouchStart, true);
            document.addEventListener("MSPointerMove", onTouchMove, true);
        }
        if (hasKeyDown)
            document.addEventListener("keydown", onKeyDown);
        initialized = true;
    }
    var destroyListeners = function () {
        if (hasWheelEvent)
            document.removeEventListener("wheel", onWheel);
        if (hasMouseWheelEvent)
            document.removeEventListener("mousewheel", onMouseWheel);
        if (hasTouch) {
            document.removeEventListener("touchstart", onTouchStart);
            document.removeEventListener("touchmove", onTouchMove);
        }
        if (hasPointer && hasTouchWin) {
            document.body.style.msTouchAction = bodyTouchAction;
            document.removeEventListener("MSPointerDown", onTouchStart, true);
            document.removeEventListener("MSPointerMove", onTouchMove, true);
        }
        if (hasKeyDown)
            document.removeEventListener("keydown", onKeyDown);
        initialized = false;
    }
    return vs;
}
)(document);
(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a)
                    return a(o, !0);
                if (i)
                    return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND",
                f
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];
                return s(n ? n : e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)
        s(r[o]);
    return s
}
)({
    1: [function (require, module, exports) {
        'use strict';
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function (Constructor, protoProps, staticProps) {
                if (protoProps)
                    defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                    defineProperties(Constructor, staticProps);
                return Constructor;
            }
                ;
        }();
        var _domClasses = require('dom-classes');
        var _domClasses2 = _interopRequireDefault(_domClasses);
        var _domCreateElement = require('dom-create-element');
        var _domCreateElement2 = _interopRequireDefault(_domCreateElement);
        var _domCss = require('dom-css');
        var _domCss2 = _interopRequireDefault(_domCss);
        var _prefix = require('prefix');
        var _prefix2 = _interopRequireDefault(_prefix);
        var _virtualScroll = require('virtual-scroll');
        var _virtualScroll2 = _interopRequireDefault(_virtualScroll);
        var _domEvent = require('dom-event');
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }
        var Smooth = function () {
            function Smooth() {
                var opt = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                _classCallCheck(this, Smooth);
                this.createBound();
                this.prefix = (0,
                    _prefix2.default)('transform');
                this.extends = opt.extends || false;
                this.vars = {
                    direction: opt.direction || 'vertical',
                    native: opt.native || false,
                    ease: opt.ease || 0.075,
                    preload: opt.preload || false,
                    current: 0,
                    target: 0,
                    height: 0,
                    bounding: 0,
                    timer: null,
                    ticking: false
                };
                this.vs = this.vars.native ? null : new _virtualScroll2.default({
                    limitInertia: opt.vs && opt.vs.limitInertia || false,
                    mouseMultiplier: opt.vs && opt.vs.mouseMultiplier || 1,
                    touchMultiplier: opt.vs && opt.vs.touchMultiplier || 1.5,
                    firefoxMultiplier: opt.vs && opt.vs.firefoxMultiplier || 100,
                    preventTouch: opt.vs && opt.vs.preventTouch || true
                });
                this.dom = {
                    listener: opt.listener || document.body,
                    section: opt.section || document.querySelector('.vs-section') || null,
                    scrollbar: this.vars.native ? null : {
                        state: {
                            clicked: false,
                            x: 0
                        },
                        el: (0,
                            _domCreateElement2.default)({
                                selector: 'div',
                                styles: 'vs-scrollbar vs-' + this.vars.direction
                            }),
                        drag: {
                            el: (0,
                                _domCreateElement2.default)({
                                    selector: 'div',
                                    styles: 'vs-scrolldrag'
                                }),
                            delta: 0,
                            height: 50
                        }
                    }
                };
            }
            _createClass(Smooth, [{
                key: 'createBound',
                value: function createBound() {
                    var _this = this;
                    ['run', 'calc', 'debounce', 'resize', 'mouseUp', 'mouseDown', 'mouseMove', 'calcScroll', 'scrollTo'].forEach(function (fn) {
                        return _this[fn] = _this[fn].bind(_this);
                    });
                }
            }, {
                key: 'init',
                value: function init() {
                    this.vars.preload && this.preloadImages();
                    this.vars.native && this.addFakeScrollHeight();
                    this.addEvents();
                    !this.vars.preload && this.resize();
                    !this.vars.native && this.addFakeScrollBar();
                }
            }, {
                key: 'preloadImages',
                value: function preloadImages() {
                    var _this2 = this;
                    var images = Array.prototype.slice.call(this.dom.listener.querySelectorAll('img'), 0);
                    images.forEach(function (image) {
                        var img = new Image();
                        img.onload = function (el) {
                            images.splice(images.indexOf(image), 1);
                            images.length === 0 && _this2.resize();
                        }
                            ;
                        img.src = image.getAttribute('src');
                    });
                }
            }, {
                key: 'calc',
                value: function calc(e) {
                    var delta = this.direction == 'horizontal' ? e.deltaX : e.deltaY;
                    this.vars.target += delta * -1;
                    this.vars.target = Math.max(0, Math.min(this.vars.target, this.vars.bounding));
                }
            }, {
                key: 'debounce',
                value: function debounce() {
                    this.vars.target = this.vars.direction === 'vertical' ? window.scrollY || window.pageYOffset : window.scrollX || window.pageXOffset;
                    this.addScrollingClass();
                }
            }, {
                key: 'addScrollingClass',
                value: function addScrollingClass() {
                    var _this3 = this;
                    clearTimeout(this.vars.timer);
                    if (!this.vars.ticking) {
                        this.vars.ticking = true;
                        _domClasses2.default.add(this.dom.listener, 'is-scrolling');
                    }
                    this.vars.timer = setTimeout(function () {
                        _this3.vars.ticking = false;
                        _domClasses2.default.remove(_this3.dom.listener, 'is-scrolling');
                    }, 200);
                }
            }, {
                key: 'run',
                value: function run() {
                    this.vars.current += (this.vars.target - this.vars.current) * this.vars.ease;
                    this.vars.current < .1 && (this.vars.current = 0);
                    !this.extends && (this.dom.section.style[this.prefix] = this.getTransform(-this.vars.current.toFixed(2)));
                    !this.vars.native && this.transformScrollbar();
                    this.rAF = requestAnimationFrame(this.run);
                }
            }, {
                key: 'transformScrollbar',
                value: function transformScrollbar() {
                    var size = this.dom.scrollbar.drag.height;
                    var bounds = this.vars.direction === 'vertical' ? this.vars.height : this.vars.width;
                    var value = Math.abs(this.vars.current) / (this.vars.bounding / (bounds - size)) + size / .5 - size;
                    var clamp = Math.max(0, Math.min(value - size, value + size));
                    this.dom.scrollbar.drag.el.style[this.prefix] = this.getTransform(clamp.toFixed(2));
                }
            }, {
                key: 'getTransform',
                value: function getTransform(value) {
                    return this.direction === 'vertical' ? 'translate3d(0,' + value + 'px,0)' : 'translate3d(0,' + value + 'px,0)';
                }
            }, {
                key: 'on',
                value: function on() {
                    this.vars.native ? (0,
                        _domEvent.on)(window, 'scroll', this.debounce) : this.vs && this.vs.on(this.calc);
                }
            }, {
                key: 'off',
                value: function off() {
                    this.vars.native ? (0,
                        _domEvent.off)(window, 'scroll', this.debounce) : this.vs && (this.vs.off(this.calc),
                            this.vs.destroy(),
                            this.vs = null);
                }
            }, {
                key: 'addEvents',
                value: function addEvents() {
                    this.on();
                    (0,
                        _domEvent.on)(window, 'resize', this.resize);
                    this.rAF = requestAnimationFrame(this.run);
                }
            }, {
                key: 'removeEvents',
                value: function removeEvents() {
                    this.off();
                    (0,
                        _domEvent.off)(window, 'resize', this.resize);
                    cancelAnimationFrame(this.rAF);
                }
            }, {
                key: 'addFakeScrollBar',
                value: function addFakeScrollBar() {
                    this.dom.listener.appendChild(this.dom.scrollbar.el);
                    this.dom.scrollbar.el.appendChild(this.dom.scrollbar.drag.el);
                    (0,
                        _domEvent.on)(this.dom.scrollbar.el, 'click', this.calcScroll);
                    (0,
                        _domEvent.on)(this.dom.scrollbar.el, 'mousedown', this.mouseDown);
                    (0,
                        _domEvent.on)(document, 'mousemove', this.mouseMove);
                    (0,
                        _domEvent.on)(document, 'mouseup', this.mouseUp);
                }
            }, {
                key: 'removeFakeScrollBar',
                value: function removeFakeScrollBar() {
                    (0,
                        _domEvent.off)(this.dom.scrollbar.el, 'click', this.calcScroll);
                    (0,
                        _domEvent.off)(this.dom.scrollbar.el, 'mousedown', this.mouseDown);
                    (0,
                        _domEvent.off)(document, 'mousemove', this.mouseMove);
                    (0,
                        _domEvent.off)(document, 'mouseup', this.mouseUp);
                    this.dom.listener.removeChild(this.dom.scrollbar.el);
                }
            }, {
                key: 'mouseDown',
                value: function mouseDown(e) {
                    e.which == 1 && (this.dom.scrollbar.state.clicked = true);
                }
            }, {
                key: 'mouseUp',
                value: function mouseUp(e) {
                    this.dom.scrollbar.state.clicked = false;
                    _domClasses2.default.remove(this.dom.listener, 'is-dragging');
                }
            }, {
                key: 'mouseMove',
                value: function mouseMove(e) {
                    this.dom.scrollbar.state.clicked && this.calcScroll(e);
                }
            }, {
                key: 'addFakeScrollHeight',
                value: function addFakeScrollHeight() {
                    this.dom.scroll = (0,
                        _domCreateElement2.default)({
                            selector: 'div',
                            styles: 'vs-scroll-view'
                        });
                    this.dom.listener.appendChild(this.dom.scroll);
                }
            }, {
                key: 'removeFakeScrollHeight',
                value: function removeFakeScrollHeight() {
                    this.dom.listener.removeChild(this.dom.scroll);
                }
            }, {
                key: 'calcScroll',
                value: function calcScroll(e) {
                    var client = this.vars.direction == 'vertical' ? e.clientY : e.clientX;
                    var bounds = this.vars.direction == 'vertical' ? this.vars.height : this.vars.width;
                    var delta = client * (this.vars.bounding / bounds);
                    _domClasses2.default.add(this.dom.listener, 'is-dragging');
                    this.vars.target = delta;
                    this.vars.target = Math.max(0, Math.min(this.vars.target, this.vars.bounding));
                    this.dom.scrollbar && (this.dom.scrollbar.drag.delta = this.vars.target);
                }
            }, {
                key: 'scrollTo',
                value: function scrollTo(offset) {
                    if (this.vars.native) {
                        this.vars.direction == 'vertical' ? window.scrollTo(0, offset) : window.scrollTo(offset, 0);
                    } else {
                        this.vars.target = offset;
                    }
                }
            }, {
                key: 'resize',
                value: function resize() {
                    var prop = this.vars.direction === 'vertical' ? 'height' : 'width';
                    if ($('body').hasClass('single')) {
                        this.vars.height = document.documentElement.clientHeight || window.innerHeight;
                    } else {
                        var currPadding = parseInt($('.work-holder').css('padding-top'));
                        this.vars.height = document.documentElement.clientHeight - currPadding || window.innerHeight - currPadding;
                    }
                    this.vars.width = document.documentElement.clientWidth || window.innerWidth;
                    if (!this.extends) {
                        var bounding = this.dom.section.getBoundingClientRect();
                        this.vars.bounding = this.vars.direction === 'vertical' ? bounding.height - (this.vars.native ? 0 : this.vars.height) : bounding.right - (this.vars.native ? 0 : this.vars.width);
                    }
                    if (!this.vars.native) {
                        this.dom.scrollbar.drag.height = this.vars.height * (this.vars.height / (this.vars.bounding + this.vars.height));
                        (0,
                            _domCss2.default)(this.dom.scrollbar.drag.el, prop, this.dom.scrollbar.drag.height);
                    } else {
                        (0,
                            _domCss2.default)(this.dom.scroll, prop, this.vars.bounding);
                    }
                }
            }, {
                key: 'destroy',
                value: function destroy() {
                    this.vars.native ? this.removeFakeScrollHeight() : this.removeFakeScrollBar();
                    this.removeEvents();
                }
            }]);
            return Smooth;
        }();
        window.Smooth = Smooth;
        exports.default = Smooth;
    }
        , {
        "dom-classes": 9,
        "dom-create-element": 10,
        "dom-css": 11,
        "dom-event": 12,
        "prefix": 17,
        "virtual-scroll": 23
    }],
    2: [function (require, module, exports) {
        var IS_UNITLESS = {
            animationIterationCount: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridRow: true,
            gridColumn: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            stopOpacity: true,
            strokeDashoffset: true,
            strokeOpacity: true,
            strokeWidth: true
        };
        module.exports = function (name, value) {
            if (typeof value === 'number' && !IS_UNITLESS[name]) {
                return value + 'px';
            } else {
                return value;
            }
        }
            ;
    }
        , {}],
    3: [function (require, module, exports) {
        'use strict'
        exports.toByteArray = toByteArray
        exports.fromByteArray = fromByteArray
        var lookup = []
        var revLookup = []
        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
        function init() {
            var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
            for (var i = 0, len = code.length; i < len; ++i) {
                lookup[i] = code[i]
                revLookup[code.charCodeAt(i)] = i
            }
            revLookup['-'.charCodeAt(0)] = 62
            revLookup['_'.charCodeAt(0)] = 63
        }
        init()
        function toByteArray(b64) {
            var i, j, l, tmp, placeHolders, arr
            var len = b64.length
            if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
            }
            placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
            arr = new Arr(len * 3 / 4 - placeHolders)
            l = placeHolders > 0 ? len - 4 : len
            var L = 0
            for (i = 0,
                j = 0; i < l; i += 4,
                j += 3) {
                tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
                arr[L++] = (tmp >> 16) & 0xFF
                arr[L++] = (tmp >> 8) & 0xFF
                arr[L++] = tmp & 0xFF
            }
            if (placeHolders === 2) {
                tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
                arr[L++] = tmp & 0xFF
            } else if (placeHolders === 1) {
                tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
                arr[L++] = (tmp >> 8) & 0xFF
                arr[L++] = tmp & 0xFF
            }
            return arr
        }
        function tripletToBase64(num) {
            return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
        }
        function encodeChunk(uint8, start, end) {
            var tmp
            var output = []
            for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                output.push(tripletToBase64(tmp))
            }
            return output.join('')
        }
        function fromByteArray(uint8) {
            var tmp
            var len = uint8.length
            var extraBytes = len % 3
            var output = ''
            var parts = []
            var maxChunkLength = 16383
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
            }
            if (extraBytes === 1) {
                tmp = uint8[len - 1]
                output += lookup[tmp >> 2]
                output += lookup[(tmp << 4) & 0x3F]
                output += '=='
            } else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
                output += lookup[tmp >> 10]
                output += lookup[(tmp >> 4) & 0x3F]
                output += lookup[(tmp << 2) & 0x3F]
                output += '='
            }
            parts.push(output)
            return parts.join('')
        }
    }
        , {}],
    4: [function (require, module, exports) {
        'use strict';
        var toString = Object.prototype.toString
            , hasOwnProperty = Object.prototype.hasOwnProperty;
        module.exports = function (object) {
            if (!object)
                return console.warn('bindAll requires at least one argument.');
            var functions = Array.prototype.slice.call(arguments, 1);
            if (functions.length === 0) {
                for (var method in object) {
                    if (hasOwnProperty.call(object, method)) {
                        if (typeof object[method] == 'function' && toString.call(object[method]) == "[object Function]") {
                            functions.push(method);
                        }
                    }
                }
            }
            for (var i = 0; i < functions.length; i++) {
                var f = functions[i];
                object[f] = bind(object[f], object);
            }
        }
            ;
        function bind(func, context) {
            return function () {
                return func.apply(context, arguments);
            }
                ;
        }
    }
        , {}],
    5: [function (require, module, exports) {
        (function (global) {
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
            'use strict'
            var base64 = require('base64-js')
            var ieee754 = require('ieee754')
            var isArray = require('isarray')
            exports.Buffer = Buffer
            exports.SlowBuffer = SlowBuffer
            exports.INSPECT_MAX_BYTES = 50
            Buffer.poolSize = 8192
            var rootParent = {}
            Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport()
            function typedArraySupport() {
                try {
                    var arr = new Uint8Array(1)
                    arr.foo = function () {
                        return 42
                    }
                    return arr.foo() === 42 && typeof arr.subarray === 'function' && arr.subarray(1, 1).byteLength === 0
                } catch (e) {
                    return false
                }
            }
            function kMaxLength() {
                return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff
            }
            function Buffer(arg) {
                if (!(this instanceof Buffer)) {
                    if (arguments.length > 1)
                        return new Buffer(arg, arguments[1])
                    return new Buffer(arg)
                }
                if (!Buffer.TYPED_ARRAY_SUPPORT) {
                    this.length = 0
                    this.parent = undefined
                }
                if (typeof arg === 'number') {
                    return fromNumber(this, arg)
                }
                if (typeof arg === 'string') {
                    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
                }
                return fromObject(this, arg)
            }
            Buffer._augment = function (arr) {
                arr.__proto__ = Buffer.prototype
                return arr
            }
            function fromNumber(that, length) {
                that = allocate(that, length < 0 ? 0 : checked(length) | 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT) {
                    for (var i = 0; i < length; i++) {
                        that[i] = 0
                    }
                }
                return that
            }
            function fromString(that, string, encoding) {
                if (typeof encoding !== 'string' || encoding === '')
                    encoding = 'utf8'
                var length = byteLength(string, encoding) | 0
                that = allocate(that, length)
                that.write(string, encoding)
                return that
            }
            function fromObject(that, object) {
                if (Buffer.isBuffer(object))
                    return fromBuffer(that, object)
                if (isArray(object))
                    return fromArray(that, object)
                if (object == null) {
                    throw new TypeError('must start with number, buffer, array or string')
                }
                if (typeof ArrayBuffer !== 'undefined') {
                    if (object.buffer instanceof ArrayBuffer) {
                        return fromTypedArray(that, object)
                    }
                    if (object instanceof ArrayBuffer) {
                        return fromArrayBuffer(that, object)
                    }
                }
                if (object.length)
                    return fromArrayLike(that, object)
                return fromJsonObject(that, object)
            }
            function fromBuffer(that, buffer) {
                var length = checked(buffer.length) | 0
                that = allocate(that, length)
                buffer.copy(that, 0, 0, length)
                return that
            }
            function fromArray(that, array) {
                var length = checked(array.length) | 0
                that = allocate(that, length)
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255
                }
                return that
            }
            function fromTypedArray(that, array) {
                var length = checked(array.length) | 0
                that = allocate(that, length)
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255
                }
                return that
            }
            function fromArrayBuffer(that, array) {
                array.byteLength
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    that = new Uint8Array(array)
                    that.__proto__ = Buffer.prototype
                } else {
                    that = fromTypedArray(that, new Uint8Array(array))
                }
                return that
            }
            function fromArrayLike(that, array) {
                var length = checked(array.length) | 0
                that = allocate(that, length)
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255
                }
                return that
            }
            function fromJsonObject(that, object) {
                var array
                var length = 0
                if (object.type === 'Buffer' && isArray(object.data)) {
                    array = object.data
                    length = checked(array.length) | 0
                }
                that = allocate(that, length)
                for (var i = 0; i < length; i += 1) {
                    that[i] = array[i] & 255
                }
                return that
            }
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                Buffer.prototype.__proto__ = Uint8Array.prototype
                Buffer.__proto__ = Uint8Array
                if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
                    Object.defineProperty(Buffer, Symbol.species, {
                        value: null,
                        configurable: true
                    })
                }
            } else {
                Buffer.prototype.length = undefined
                Buffer.prototype.parent = undefined
            }
            function allocate(that, length) {
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    that = new Uint8Array(length)
                    that.__proto__ = Buffer.prototype
                } else {
                    that.length = length
                }
                var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
                if (fromPool)
                    that.parent = rootParent
                return that
            }
            function checked(length) {
                if (length >= kMaxLength()) {
                    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes')
                }
                return length | 0
            }
            function SlowBuffer(subject, encoding) {
                if (!(this instanceof SlowBuffer))
                    return new SlowBuffer(subject, encoding)
                var buf = new Buffer(subject, encoding)
                delete buf.parent
                return buf
            }
            Buffer.isBuffer = function isBuffer(b) {
                return !!(b != null && b._isBuffer)
            }
            Buffer.compare = function compare(a, b) {
                if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError('Arguments must be Buffers')
                }
                if (a === b)
                    return 0
                var x = a.length
                var y = b.length
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                        x = a[i]
                        y = b[i]
                        break
                    }
                }
                if (x < y)
                    return -1
                if (y < x)
                    return 1
                return 0
            }
            Buffer.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'binary':
                    case 'base64':
                    case 'raw':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return true
                    default:
                        return false
                }
            }
            Buffer.concat = function concat(list, length) {
                if (!isArray(list))
                    throw new TypeError('list argument must be an Array of Buffers.')
                if (list.length === 0) {
                    return new Buffer(0)
                }
                var i
                if (length === undefined) {
                    length = 0
                    for (i = 0; i < list.length; i++) {
                        length += list[i].length
                    }
                }
                var buf = new Buffer(length)
                var pos = 0
                for (i = 0; i < list.length; i++) {
                    var item = list[i]
                    item.copy(buf, pos)
                    pos += item.length
                }
                return buf
            }
            function byteLength(string, encoding) {
                if (typeof string !== 'string')
                    string = '' + string
                var len = string.length
                if (len === 0)
                    return 0
                var loweredCase = false
                for (; ;) {
                    switch (encoding) {
                        case 'ascii':
                        case 'binary':
                        case 'raw':
                        case 'raws':
                            return len
                        case 'utf8':
                        case 'utf-8':
                            return utf8ToBytes(string).length
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return len * 2
                        case 'hex':
                            return len >>> 1
                        case 'base64':
                            return base64ToBytes(string).length
                        default:
                            if (loweredCase)
                                return utf8ToBytes(string).length
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }
            Buffer.byteLength = byteLength
            function slowToString(encoding, start, end) {
                var loweredCase = false
                start = start | 0
                end = end === undefined || end === Infinity ? this.length : end | 0
                if (!encoding)
                    encoding = 'utf8'
                if (start < 0)
                    start = 0
                if (end > this.length)
                    end = this.length
                if (end <= start)
                    return ''
                while (true) {
                    switch (encoding) {
                        case 'hex':
                            return hexSlice(this, start, end)
                        case 'utf8':
                        case 'utf-8':
                            return utf8Slice(this, start, end)
                        case 'ascii':
                            return asciiSlice(this, start, end)
                        case 'binary':
                            return binarySlice(this, start, end)
                        case 'base64':
                            return base64Slice(this, start, end)
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return utf16leSlice(this, start, end)
                        default:
                            if (loweredCase)
                                throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = (encoding + '').toLowerCase()
                            loweredCase = true
                    }
                }
            }
            Buffer.prototype._isBuffer = true
            Buffer.prototype.toString = function toString() {
                var length = this.length | 0
                if (length === 0)
                    return ''
                if (arguments.length === 0)
                    return utf8Slice(this, 0, length)
                return slowToString.apply(this, arguments)
            }
            Buffer.prototype.equals = function equals(b) {
                if (!Buffer.isBuffer(b))
                    throw new TypeError('Argument must be a Buffer')
                if (this === b)
                    return true
                return Buffer.compare(this, b) === 0
            }
            Buffer.prototype.inspect = function inspect() {
                var str = ''
                var max = exports.INSPECT_MAX_BYTES
                if (this.length > 0) {
                    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
                    if (this.length > max)
                        str += ' ... '
                }
                return '<Buffer ' + str + '>'
            }
            Buffer.prototype.compare = function compare(b) {
                if (!Buffer.isBuffer(b))
                    throw new TypeError('Argument must be a Buffer')
                return Buffer.compare(this, b)
            }
            Buffer.prototype.indexOf = function indexOf(val, byteOffset) {
                if (byteOffset > 0x7fffffff)
                    byteOffset = 0x7fffffff
                else if (byteOffset < -0x80000000)
                    byteOffset = -0x80000000
                byteOffset >>= 0
                if (this.length === 0)
                    return -1
                if (byteOffset >= this.length)
                    return -1
                if (byteOffset < 0)
                    byteOffset = Math.max(this.length + byteOffset, 0)
                if (typeof val === 'string') {
                    if (val.length === 0)
                        return -1
                    return String.prototype.indexOf.call(this, val, byteOffset)
                }
                if (Buffer.isBuffer(val)) {
                    return arrayIndexOf(this, val, byteOffset)
                }
                if (typeof val === 'number') {
                    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                        return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
                    }
                    return arrayIndexOf(this, [val], byteOffset)
                }
                function arrayIndexOf(arr, val, byteOffset) {
                    var foundIndex = -1
                    for (var i = 0; byteOffset + i < arr.length; i++) {
                        if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                            if (foundIndex === -1)
                                foundIndex = i
                            if (i - foundIndex + 1 === val.length)
                                return byteOffset + foundIndex
                        } else {
                            foundIndex = -1
                        }
                    }
                    return -1
                }
                throw new TypeError('val must be string, number or Buffer')
            }
            function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0
                var remaining = buf.length - offset
                if (!length) {
                    length = remaining
                } else {
                    length = Number(length)
                    if (length > remaining) {
                        length = remaining
                    }
                }
                var strLen = string.length
                if (strLen % 2 !== 0)
                    throw new Error('Invalid hex string')
                if (length > strLen / 2) {
                    length = strLen / 2
                }
                for (var i = 0; i < length; i++) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16)
                    if (isNaN(parsed))
                        throw new Error('Invalid hex string')
                    buf[offset + i] = parsed
                }
                return i
            }
            function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
            }
            function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length)
            }
            function binaryWrite(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length)
            }
            function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length)
            }
            function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
            }
            Buffer.prototype.write = function write(string, offset, length, encoding) {
                if (offset === undefined) {
                    encoding = 'utf8'
                    length = this.length
                    offset = 0
                } else if (length === undefined && typeof offset === 'string') {
                    encoding = offset
                    length = this.length
                    offset = 0
                } else if (isFinite(offset)) {
                    offset = offset | 0
                    if (isFinite(length)) {
                        length = length | 0
                        if (encoding === undefined)
                            encoding = 'utf8'
                    } else {
                        encoding = length
                        length = undefined
                    }
                } else {
                    var swap = encoding
                    encoding = offset
                    offset = length | 0
                    length = swap
                }
                var remaining = this.length - offset
                if (length === undefined || length > remaining)
                    length = remaining
                if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                    throw new RangeError('attempt to write outside buffer bounds')
                }
                if (!encoding)
                    encoding = 'utf8'
                var loweredCase = false
                for (; ;) {
                    switch (encoding) {
                        case 'hex':
                            return hexWrite(this, string, offset, length)
                        case 'utf8':
                        case 'utf-8':
                            return utf8Write(this, string, offset, length)
                        case 'ascii':
                            return asciiWrite(this, string, offset, length)
                        case 'binary':
                            return binaryWrite(this, string, offset, length)
                        case 'base64':
                            return base64Write(this, string, offset, length)
                        case 'ucs2':
                        case 'ucs-2':
                        case 'utf16le':
                        case 'utf-16le':
                            return ucs2Write(this, string, offset, length)
                        default:
                            if (loweredCase)
                                throw new TypeError('Unknown encoding: ' + encoding)
                            encoding = ('' + encoding).toLowerCase()
                            loweredCase = true
                    }
                }
            }
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: 'Buffer',
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            }
            function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf)
                } else {
                    return base64.fromByteArray(buf.slice(start, end))
                }
            }
            function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end)
                var res = []
                var i = start
                while (i < end) {
                    var firstByte = buf[i]
                    var codePoint = null
                    var bytesPerSequence = (firstByte > 0xEF) ? 4 : (firstByte > 0xDF) ? 3 : (firstByte > 0xBF) ? 2 : 1
                    if (i + bytesPerSequence <= end) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint
                        switch (bytesPerSequence) {
                            case 1:
                                if (firstByte < 0x80) {
                                    codePoint = firstByte
                                }
                                break
                            case 2:
                                secondByte = buf[i + 1]
                                if ((secondByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                                    if (tempCodePoint > 0x7F) {
                                        codePoint = tempCodePoint
                                    }
                                }
                                break
                            case 3:
                                secondByte = buf[i + 1]
                                thirdByte = buf[i + 2]
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                        codePoint = tempCodePoint
                                    }
                                }
                                break
                            case 4:
                                secondByte = buf[i + 1]
                                thirdByte = buf[i + 2]
                                fourthByte = buf[i + 3]
                                if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                        codePoint = tempCodePoint
                                    }
                                }
                        }
                    }
                    if (codePoint === null) {
                        codePoint = 0xFFFD
                        bytesPerSequence = 1
                    } else if (codePoint > 0xFFFF) {
                        codePoint -= 0x10000
                        res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                        codePoint = 0xDC00 | codePoint & 0x3FF
                    }
                    res.push(codePoint)
                    i += bytesPerSequence
                }
                return decodeCodePointsArray(res)
            }
            var MAX_ARGUMENTS_LENGTH = 0x1000
            function decodeCodePointsArray(codePoints) {
                var len = codePoints.length
                if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints)
                }
                var res = ''
                var i = 0
                while (i < len) {
                    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH))
                }
                return res
            }
            function asciiSlice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)
                for (var i = start; i < end; i++) {
                    ret += String.fromCharCode(buf[i] & 0x7F)
                }
                return ret
            }
            function binarySlice(buf, start, end) {
                var ret = ''
                end = Math.min(buf.length, end)
                for (var i = start; i < end; i++) {
                    ret += String.fromCharCode(buf[i])
                }
                return ret
            }
            function hexSlice(buf, start, end) {
                var len = buf.length
                if (!start || start < 0)
                    start = 0
                if (!end || end < 0 || end > len)
                    end = len
                var out = ''
                for (var i = start; i < end; i++) {
                    out += toHex(buf[i])
                }
                return out
            }
            function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end)
                var res = ''
                for (var i = 0; i < bytes.length; i += 2) {
                    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
                }
                return res
            }
            Buffer.prototype.slice = function slice(start, end) {
                var len = this.length
                start = ~~start
                end = end === undefined ? len : ~~end
                if (start < 0) {
                    start += len
                    if (start < 0)
                        start = 0
                } else if (start > len) {
                    start = len
                }
                if (end < 0) {
                    end += len
                    if (end < 0)
                        end = 0
                } else if (end > len) {
                    end = len
                }
                if (end < start)
                    end = start
                var newBuf
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    newBuf = this.subarray(start, end)
                    newBuf.__proto__ = Buffer.prototype
                } else {
                    var sliceLen = end - start
                    newBuf = new Buffer(sliceLen, undefined)
                    for (var i = 0; i < sliceLen; i++) {
                        newBuf[i] = this[i + start]
                    }
                }
                if (newBuf.length)
                    newBuf.parent = this.parent || this
                return newBuf
            }
            function checkOffset(offset, ext, length) {
                if ((offset % 1) !== 0 || offset < 0)
                    throw new RangeError('offset is not uint')
                if (offset + ext > length)
                    throw new RangeError('Trying to access beyond buffer length')
            }
            Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert)
                    checkOffset(offset, byteLength, this.length)
                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                }
                return val
            }
            Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert) {
                    checkOffset(offset, byteLength, this.length)
                }
                var val = this[offset + --byteLength]
                var mul = 1
                while (byteLength > 0 && (mul *= 0x100)) {
                    val += this[offset + --byteLength] * mul
                }
                return val
            }
            Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 1, this.length)
                return this[offset]
            }
            Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 2, this.length)
                return this[offset] | (this[offset + 1] << 8)
            }
            Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 2, this.length)
                return (this[offset] << 8) | this[offset + 1]
            }
            Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length)
                return ((this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16)) + (this[offset + 3] * 0x1000000)
            }
            Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length)
                return (this[offset] * 0x1000000) + ((this[offset + 1] << 16) | (this[offset + 2] << 8) | this[offset + 3])
            }
            Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert)
                    checkOffset(offset, byteLength, this.length)
                var val = this[offset]
                var mul = 1
                var i = 0
                while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                }
                mul *= 0x80
                if (val >= mul)
                    val -= Math.pow(2, 8 * byteLength)
                return val
            }
            Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert)
                    checkOffset(offset, byteLength, this.length)
                var i = byteLength
                var mul = 1
                var val = this[offset + --i]
                while (i > 0 && (mul *= 0x100)) {
                    val += this[offset + --i] * mul
                }
                mul *= 0x80
                if (val >= mul)
                    val -= Math.pow(2, 8 * byteLength)
                return val
            }
            Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 1, this.length)
                if (!(this[offset] & 0x80))
                    return (this[offset])
                return ((0xff - this[offset] + 1) * -1)
            }
            Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 2, this.length)
                var val = this[offset] | (this[offset + 1] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }
            Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 2, this.length)
                var val = this[offset + 1] | (this[offset] << 8)
                return (val & 0x8000) ? val | 0xFFFF0000 : val
            }
            Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length)
                return (this[offset]) | (this[offset + 1] << 8) | (this[offset + 2] << 16) | (this[offset + 3] << 24)
            }
            Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length)
                return (this[offset] << 24) | (this[offset + 1] << 16) | (this[offset + 2] << 8) | (this[offset + 3])
            }
            Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, true, 23, 4)
            }
            Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 4, this.length)
                return ieee754.read(this, offset, false, 23, 4)
            }
            Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, true, 52, 8)
            }
            Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                if (!noAssert)
                    checkOffset(offset, 8, this.length)
                return ieee754.read(this, offset, false, 52, 8)
            }
            function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer.isBuffer(buf))
                    throw new TypeError('buffer must be a Buffer instance')
                if (value > max || value < min)
                    throw new RangeError('value is out of bounds')
                if (offset + ext > buf.length)
                    throw new RangeError('index out of range')
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert)
                    checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
                var mul = 1
                var i = 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                }
                return offset + byteLength
            }
            Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                byteLength = byteLength | 0
                if (!noAssert)
                    checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
                var i = byteLength - 1
                var mul = 1
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                }
                return offset + byteLength
            }
            Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert)
                    checkInt(this, value, offset, 1, 0xff, 0)
                if (!Buffer.TYPED_ARRAY_SUPPORT)
                    value = Math.floor(value)
                this[offset] = (value & 0xff)
                return offset + 1
            }
            function objectWriteUInt16(buf, value, offset, littleEndian) {
                if (value < 0)
                    value = 0xffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
                    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>> (littleEndian ? i : 1 - i) * 8
                }
            }
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert)
                    checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                } else {
                    objectWriteUInt16(this, value, offset, true)
                }
                return offset + 2
            }
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert)
                    checkInt(this, value, offset, 2, 0xffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 8)
                    this[offset + 1] = (value & 0xff)
                } else {
                    objectWriteUInt16(this, value, offset, false)
                }
                return offset + 2
            }
            function objectWriteUInt32(buf, value, offset, littleEndian) {
                if (value < 0)
                    value = 0xffffffff + value + 1
                for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
                    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
                }
            }
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert)
                    checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset + 3] = (value >>> 24)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 1] = (value >>> 8)
                    this[offset] = (value & 0xff)
                } else {
                    objectWriteUInt32(this, value, offset, true)
                }
                return offset + 4
            }
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert)
                    checkInt(this, value, offset, 4, 0xffffffff, 0)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = (value & 0xff)
                } else {
                    objectWriteUInt32(this, value, offset, false)
                }
                return offset + 4
            }
            Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1)
                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }
                var i = 0
                var mul = 1
                var sub = value < 0 ? 1 : 0
                this[offset] = value & 0xFF
                while (++i < byteLength && (mul *= 0x100)) {
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }
                return offset + byteLength
            }
            Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength - 1)
                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                }
                var i = byteLength - 1
                var mul = 1
                var sub = value < 0 ? 1 : 0
                this[offset + i] = value & 0xFF
                while (--i >= 0 && (mul *= 0x100)) {
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                }
                return offset + byteLength
            }
            Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert)
                    checkInt(this, value, offset, 1, 0x7f, -0x80)
                if (!Buffer.TYPED_ARRAY_SUPPORT)
                    value = Math.floor(value)
                if (value < 0)
                    value = 0xff + value + 1
                this[offset] = (value & 0xff)
                return offset + 1
            }
            Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert)
                    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                } else {
                    objectWriteUInt16(this, value, offset, true)
                }
                return offset + 2
            }
            Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert)
                    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 8)
                    this[offset + 1] = (value & 0xff)
                } else {
                    objectWriteUInt16(this, value, offset, false)
                }
                return offset + 2
            }
            Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert)
                    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value & 0xff)
                    this[offset + 1] = (value >>> 8)
                    this[offset + 2] = (value >>> 16)
                    this[offset + 3] = (value >>> 24)
                } else {
                    objectWriteUInt32(this, value, offset, true)
                }
                return offset + 4
            }
            Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value
                offset = offset | 0
                if (!noAssert)
                    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                if (value < 0)
                    value = 0xffffffff + value + 1
                if (Buffer.TYPED_ARRAY_SUPPORT) {
                    this[offset] = (value >>> 24)
                    this[offset + 1] = (value >>> 16)
                    this[offset + 2] = (value >>> 8)
                    this[offset + 3] = (value & 0xff)
                } else {
                    objectWriteUInt32(this, value, offset, false)
                }
                return offset + 4
            }
            function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length)
                    throw new RangeError('index out of range')
                if (offset < 0)
                    throw new RangeError('index out of range')
            }
            function writeFloat(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4)
                return offset + 4
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert)
            }
            Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert)
            }
            function writeDouble(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8)
                return offset + 8
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert)
            }
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert)
            }
            Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                if (!start)
                    start = 0
                if (!end && end !== 0)
                    end = this.length
                if (targetStart >= target.length)
                    targetStart = target.length
                if (!targetStart)
                    targetStart = 0
                if (end > 0 && end < start)
                    end = start
                if (end === start)
                    return 0
                if (target.length === 0 || this.length === 0)
                    return 0
                if (targetStart < 0) {
                    throw new RangeError('targetStart out of bounds')
                }
                if (start < 0 || start >= this.length)
                    throw new RangeError('sourceStart out of bounds')
                if (end < 0)
                    throw new RangeError('sourceEnd out of bounds')
                if (end > this.length)
                    end = this.length
                if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start
                }
                var len = end - start
                var i
                if (this === target && start < targetStart && targetStart < end) {
                    for (i = len - 1; i >= 0; i--) {
                        target[i + targetStart] = this[i + start]
                    }
                } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                    for (i = 0; i < len; i++) {
                        target[i + targetStart] = this[i + start]
                    }
                } else {
                    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart)
                }
                return len
            }
            Buffer.prototype.fill = function fill(value, start, end) {
                if (!value)
                    value = 0
                if (!start)
                    start = 0
                if (!end)
                    end = this.length
                if (end < start)
                    throw new RangeError('end < start')
                if (end === start)
                    return
                if (this.length === 0)
                    return
                if (start < 0 || start >= this.length)
                    throw new RangeError('start out of bounds')
                if (end < 0 || end > this.length)
                    throw new RangeError('end out of bounds')
                var i
                if (typeof value === 'number') {
                    for (i = start; i < end; i++) {
                        this[i] = value
                    }
                } else {
                    var bytes = utf8ToBytes(value.toString())
                    var len = bytes.length
                    for (i = start; i < end; i++) {
                        this[i] = bytes[i % len]
                    }
                }
                return this
            }
            var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
            function base64clean(str) {
                str = stringtrim(str).replace(INVALID_BASE64_RE, '')
                if (str.length < 2)
                    return ''
                while (str.length % 4 !== 0) {
                    str = str + '='
                }
                return str
            }
            function stringtrim(str) {
                if (str.trim)
                    return str.trim()
                return str.replace(/^\s+|\s+$/g, '')
            }
            function toHex(n) {
                if (n < 16)
                    return '0' + n.toString(16)
                return n.toString(16)
            }
            function utf8ToBytes(string, units) {
                units = units || Infinity
                var codePoint
                var length = string.length
                var leadSurrogate = null
                var bytes = []
                for (var i = 0; i < length; i++) {
                    codePoint = string.charCodeAt(i)
                    if (codePoint > 0xD7FF && codePoint < 0xE000) {
                        if (!leadSurrogate) {
                            if (codePoint > 0xDBFF) {
                                if ((units -= 3) > -1)
                                    bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            } else if (i + 1 === length) {
                                if ((units -= 3) > -1)
                                    bytes.push(0xEF, 0xBF, 0xBD)
                                continue
                            }
                            leadSurrogate = codePoint
                            continue
                        }
                        if (codePoint < 0xDC00) {
                            if ((units -= 3) > -1)
                                bytes.push(0xEF, 0xBF, 0xBD)
                            leadSurrogate = codePoint
                            continue
                        }
                        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
                    } else if (leadSurrogate) {
                        if ((units -= 3) > -1)
                            bytes.push(0xEF, 0xBF, 0xBD)
                    }
                    leadSurrogate = null
                    if (codePoint < 0x80) {
                        if ((units -= 1) < 0)
                            break
                        bytes.push(codePoint)
                    } else if (codePoint < 0x800) {
                        if ((units -= 2) < 0)
                            break
                        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80)
                    } else if (codePoint < 0x10000) {
                        if ((units -= 3) < 0)
                            break
                        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80)
                    } else if (codePoint < 0x110000) {
                        if ((units -= 4) < 0)
                            break
                        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80)
                    } else {
                        throw new Error('Invalid code point')
                    }
                }
                return bytes
            }
            function asciiToBytes(str) {
                var byteArray = []
                for (var i = 0; i < str.length; i++) {
                    byteArray.push(str.charCodeAt(i) & 0xFF)
                }
                return byteArray
            }
            function utf16leToBytes(str, units) {
                var c, hi, lo
                var byteArray = []
                for (var i = 0; i < str.length; i++) {
                    if ((units -= 2) < 0)
                        break
                    c = str.charCodeAt(i)
                    hi = c >> 8
                    lo = c % 256
                    byteArray.push(lo)
                    byteArray.push(hi)
                }
                return byteArray
            }
            function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str))
            }
            function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; i++) {
                    if ((i + offset >= dst.length) || (i >= src.length))
                        break
                    dst[i + offset] = src[i]
                }
                return i
            }
        }
        ).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    }
        , {
        "base64-js": 3,
        "ieee754": 13,
        "isarray": 6
    }],
    6: [function (require, module, exports) {
        var toString = {}.toString;
        module.exports = Array.isArray || function (arr) {
            return toString.call(arr) == '[object Array]';
        }
            ;
    }
        , {}],
    7: [function (require, module, exports) {
        (function (Buffer) {
            var clone = (function () {
                'use strict';
                function clone(parent, circular, depth, prototype) {
                    var filter;
                    if (typeof circular === 'object') {
                        depth = circular.depth;
                        prototype = circular.prototype;
                        filter = circular.filter;
                        circular = circular.circular
                    }
                    var allParents = [];
                    var allChildren = [];
                    var useBuffer = typeof Buffer != 'undefined';
                    if (typeof circular == 'undefined')
                        circular = true;
                    if (typeof depth == 'undefined')
                        depth = Infinity;
                    function _clone(parent, depth) {
                        if (parent === null)
                            return null;
                        if (depth == 0)
                            return parent;
                        var child;
                        var proto;
                        if (typeof parent != 'object') {
                            return parent;
                        }
                        if (clone.__isArray(parent)) {
                            child = [];
                        } else if (clone.__isRegExp(parent)) {
                            child = new RegExp(parent.source, __getRegExpFlags(parent));
                            if (parent.lastIndex)
                                child.lastIndex = parent.lastIndex;
                        } else if (clone.__isDate(parent)) {
                            child = new Date(parent.getTime());
                        } else if (useBuffer && Buffer.isBuffer(parent)) {
                            child = new Buffer(parent.length);
                            parent.copy(child);
                            return child;
                        } else {
                            if (typeof prototype == 'undefined') {
                                proto = Object.getPrototypeOf(parent);
                                child = Object.create(proto);
                            } else {
                                child = Object.create(prototype);
                                proto = prototype;
                            }
                        }
                        if (circular) {
                            var index = allParents.indexOf(parent);
                            if (index != -1) {
                                return allChildren[index];
                            }
                            allParents.push(parent);
                            allChildren.push(child);
                        }
                        for (var i in parent) {
                            var attrs;
                            if (proto) {
                                attrs = Object.getOwnPropertyDescriptor(proto, i);
                            }
                            if (attrs && attrs.set == null) {
                                continue;
                            }
                            child[i] = _clone(parent[i], depth - 1);
                        }
                        return child;
                    }
                    return _clone(parent, depth);
                }
                clone.clonePrototype = function clonePrototype(parent) {
                    if (parent === null)
                        return null;
                    var c = function () { };
                    c.prototype = parent;
                    return new c();
                }
                    ;
                function __objToStr(o) {
                    return Object.prototype.toString.call(o);
                }
                ; clone.__objToStr = __objToStr;
                function __isDate(o) {
                    return typeof o === 'object' && __objToStr(o) === '[object Date]';
                }
                ; clone.__isDate = __isDate;
                function __isArray(o) {
                    return typeof o === 'object' && __objToStr(o) === '[object Array]';
                }
                ; clone.__isArray = __isArray;
                function __isRegExp(o) {
                    return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
                }
                ; clone.__isRegExp = __isRegExp;
                function __getRegExpFlags(re) {
                    var flags = '';
                    if (re.global)
                        flags += 'g';
                    if (re.ignoreCase)
                        flags += 'i';
                    if (re.multiline)
                        flags += 'm';
                    return flags;
                }
                ; clone.__getRegExpFlags = __getRegExpFlags;
                return clone;
            }
            )();
            if (typeof module === 'object' && module.exports) {
                module.exports = clone;
            }
        }
        ).call(this, require("buffer").Buffer)
    }
        , {
        "buffer": 5
    }],
    8: [function (require, module, exports) {
        var clone = require('clone');
        module.exports = function (options, defaults) {
            options = options || {};
            Object.keys(defaults).forEach(function (key) {
                if (typeof options[key] === 'undefined') {
                    options[key] = clone(defaults[key]);
                }
            });
            return options;
        }
            ;
    }
        , {
        "clone": 7
    }],
    9: [function (require, module, exports) {
        var index = require('indexof');
        var whitespaceRe = /\s+/;
        var toString = Object.prototype.toString;
        module.exports = classes;
        module.exports.add = add;
        module.exports.contains = has;
        module.exports.has = has;
        module.exports.toggle = toggle;
        module.exports.remove = remove;
        module.exports.removeMatching = removeMatching;
        function classes(el) {
            if (el.classList) {
                return el.classList;
            }
            var str = el.className.replace(/^\s+|\s+$/g, '');
            var arr = str.split(whitespaceRe);
            if ('' === arr[0])
                arr.shift();
            return arr;
        }
        function add(el, name) {
            if (el.classList) {
                el.classList.add(name);
                return;
            }
            var arr = classes(el);
            var i = index(arr, name);
            if (!~i)
                arr.push(name);
            el.className = arr.join(' ');
        }
        function has(el, name) {
            return el.classList ? el.classList.contains(name) : !!~index(classes(el), name);
        }
        function remove(el, name) {
            if ('[object RegExp]' == toString.call(name)) {
                return removeMatching(el, name);
            }
            if (el.classList) {
                el.classList.remove(name);
                return;
            }
            var arr = classes(el);
            var i = index(arr, name);
            if (~i)
                arr.splice(i, 1);
            el.className = arr.join(' ');
        }
        function removeMatching(el, re, ref) {
            var arr = Array.prototype.slice.call(classes(el));
            for (var i = 0; i < arr.length; i++) {
                if (re.test(arr[i])) {
                    remove(el, arr[i]);
                }
            }
        }
        function toggle(el, name) {
            if (el.classList) {
                return el.classList.toggle(name);
            }
            if (has(el, name)) {
                remove(el, name);
            } else {
                add(el, name);
            }
        }
    }
        , {
        "indexof": 14
    }],
    10: [function (require, module, exports) {
        module.exports = create;
        function create(opt) {
            opt = opt || {};
            var el = document.createElement(opt.selector);
            if (opt.attr)
                for (var index in opt.attr)
                    opt.attr.hasOwnProperty(index) && el.setAttribute(index, opt.attr[index]);
            "a" == opt.selector && opt.link && (el.href = opt.link,
                opt.target && el.setAttribute("target", opt.target));
            "img" == opt.selector && opt.src && (el.src = opt.src,
                opt.lazyload && (el.style.opacity = 0,
                    el.onload = function () {
                        el.style.opacity = 1;
                    }
                ));
            opt.id && (el.id = opt.id);
            opt.styles && (el.className = opt.styles);
            opt.html && (el.innerHTML = opt.html);
            opt.children && (el.appendChild(opt.children));
            return el;
        }
        ;
    }
        , {}],
    11: [function (require, module, exports) {
        var prefix = require('prefix-style')
        var toCamelCase = require('to-camel-case')
        var cache = {
            'float': 'cssFloat'
        }
        var addPxToStyle = require('add-px-to-style')
        function style(element, property, value) {
            var camel = cache[property]
            if (typeof camel === 'undefined') {
                camel = detect(property)
            }
            if (camel) {
                if (value === undefined) {
                    return element.style[camel]
                }
                element.style[camel] = addPxToStyle(camel, value)
            }
        }
        function each(element, properties) {
            for (var k in properties) {
                if (properties.hasOwnProperty(k)) {
                    style(element, k, properties[k])
                }
            }
        }
        function detect(cssProp) {
            var camel = toCamelCase(cssProp)
            var result = prefix(camel)
            cache[camel] = cache[cssProp] = cache[result] = result
            return result
        }
        function set() {
            if (arguments.length === 2) {
                each(arguments[0], arguments[1])
            } else {
                style(arguments[0], arguments[1], arguments[2])
            }
        }
        module.exports = set
        module.exports.set = set
        module.exports.get = function (element, properties) {
            if (Array.isArray(properties)) {
                return properties.reduce(function (obj, prop) {
                    obj[prop] = style(element, prop || '')
                    return obj
                }, {})
            } else {
                return style(element, properties || '')
            }
        }
    }
        , {
        "add-px-to-style": 2,
        "prefix-style": 16,
        "to-camel-case": 19
    }],
    12: [function (require, module, exports) {
        module.exports = on;
        module.exports.on = on;
        module.exports.off = off;
        function on(element, event, callback, capture) {
            !element.addEventListener && (event = 'on' + event);
            (element.addEventListener || element.attachEvent).call(element, event, callback, capture);
            return callback;
        }
        function off(element, event, callback, capture) {
            !element.removeEventListener && (event = 'on' + event);
            (element.removeEventListener || element.detachEvent).call(element, event, callback, capture);
            return callback;
        }
    }
        , {}],
    13: [function (require, module, exports) {
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
            var e, m
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var nBits = -7
            var i = isLE ? (nBytes - 1) : 0
            var d = isLE ? -1 : 1
            var s = buffer[offset + i]
            i += d
            e = s & ((1 << (-nBits)) - 1)
            s >>= (-nBits)
            nBits += eLen
            for (; nBits > 0; e = e * 256 + buffer[offset + i],
                i += d,
                nBits -= 8) { }
            m = e & ((1 << (-nBits)) - 1)
            e >>= (-nBits)
            nBits += mLen
            for (; nBits > 0; m = m * 256 + buffer[offset + i],
                i += d,
                nBits -= 8) { }
            if (e === 0) {
                e = 1 - eBias
            } else if (e === eMax) {
                return m ? NaN : ((s ? -1 : 1) * Infinity)
            } else {
                m = m + Math.pow(2, mLen)
                e = e - eBias
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }
        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c
            var eLen = nBytes * 8 - mLen - 1
            var eMax = (1 << eLen) - 1
            var eBias = eMax >> 1
            var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
            var i = isLE ? 0 : (nBytes - 1)
            var d = isLE ? 1 : -1
            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
            value = Math.abs(value)
            if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0
                e = eMax
            } else {
                e = Math.floor(Math.log(value) / Math.LN2)
                if (value * (c = Math.pow(2, -e)) < 1) {
                    e--
                    c *= 2
                }
                if (e + eBias >= 1) {
                    value += rt / c
                } else {
                    value += rt * Math.pow(2, 1 - eBias)
                }
                if (value * c >= 2) {
                    e++
                    c /= 2
                }
                if (e + eBias >= eMax) {
                    m = 0
                    e = eMax
                } else if (e + eBias >= 1) {
                    m = (value * c - 1) * Math.pow(2, mLen)
                    e = e + eBias
                } else {
                    m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                    e = 0
                }
            }
            for (; mLen >= 8; buffer[offset + i] = m & 0xff,
                i += d,
                m /= 256,
                mLen -= 8) { }
            e = (e << mLen) | m
            eLen += mLen
            for (; eLen > 0; buffer[offset + i] = e & 0xff,
                i += d,
                e /= 256,
                eLen -= 8) { }
            buffer[offset + i - d] |= s * 128
        }
    }
        , {}],
    14: [function (require, module, exports) {
        var indexOf = [].indexOf;
        module.exports = function (arr, obj) {
            if (indexOf)
                return arr.indexOf(obj);
            for (var i = 0; i < arr.length; ++i) {
                if (arr[i] === obj)
                    return i;
            }
            return -1;
        }
            ;
    }
        , {}],
    15: [function (require, module, exports) {
        (function () {
            var root;
            root = typeof exports !== "undefined" && exports !== null ? exports : this;
            root.Lethargy = (function () {
                function Lethargy(stability, sensitivity, tolerance, delay) {
                    this.stability = stability != null ? Math.abs(stability) : 8;
                    this.sensitivity = sensitivity != null ? 1 + Math.abs(sensitivity) : 100;
                    this.tolerance = tolerance != null ? 1 + Math.abs(tolerance) : 1.1;
                    this.delay = delay != null ? delay : 150;
                    this.lastUpDeltas = (function () {
                        var i, ref, results;
                        results = [];
                        for (i = 1,
                            ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
                            results.push(null);
                        }
                        return results;
                    }
                    ).call(this);
                    this.lastDownDeltas = (function () {
                        var i, ref, results;
                        results = [];
                        for (i = 1,
                            ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
                            results.push(null);
                        }
                        return results;
                    }
                    ).call(this);
                    this.deltasTimestamp = (function () {
                        var i, ref, results;
                        results = [];
                        for (i = 1,
                            ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {
                            results.push(null);
                        }
                        return results;
                    }
                    ).call(this);
                }
                Lethargy.prototype.check = function (e) {
                    var lastDelta;
                    e = e.originalEvent || e;
                    if (e.wheelDelta != null) {
                        lastDelta = e.wheelDelta;
                    } else if (e.deltaY != null) {
                        lastDelta = e.deltaY * -40;
                    } else if ((e.detail != null) || e.detail === 0) {
                        lastDelta = e.detail * -40;
                    }
                    this.deltasTimestamp.push(Date.now());
                    this.deltasTimestamp.shift();
                    if (lastDelta > 0) {
                        this.lastUpDeltas.push(lastDelta);
                        this.lastUpDeltas.shift();
                        return this.isInertia(1);
                    } else {
                        this.lastDownDeltas.push(lastDelta);
                        this.lastDownDeltas.shift();
                        return this.isInertia(-1);
                    }
                    return false;
                }
                    ;
                Lethargy.prototype.isInertia = function (direction) {
                    var lastDeltas, lastDeltasNew, lastDeltasOld, newAverage, newSum, oldAverage, oldSum;
                    lastDeltas = direction === -1 ? this.lastDownDeltas : this.lastUpDeltas;
                    if (lastDeltas[0] === null) {
                        return direction;
                    }
                    if (this.deltasTimestamp[(this.stability * 2) - 2] + this.delay > Date.now() && lastDeltas[0] === lastDeltas[(this.stability * 2) - 1]) {
                        return false;
                    }
                    lastDeltasOld = lastDeltas.slice(0, this.stability);
                    lastDeltasNew = lastDeltas.slice(this.stability, this.stability * 2);
                    oldSum = lastDeltasOld.reduce(function (t, s) {
                        return t + s;
                    });
                    newSum = lastDeltasNew.reduce(function (t, s) {
                        return t + s;
                    });
                    oldAverage = oldSum / lastDeltasOld.length;
                    newAverage = newSum / lastDeltasNew.length;
                    if (Math.abs(oldAverage) < Math.abs(newAverage * this.tolerance) && (this.sensitivity < Math.abs(newAverage))) {
                        return direction;
                    } else {
                        return false;
                    }
                }
                    ;
                Lethargy.prototype.showLastUpDeltas = function () {
                    return this.lastUpDeltas;
                }
                    ;
                Lethargy.prototype.showLastDownDeltas = function () {
                    return this.lastDownDeltas;
                }
                    ;
                return Lethargy;
            }
            )();
        }
        ).call(this);
    }
        , {}],
    16: [function (require, module, exports) {
        var div = null
        var prefixes = ['Webkit', 'Moz', 'O', 'ms']
        module.exports = function prefixStyle(prop) {
            if (!div) {
                div = document.createElement('div')
            }
            var style = div.style
            if (prop in style) {
                return prop
            }
            var titleCase = prop.charAt(0).toUpperCase() + prop.slice(1)
            for (var i = prefixes.length; i >= 0; i--) {
                var name = prefixes[i] + titleCase
                if (name in style) {
                    return name
                }
            }
            return false
        }
    }
        , {}],
    17: [function (require, module, exports) {
        function identity(x) {
            return x;
        }
        module.exports = identity;
        module.exports.dash = identity;
        module.exports.dash = identity;
    }
        , {}],
    18: [function (require, module, exports) {
        function E() { }
        E.prototype = {
            on: function (name, callback, ctx) {
                var e = this.e || (this.e = {});
                (e[name] || (e[name] = [])).push({
                    fn: callback,
                    ctx: ctx
                });
                return this;
            },
            once: function (name, callback, ctx) {
                var self = this;
                function listener() {
                    self.off(name, listener);
                    callback.apply(ctx, arguments);
                }
                ; listener._ = callback
                return this.on(name, listener, ctx);
            },
            emit: function (name) {
                var data = [].slice.call(arguments, 1);
                var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
                var i = 0;
                var len = evtArr.length;
                for (i; i < len; i++) {
                    evtArr[i].fn.apply(evtArr[i].ctx, data);
                }
                return this;
            },
            off: function (name, callback) {
                var e = this.e || (this.e = {});
                var evts = e[name];
                var liveEvents = [];
                if (evts && callback) {
                    for (var i = 0, len = evts.length; i < len; i++) {
                        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
                            liveEvents.push(evts[i]);
                    }
                }
                (liveEvents.length) ? e[name] = liveEvents : delete e[name];
                return this;
            }
        };
        module.exports = E;
    }
        , {}],
    19: [function (require, module, exports) {
        var toSpace = require('to-space-case');
        module.exports = toCamelCase;
        function toCamelCase(string) {
            return toSpace(string).replace(/\s(\w)/g, function (matches, letter) {
                return letter.toUpperCase();
            });
        }
    }
        , {
        "to-space-case": 21
    }],
    20: [function (require, module, exports) {
        module.exports = toNoCase;
        var hasSpace = /\s/;
        var hasCamel = /[a-z][A-Z]/;
        var hasSeparator = /[\W_]/;
        function toNoCase(string) {
            if (hasSpace.test(string))
                return string.toLowerCase();
            if (hasSeparator.test(string))
                string = unseparate(string);
            if (hasCamel.test(string))
                string = uncamelize(string);
            return string.toLowerCase();
        }
        var separatorSplitter = /[\W_]+(.|$)/g;
        function unseparate(string) {
            return string.replace(separatorSplitter, function (m, next) {
                return next ? ' ' + next : '';
            });
        }
        var camelSplitter = /(.)([A-Z]+)/g;
        function uncamelize(string) {
            return string.replace(camelSplitter, function (m, previous, uppers) {
                return previous + ' ' + uppers.toLowerCase().split('').join(' ');
            });
        }
    }
        , {}],
    21: [function (require, module, exports) {
        var clean = require('to-no-case');
        module.exports = toSpaceCase;
        function toSpaceCase(string) {
            return clean(string).replace(/[\W_]+(.|$)/g, function (matches, match) {
                return match ? ' ' + match : '';
            });
        }
    }
        , {
        "to-no-case": 20
    }],
    22: [function (require, module, exports) {
        'use strict';
        module.exports = function (source) {
            return JSON.parse(JSON.stringify(source));
        }
            ;
    }
        , {}],
    23: [function (require, module, exports) {
        'use strict';
        var defaults = require('defaults');
        var Emitter = require('tiny-emitter');
        var Lethargy = require('lethargy').Lethargy;
        var support = require('./support');
        var clone = require('./clone');
        var bindAll = require('bindall-standalone');
        var EVT_ID = 'virtualscroll';
        module.exports = VirtualScroll;
        var keyCodes = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40
        };
        function VirtualScroll(options) {
            bindAll(this, '_onWheel', '_onMouseWheel', '_onTouchStart', '_onTouchMove', '_onKeyDown');
            this.options = defaults(options || {}, {
                mouseMultiplier: 1,
                touchMultiplier: 2,
                firefoxMultiplier: 15,
                keyStep: 120,
                preventTouch: false,
                unpreventTouchClass: 'vs-touchmove-allowed',
                limitInertia: false
            });
            if (this.options.limitInertia)
                this._lethargy = new Lethargy();
            this._emitter = new Emitter();
            this._event = {
                y: 0,
                x: 0,
                deltaX: 0,
                deltaY: 0
            };
            this.touchStartX = null;
            this.touchStartY = null;
            this.bodyTouchAction = null;
        }
        VirtualScroll.prototype._notify = function (e) {
            var evt = this._event;
            evt.x += evt.deltaX;
            evt.y += evt.deltaY;
            this._emitter.emit(EVT_ID, {
                x: evt.x,
                y: evt.y,
                deltaX: evt.deltaX,
                deltaY: evt.deltaY,
                originalEvent: e
            });
        }
            ;
        VirtualScroll.prototype._onWheel = function (e) {
            var options = this.options;
            if (this._lethargy && this._lethargy.check(e) === false)
                return;
            var evt = this._event;
            evt.deltaX = e.wheelDeltaX || e.deltaX * -1;
            evt.deltaY = e.wheelDeltaY || e.deltaY * -1;
            if (support.isFirefox && e.deltaMode == 1) {
                evt.deltaX *= options.firefoxMultiplier;
                evt.deltaY *= options.firefoxMultiplier;
            }
            evt.deltaX *= options.mouseMultiplier;
            evt.deltaY *= options.mouseMultiplier;
            this._notify(e);
        }
            ;
        VirtualScroll.prototype._onMouseWheel = function (e) {
            if (this.options.limitInertia && this._lethargy.check(e) === false)
                return;
            var evt = this._event;
            evt.deltaX = (e.wheelDeltaX) ? e.wheelDeltaX : 0;
            evt.deltaY = (e.wheelDeltaY) ? e.wheelDeltaY : e.wheelDelta;
            this._notify(e);
        }
            ;
        VirtualScroll.prototype._onTouchStart = function (e) {
            var t = (e.targetTouches) ? e.targetTouches[0] : e;
            this.touchStartX = t.pageX;
            this.touchStartY = t.pageY;
        }
            ;
        VirtualScroll.prototype._onTouchMove = function (e) {
            var options = this.options;
            if (options.preventTouch && !e.target.classList.contains(options.unpreventTouchClass)) {
                e.preventDefault();
            }
            var evt = this._event;
            var t = (e.targetTouches) ? e.targetTouches[0] : e;
            evt.deltaX = (t.pageX - this.touchStartX) * options.touchMultiplier;
            evt.deltaY = (t.pageY - this.touchStartY) * options.touchMultiplier;
            this.touchStartX = t.pageX;
            this.touchStartY = t.pageY;
            this._notify(e);
        }
            ;
        VirtualScroll.prototype._onKeyDown = function (e) {
            var evt = this._event;
            evt.deltaX = evt.deltaY = 0;
            switch (e.keyCode) {
                case keyCodes.LEFT:
                case keyCodes.UP:
                    evt.deltaY = this.options.keyStep;
                    break;
                case keyCodes.RIGHT:
                case keyCodes.DOWN:
                    evt.deltaY = -this.options.keyStep;
                    break;
                default:
                    return;
            }
            this._notify(e);
        }
            ;
        VirtualScroll.prototype._bind = function () {
            if (support.hasWheelEvent)
                document.addEventListener('wheel', this._onWheel);
            if (support.hasMouseWheelEvent)
                document.addEventListener('mousewheel', this._onMouseWheel);
            if (support.hasTouch) {
                document.addEventListener('touchstart', this._onTouchStart);
                document.addEventListener('touchmove', this._onTouchMove);
            }
            if (support.hasPointer && support.hasTouchWin) {
                this.bodyTouchAction = document.body.style.msTouchAction;
                document.body.style.msTouchAction = 'none';
                document.addEventListener('MSPointerDown', this._onTouchStart, true);
                document.addEventListener('MSPointerMove', this._onTouchMove, true);
            }
            if (support.hasKeyDown)
                document.addEventListener('keydown', this._onKeyDown);
        }
            ;
        VirtualScroll.prototype._unbind = function () {
            if (support.hasWheelEvent)
                document.removeEventListener('wheel', this._onWheel);
            if (support.hasMouseWheelEvent)
                document.removeEventListener('mousewheel', this._onMouseWheel);
            if (support.hasTouch) {
                document.removeEventListener('touchstart', this._onTouchStart);
                document.removeEventListener('touchmove', this._onTouchMove);
            }
            if (support.hasPointer && support.hasTouchWin) {
                document.body.style.msTouchAction = this.bodyTouchAction;
                document.removeEventListener('MSPointerDown', this._onTouchStart, true);
                document.removeEventListener('MSPointerMove', this._onTouchMove, true);
            }
            if (support.hasKeyDown)
                document.removeEventListener('keydown', this._onKeyDown);
        }
            ;
        VirtualScroll.prototype.on = function (cb, ctx) {
            this._emitter.on(EVT_ID, cb, ctx);
            var events = this._emitter.e;
            if (events && events[EVT_ID] && events[EVT_ID].length === 1)
                this._bind();
        }
            ;
        VirtualScroll.prototype.off = function (cb, ctx) {
            this._emitter.off(EVT_ID, cb, ctx);
            var events = this._emitter.e;
            if (!events[EVT_ID] || events[EVT_ID].length <= 0)
                this._unbind();
        }
            ;
        VirtualScroll.prototype.reset = function () {
            var evt = this._event;
            evt.x = 0;
            evt.y = 0;
        }
            ;
        VirtualScroll.prototype.destroy = function () {
            this._emitter.off();
            this._unbind();
        }
            ;
    }
        , {
        "./clone": 22,
        "./support": 24,
        "bindall-standalone": 4,
        "defaults": 8,
        "lethargy": 15,
        "tiny-emitter": 18
    }],
    24: [function (require, module, exports) {
        'use strict';
        module.exports = (function getSupport() {
            return {
                hasWheelEvent: 'onwheel' in document,
                hasMouseWheelEvent: 'onmousewheel' in document,
                hasTouch: 'ontouchstart' in document,
                hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
                hasPointer: !!window.navigator.msPointerEnabled,
                hasKeyDown: 'onkeydown' in document,
                isFirefox: navigator.userAgent.indexOf('Firefox') > -1
            };
        }
        )();
    }
        , {}]
}, {}, [1]);
; (function (root, factory) {
    'use strict';
    if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = factory(root, document);
    } else if (typeof define === 'function' && define.amd) {
        define([], function () {
            return factory(root, document);
        });
    } else {
        root.vimeovideo = factory(root, document);
    }
}(typeof window !== 'undefined' ? window : this, function (window, document) {
    'use strict';
    var fullscreen, scroll = {
        x: 0,
        y: 0
    }, defaults = {
        enabled: true,
        debug: false,
        autoplay: false,
        loop: true,
        seekTime: 10,
        volume: 10,
        volumeMin: 0,
        volumeMax: 10,
        volumeStep: 10,
        duration: null,
        displayDuration: true,
        loadSprite: false,
        iconPrefix: 'vimeovideo',
        iconUrl: '',
        clickToPlay: true,
        hideControls: false,
        showPosterOnEnd: false,
        disableContextMenu: true,
        keyboardShorcuts: {
            focused: false,
            global: false
        },
        tooltips: {
            controls: false,
            seek: false
        },
        selectors: {
            html5: 'video, audio',
            embed: '[data-type]',
            editable: 'input, textarea, select, [contenteditable]',
            container: '.vimeovideo',
            controls: {
                container: null,
                wrapper: '.vimeovideo-controls'
            },
            labels: '[data-vimeovideo]',
            buttons: {
                seek: '[data-vimeovideo="seek"]',
                play: '[data-vimeovideo="play"]',
                pause: '[data-vimeovideo="pause"]',
                restart: '[data-vimeovideo="restart"]',
                rewind: '[data-vimeovideo="rewind"]',
                forward: '[data-vimeovideo="fast-forward"]',
                mute: '[data-vimeovideo="mute"]',
                captions: '[data-vimeovideo="captions"]',
                fullscreen: '[data-vimeovideo="fullscreen"]'
            },
            volume: {
                input: '[data-vimeovideo="volume"]',
                display: '.vimeovideo-volume-display'
            },
            progress: {
                container: '.vimeovideo-progress',
                buffer: '.vimeovideo-progress-buffer',
                played: '.vimeovideo-progress-played'
            },
            captions: '.vimeovideo-captions',
            currentTime: '.vimeovideo-time-current',
            duration: '.vimeovideo-time-duration'
        },
        classes: {
            setup: 'vimeovideo-setup',
            ready: 'vimeovideo-ready',
            videoWrapper: 'vimeovideo-video-wrapper',
            embedWrapper: 'vimeovideo-video-embed',
            type: 'vimeovideo-{0}',
            stopped: 'vimeovideo-stopped',
            playing: 'vimeovideo-playing',
            muted: 'vimeovideo-muted',
            loading: 'vimeovideo-loading',
            hover: 'vimeovideo-hover',
            tooltip: 'vimeovideo-tooltip',
            hidden: 'vimeovideo-sr-only',
            hideControls: 'vimeovideo-hide-controls',
            isIos: 'vimeovideo-is-ios',
            isTouch: 'vimeovideo-is-touch',
            captions: {
                enabled: 'vimeovideo-captions-enabled',
                active: 'vimeovideo-captions-active'
            },
            fullscreen: {
                enabled: 'vimeovideo-fullscreen-enabled',
                active: 'vimeovideo-fullscreen-active'
            },
            tabFocus: 'tab-focus'
        },
        captions: {
            defaultActive: false
        },
        fullscreen: {
            enabled: false,
            fallback: false,
            allowAudio: false
        },
        storage: {
            enabled: true,
            key: 'vimeovideo'
        },
        controls: ['play-large', 'play', 'progress', 'current-time', 'mute', 'volume', 'captions', 'fullscreen'],
        i18n: {
            restart: 'Restart',
            rewind: 'Rewind {seektime} secs',
            play: 'Play',
            pause: 'Pause',
            forward: 'Forward {seektime} secs',
            played: 'played',
            buffered: 'buffered',
            currentTime: 'Current time',
            duration: 'Duration',
            volume: 'Volume',
            toggleMute: 'Toggle Mute',
            toggleCaptions: 'Toggle Captions',
            toggleFullscreen: 'Toggle Fullscreen',
            frameTitle: 'Player for {title}'
        },
        types: {
            embed: ['vimeo'],
            html5: ['video', 'audio']
        },
        urls: {
            vimeo: {
                api: 'https://player.vimeo.com/api/player.js',
            },
        },
        listeners: {
            seek: null,
            play: null,
            pause: null,
            restart: null,
            rewind: null,
            forward: null,
            mute: null,
            volume: null,
            captions: null,
            fullscreen: null
        },
        events: ['ready', 'loaded', 'ended', 'progress', 'stalled', 'playing', 'waiting', 'canplay', 'canplaythrough', 'loadstart', 'loadeddata', 'loadedmetadata', 'timeupdate', 'volumechange', 'play', 'pause', 'error', 'seeking', 'seeked', 'emptied'],
        logPrefix: '[vimeovideo]'
    };
    function _browserSniff() {
        var ua = navigator.userAgent, name = navigator.appName, fullVersion = '' + parseFloat(navigator.appVersion), majorVersion = parseInt(navigator.appVersion, 10), nameOffset, verOffset, ix, isIE = false, isFirefox = false, isChrome = false, isSafari = false;
        if ((navigator.appVersion.indexOf('Windows NT') !== -1) && (navigator.appVersion.indexOf('rv:11') !== -1)) {
            isIE = true;
            name = 'IE';
            fullVersion = '11';
        } else if ((verOffset = ua.indexOf('MSIE')) !== -1) {
            isIE = true;
            name = 'IE';
            fullVersion = ua.substring(verOffset + 5);
        } else if ((verOffset = ua.indexOf('Chrome')) !== -1) {
            isChrome = true;
            name = 'Chrome';
            fullVersion = ua.substring(verOffset + 7);
        } else if ((verOffset = ua.indexOf('Safari')) !== -1) {
            isSafari = true;
            name = 'Safari';
            fullVersion = ua.substring(verOffset + 7);
            if ((verOffset = ua.indexOf('Version')) !== -1) {
                fullVersion = ua.substring(verOffset + 8);
            }
        } else if ((verOffset = ua.indexOf('Firefox')) !== -1) {
            isFirefox = true;
            name = 'Firefox';
            fullVersion = ua.substring(verOffset + 8);
        } else if ((nameOffset = ua.lastIndexOf(' ') + 1) < (verOffset = ua.lastIndexOf('/'))) {
            name = ua.substring(nameOffset, verOffset);
            fullVersion = ua.substring(verOffset + 1);
            if (name.toLowerCase() === name.toUpperCase()) {
                name = navigator.appName;
            }
        }
        if ((ix = fullVersion.indexOf(';')) !== -1) {
            fullVersion = fullVersion.substring(0, ix);
        }
        if ((ix = fullVersion.indexOf(' ')) !== -1) {
            fullVersion = fullVersion.substring(0, ix);
        }
        majorVersion = parseInt('' + fullVersion, 10);
        if (isNaN(majorVersion)) {
            fullVersion = '' + parseFloat(navigator.appVersion);
            majorVersion = parseInt(navigator.appVersion, 10);
        }
        return {
            name: name,
            version: majorVersion,
            isIE: isIE,
            isFirefox: isFirefox,
            isChrome: isChrome,
            isSafari: isSafari,
            isIos: /(iPad|iPhone|iPod)/g.test(navigator.platform),
            isIphone: /(iPhone|iPod)/g.test(navigator.userAgent),
            isTouch: 'ontouchstart' in document.documentElement
        };
    }
    function _supportMime(vimeovideo, mimeType) {
        var media = vimeovideo.media;
        if (vimeovideo.type === 'video') {
            switch (mimeType) {
                case 'video/webm':
                    return !!(media.canPlayType && media.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/no/, ''));
                case 'video/mp4':
                    return !!(media.canPlayType && media.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"').replace(/no/, ''));
                case 'video/ogg':
                    return !!(media.canPlayType && media.canPlayType('video/ogg; codecs="theora"').replace(/no/, ''));
            }
        } else if (vimeovideo.type === 'audio') {
            switch (mimeType) {
                case 'audio/mpeg':
                    return !!(media.canPlayType && media.canPlayType('audio/mpeg;').replace(/no/, ''));
                case 'audio/ogg':
                    return !!(media.canPlayType && media.canPlayType('audio/ogg; codecs="vorbis"').replace(/no/, ''));
                case 'audio/wav':
                    return !!(media.canPlayType && media.canPlayType('audio/wav; codecs="1"').replace(/no/, ''));
            }
        }
        return false;
    }
    function _injectScript(source) {
        if (document.querySelectorAll('script[src="' + source + '"]').length) {
            return;
        }
        var tag = document.createElement('script');
        tag.src = source;
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
    }
    function _inArray(haystack, needle) {
        return Array.prototype.indexOf && (haystack.indexOf(needle) !== -1);
    }
    function _replaceAll(string, find, replace) {
        return string.replace(new RegExp(find.replace(/([.*+?\^=!:${}()|\[\]\/\\])/g, '\\$1'), 'g'), replace);
    }
    function _wrap(elements, wrapper) {
        if (!elements.length) {
            elements = [elements];
        }
        for (var i = elements.length - 1; i >= 0; i--) {
            var child = (i > 0) ? wrapper.cloneNode(true) : wrapper;
            var element = elements[i];
            var parent = element.parentNode;
            var sibling = element.nextSibling;
            child.appendChild(element);
            if (sibling) {
                parent.insertBefore(child, sibling);
            } else {
                parent.appendChild(child);
            }
            return child;
        }
    }
    function _remove(element) {
        if (!element) {
            return;
        }
        element.parentNode.removeChild(element);
    }
    function _prependChild(parent, element) {
        parent.insertBefore(element, parent.firstChild);
    }
    function _setAttributes(element, attributes) {
        for (var key in attributes) {
            element.setAttribute(key, (_is.boolean(attributes[key]) && attributes[key]) ? '' : attributes[key]);
        }
    }
    function _insertElement(type, parent, attributes) {
        var element = document.createElement(type);
        _setAttributes(element, attributes);
        _prependChild(parent, element);
    }
    function _getClassname(selector) {
        return selector.replace('.', '');
    }
    function _toggleClass(element, className, state) {
        if (element) {
            if (element.classList) {
                element.classList[state ? 'add' : 'remove'](className);
            } else {
                var name = (' ' + element.className + ' ').replace(/\s+/g, ' ').replace(' ' + className + ' ', '');
                element.className = name + (state ? ' ' + className : '');
            }
        }
    }
    function _hasClass(element, className) {
        if (element) {
            if (element.classList) {
                return element.classList.contains(className);
            } else {
                return new RegExp('(\\s|^)' + className + '(\\s|$)').test(element.className);
            }
        }
        return false;
    }
    function _matches(element, selector) {
        var p = Element.prototype;
        var f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {
            return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
        }
            ;
        return f.call(element, selector);
    }
    function _proxyListener(element, eventName, userListener, defaultListener, useCapture) {
        _on(element, eventName, function (event) {
            if (userListener) {
                userListener.apply(element, [event]);
            }
            defaultListener.apply(element, [event]);
        }, useCapture);
    }
    function _toggleListener(element, events, callback, toggle, useCapture) {
        var eventList = events.split(' ');
        if (!_is.boolean(useCapture)) {
            useCapture = false;
        }
        if (element instanceof NodeList) {
            for (var x = 0; x < element.length; x++) {
                if (element[x] instanceof Node) {
                    _toggleListener(element[x], arguments[1], arguments[2], arguments[3]);
                }
            }
            return;
        }
        for (var i = 0; i < eventList.length; i++) {
            element[toggle ? 'addEventListener' : 'removeEventListener'](eventList[i], callback, useCapture);
        }
    }
    function _on(element, events, callback, useCapture) {
        if (element) {
            _toggleListener(element, events, callback, true, useCapture);
        }
    }
    function _event(element, type, bubbles, properties) {
        if (!element || !type) {
            return;
        }
        if (!_is.boolean(bubbles)) {
            bubbles = false;
        }
        var event = new CustomEvent(type, {
            bubbles: bubbles,
            detail: properties
        });
        element.dispatchEvent(event);
    }
    function _toggleState(target, state) {
        if (!target) {
            return;
        }
        state = (_is.boolean(state) ? state : !target.getAttribute('aria-pressed'));
        target.setAttribute('aria-pressed', state);
        return state;
    }
    function _getPercentage(current, max) {
        if (current === 0 || max === 0 || isNaN(current) || isNaN(max)) {
            return 0;
        }
        return ((current / max) * 100).toFixed(2);
    }
    function _extend() {
        var objects = arguments;
        if (!objects.length) {
            return;
        }
        if (objects.length === 1) {
            return objects[0];
        }
        var destination = Array.prototype.shift.call(objects)
            , length = objects.length;
        for (var i = 0; i < length; i++) {
            var source = objects[i];
            for (var property in source) {
                if (source[property] && source[property].constructor && source[property].constructor === Object) {
                    destination[property] = destination[property] || {};
                    _extend(destination[property], source[property]);
                } else {
                    destination[property] = source[property];
                }
            }
        }
        return destination;
    }
    var _is = {
        object: function (input) {
            return input !== null && typeof (input) === 'object';
        },
        array: function (input) {
            return input !== null && (typeof (input) === 'object' && input.constructor === Array);
        },
        number: function (input) {
            return input !== null && (typeof (input) === 'number' && !isNaN(input - 0) || (typeof input === 'object' && input.constructor === Number));
        },
        string: function (input) {
            return input !== null && (typeof input === 'string' || (typeof input === 'object' && input.constructor === String));
        },
        boolean: function (input) {
            return input !== null && typeof input === 'boolean';
        },
        nodeList: function (input) {
            return input !== null && input instanceof NodeList;
        },
        htmlElement: function (input) {
            return input !== null && input instanceof HTMLElement;
        },
        function: function (input) {
            return input !== null && typeof input === 'function';
        },
        undefined: function (input) {
            return input !== null && typeof input === 'undefined';
        }
    };
    function _parseVimeoId(url) {
        var regex = /^.*(vimeo.com\/|video\/)(\d+).*/;
        return (url.match(regex)) ? RegExp.$2 : url;
    }
    function _fullscreen() {
        var fullscreen = {
            supportsFullScreen: false,
            isFullScreen: function () {
                return false;
            },
            requestFullScreen: function () { },
            cancelFullScreen: function () { },
            fullScreenEventName: '',
            element: null,
            prefix: ''
        }
            , browserPrefixes = 'webkit o moz ms khtml'.split(' ');
        if (!_is.undefined(document.cancelFullScreen)) {
            fullscreen.supportsFullScreen = true;
        } else {
            for (var i = 0, il = browserPrefixes.length; i < il; i++) {
                fullscreen.prefix = browserPrefixes[i];
                if (!_is.undefined(document[fullscreen.prefix + 'CancelFullScreen'])) {
                    fullscreen.supportsFullScreen = true;
                    break;
                } else if (!_is.undefined(document.msExitFullscreen) && document.msFullscreenEnabled) {
                    fullscreen.prefix = 'ms';
                    fullscreen.supportsFullScreen = true;
                    break;
                }
            }
        }
        if (fullscreen.supportsFullScreen) {
            fullscreen.fullScreenEventName = (fullscreen.prefix === 'ms' ? 'MSFullscreenChange' : fullscreen.prefix + 'fullscreenchange');
            fullscreen.isFullScreen = function (element) {
                if (_is.undefined(element)) {
                    element = document.body;
                }
                switch (this.prefix) {
                    case '':
                        return document.fullscreenElement === element;
                    case 'moz':
                        return document.mozFullScreenElement === element;
                    default:
                        return document[this.prefix + 'FullscreenElement'] === element;
                }
            }
                ;
            fullscreen.requestFullScreen = function (element) {
                if (_is.undefined(element)) {
                    element = document.body;
                }
                return (this.prefix === '') ? element.requestFullScreen() : element[this.prefix + (this.prefix === 'ms' ? 'RequestFullscreen' : 'RequestFullScreen')]();
            }
                ;
            fullscreen.cancelFullScreen = function () {
                return (this.prefix === '') ? document.cancelFullScreen() : document[this.prefix + (this.prefix === 'ms' ? 'ExitFullscreen' : 'CancelFullScreen')]();
            }
                ;
            fullscreen.element = function () {
                return (this.prefix === '') ? document.fullscreenElement : document[this.prefix + 'FullscreenElement'];
            }
                ;
        }
        return fullscreen;
    }
    var _storage = {
        supported: (function () {
            if (!('localStorage' in window)) {
                return false;
            }
            try {
                window.localStorage.setItem('-_test', 'OK');
                var result = window.localStorage.getItem('-_test');
                window.localStorage.removeItem('-_test');
                return (result === 'OK');
            } catch (e) {
                return false;
            }
            return false;
        }
        )()
    };
    function vimeovideo(media, config) {
        var vimeovideo = this, timers = {}, api;
        vimeovideo.media = media;
        var original = media.cloneNode(true);
        function _triggerEvent(element, type, bubbles, properties) {
            _event(element, type, bubbles, _extend({}, properties, {
                vimeovideo: api
            }));
        }
        function _console(type, args) {
            if (config.debug && window.console) {
                args = Array.prototype.slice.call(args);
                if (_is.string(config.logPrefix) && config.logPrefix.length) {
                    args.unshift(config.logPrefix);
                }
                console[type].apply(console, args);
            }
        }
        var _log = function () {
            _console('log', arguments)
        }
            , _warn = function () {
                _console('warn', arguments)
            };
        _log('Config', config);
        function _getIconUrl() {
            return {
                url: config.iconUrl,
                absolute: (config.iconUrl.indexOf("http") === 0) || vimeovideo.browser.isIE
            };
        }
        function _buildControls() {
            var html = []
                , iconUrl = _getIconUrl()
                , iconPath = (!iconUrl.absolute ? iconUrl.url : '') + '#' + config.iconPrefix;
            if (_inArray(config.controls, 'play-large')) {
                html.push('<button type="button" data-vimeovideo="play" class="vimeovideo-play-large"><span>', '</span></button>');
            }
            html.push('<div class="vimeovideo-controls">');
            if (_inArray(config.controls, 'restart')) {
                html.push('<button type="button" data-vimeovideo="restart">', '<span class="vimeovideo-sr-only">' + config.i18n.restart + '</span>', '</button>');
            }
            if (_inArray(config.controls, 'rewind')) {
                html.push('<button type="button" data-vimeovideo="rewind">', '<span class="vimeovideo-sr-only">' + config.i18n.rewind + '</span>', '</button>');
            }
            if (_inArray(config.controls, 'play')) {
                html.push('<button type="button" data-vimeovideo="play">', '<span class="vimeovideo-sr-only">' + config.i18n.play + '</span>', '</button>', '<button type="button" data-vimeovideo="pause">', '<span class="vimeovideo-sr-only">' + config.i18n.pause + '</span>', '</button>');
            }
            if (_inArray(config.controls, 'fast-forward')) {
                html.push('<button type="button" data-vimeovideo="fast-forward">', '<span class="vimeovideo-sr-only">' + config.i18n.forward + '</span>', '</button>');
            }
            if (_inArray(config.controls, 'progress')) {
                html.push('<span class="vimeovideo-progress">', '<label for="seek{id}" class="vimeovideo-sr-only">Seek</label>', '<input id="seek{id}" class="vimeovideo-progress-seek" type="range" min="0" max="100" step="0.1" value="0" data-vimeovideo="seek">', '<progress class="vimeovideo-progress-played" max="100" value="0" role="presentation"></progress>', '<progress class="vimeovideo-progress-buffer" max="100" value="0">', '<span>0</span>% ' + config.i18n.buffered, '</progress>');
                if (config.tooltips.seek) {
                    html.push('<span class="vimeovideo-tooltip">00:00</span>');
                }
                html.push('</span>');
            }
            if (_inArray(config.controls, 'current-time')) {
                html.push('<span class="vimeovideo-time">', '<span class="vimeovideo-sr-only">' + config.i18n.currentTime + '</span>', '<span class="vimeovideo-time-current">00:00</span>', '</span>');
            }
            if (_inArray(config.controls, 'duration')) {
                html.push('<span class="vimeovideo-time">', '<span class="vimeovideo-sr-only">' + config.i18n.duration + '</span>', '<span class="vimeovideo-time-duration">00:00</span>', '</span>');
            }
            if (_inArray(config.controls, 'mute')) {
                html.push('<button type="button" data-vimeovideo="mute">', '<span class="vimeovideo-sr-only">' + config.i18n.toggleMute + '</span>', '</button>');
            }
            if (_inArray(config.controls, 'volume')) {
                html.push('<span class="vimeovideo-volume">', '<label for="volume{id}" class="vimeovideo-sr-only">' + config.i18n.volume + '</label>', '<input id="volume{id}" class="vimeovideo-volume-input" type="range" min="' + config.volumeMin + '" max="' + config.volumeMax + '" value="' + config.volume + '" data-vimeovideo="volume">', '<progress class="vimeovideo-volume-display" max="' + config.volumeMax + '" value="' + config.volumeMin + '" role="presentation"></progress>', '</span>');
            }
            if (_inArray(config.controls, 'captions')) {
                html.push('<button type="button" data-vimeovideo="captions">', '<span class="vimeovideo-sr-only">' + config.i18n.toggleCaptions + '</span>', '</button>');
            }
            if (_inArray(config.controls, 'fullscreen')) {
                html.push('<button type="button" data-vimeovideo="fullscreen">', '<span class="vimeovideo-sr-only">' + config.i18n.toggleFullscreen + '</span>', '</button>');
            }
            html.push('</div>');
            return html.join('');
        }
        function _setupFullscreen() {
            if (!vimeovideo.supported.full) {
                return;
            }
            if ((vimeovideo.type !== 'audio' || config.fullscreen.allowAudio) && config.fullscreen.enabled) {
                var nativeSupport = fullscreen.supportsFullScreen;
                if (nativeSupport || (config.fullscreen.fallback && !_inFrame())) {
                    _log((nativeSupport ? 'Native' : 'Fallback') + ' fullscreen enabled');
                    _toggleClass(vimeovideo.container, config.classes.fullscreen.enabled, true);
                } else {
                    _log('Fullscreen not supported and fallback disabled');
                }
                if (vimeovideo.buttons && vimeovideo.buttons.fullscreen) {
                    _toggleState(vimeovideo.buttons.fullscreen, false);
                }
                _focusTrap();
            }
        }
        function _setupCaptions() {
            if (vimeovideo.type !== 'video') {
                return;
            }
            if (!_getElement(config.selectors.captions)) {
                vimeovideo.videoContainer.insertAdjacentHTML('afterbegin', '<div class="' + _getClassname(config.selectors.captions) + '"></div>');
            }
            vimeovideo.usingTextTracks = false;
            if (vimeovideo.media.textTracks) {
                vimeovideo.usingTextTracks = true;
            }
            var captionSrc = '', kind, children = vimeovideo.media.childNodes;
            for (var i = 0; i < children.length; i++) {
                if (children[i].nodeName.toLowerCase() === 'track') {
                    kind = children[i].kind;
                    if (kind === 'captions' || kind === 'subtitles') {
                        captionSrc = children[i].getAttribute('src');
                    }
                }
            }
            vimeovideo.captionExists = true;
            if (captionSrc === '') {
                vimeovideo.captionExists = false;
                _log('No caption track found');
            } else {
                _log('Caption track found; URI: ' + captionSrc);
            }
            if (!vimeovideo.captionExists) {
                _toggleClass(vimeovideo.container, config.classes.captions.enabled);
            } else {
                var tracks = vimeovideo.media.textTracks;
                for (var x = 0; x < tracks.length; x++) {
                    tracks[x].mode = 'hidden';
                }
                _showCaptions(vimeovideo);
                if ((vimeovideo.browser.isIE && vimeovideo.browser.version >= 10) || (vimeovideo.browser.isFirefox && vimeovideo.browser.version >= 31)) {
                    _log('Detected browser with known TextTrack issues - using manual fallback');
                    vimeovideo.usingTextTracks = false;
                }
                if (vimeovideo.usingTextTracks) {
                    _log('TextTracks supported');
                    for (var y = 0; y < tracks.length; y++) {
                        var track = tracks[y];
                        if (track.kind === 'captions' || track.kind === 'subtitles') {
                            _on(track, 'cuechange', function () {
                                if (this.activeCues[0] && 'text' in this.activeCues[0]) {
                                    _setCaption(this.activeCues[0].getCueAsHTML());
                                } else {
                                    _setCaption();
                                }
                            });
                        }
                    }
                } else {
                    _log('TextTracks not supported so rendering captions manually');
                    vimeovideo.currentCaption = '';
                    vimeovideo.captions = [];
                    if (captionSrc !== '') {
                        var xhr = new XMLHttpRequest();
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState === 4) {
                                if (xhr.status === 200) {
                                    var captions = [], caption, req = xhr.responseText;
                                    var lineSeparator = '\r\n';
                                    if (req.indexOf(lineSeparator + lineSeparator) === -1) {
                                        if (req.indexOf('\r\r') !== -1) {
                                            lineSeparator = '\r';
                                        } else {
                                            lineSeparator = '\n';
                                        }
                                    }
                                    captions = req.split(lineSeparator + lineSeparator);
                                    for (var r = 0; r < captions.length; r++) {
                                        caption = captions[r];
                                        vimeovideo.captions[r] = [];
                                        var parts = caption.split(lineSeparator)
                                            , index = 0;
                                        if (parts[index].indexOf(":") === -1) {
                                            index = 1;
                                        }
                                        vimeovideo.captions[r] = [parts[index], parts[index + 1]];
                                    }
                                    vimeovideo.captions.shift();
                                    _log('Successfully loaded the caption file via AJAX');
                                } else {
                                    _warn(config.logPrefix + 'There was a problem loading the caption file via AJAX');
                                }
                            }
                        }
                            ;
                        xhr.open('get', captionSrc, true);
                        xhr.send();
                    }
                }
            }
        }
        function _setCaption(caption) {
            var container = _getElement(config.selectors.captions)
                , content = document.createElement('span');
            container.innerHTML = '';
            if (_is.undefined(caption)) {
                caption = '';
            }
            if (_is.string(caption)) {
                content.innerHTML = caption.trim();
            } else {
                content.appendChild(caption);
            }
            container.appendChild(content);
            var redraw = container.offsetHeight;
        }
        function _seekManualCaptions(time) {
            function _timecodeCommon(tc, pos) {
                var tcpair = [];
                tcpair = tc.split(' --> ');
                for (var i = 0; i < tcpair.length; i++) {
                    tcpair[i] = tcpair[i].replace(/(\d+:\d+:\d+\.\d+).*/, "$1");
                }
                return _subTcSecs(tcpair[pos]);
            }
            function _timecodeMin(tc) {
                return _timecodeCommon(tc, 0);
            }
            function _timecodeMax(tc) {
                return _timecodeCommon(tc, 1);
            }
            function _subTcSecs(tc) {
                if (tc === null || tc === undefined) {
                    return 0;
                } else {
                    var tc1 = [], tc2 = [], seconds;
                    tc1 = tc.split(',');
                    tc2 = tc1[0].split(':');
                    seconds = Math.floor(tc2[0] * 60 * 60) + Math.floor(tc2[1] * 60) + Math.floor(tc2[2]);
                    return seconds;
                }
            }
            if (vimeovideo.usingTextTracks || vimeovideo.type !== 'video' || !vimeovideo.supported.full) {
                return;
            }
            vimeovideo.subcount = 0;
            time = _is.number(time) ? time : vimeovideo.media.currentTime;
            if (!vimeovideo.captions[vimeovideo.subcount]) {
                return;
            }
            while (_timecodeMax(vimeovideo.captions[vimeovideo.subcount][0]) < time.toFixed(1)) {
                vimeovideo.subcount++;
                if (vimeovideo.subcount > vimeovideo.captions.length - 1) {
                    vimeovideo.subcount = vimeovideo.captions.length - 1;
                    break;
                }
            }
            if (vimeovideo.media.currentTime.toFixed(1) >= _timecodeMin(vimeovideo.captions[vimeovideo.subcount][0]) && vimeovideo.media.currentTime.toFixed(1) <= _timecodeMax(vimeovideo.captions[vimeovideo.subcount][0])) {
                vimeovideo.currentCaption = vimeovideo.captions[vimeovideo.subcount][1];
                _setCaption(vimeovideo.currentCaption);
            } else {
                _setCaption();
            }
        }
        function _showCaptions() {
            if (!vimeovideo.buttons.captions) {
                return;
            }
            _toggleClass(vimeovideo.container, config.classes.captions.enabled, true);
            var active = vimeovideo.storage.captionsEnabled;
            if (!_is.boolean(active)) {
                active = config.captions.defaultActive;
            }
            if (active) {
                _toggleClass(vimeovideo.container, config.classes.captions.active, true);
                _toggleState(vimeovideo.buttons.captions, true);
            }
        }
        function _getElements(selector) {
            return vimeovideo.container.querySelectorAll(selector);
        }
        function _getElement(selector) {
            return _getElements(selector)[0];
        }
        function _inFrame() {
            try {
                return window.self !== window.top;
            } catch (e) {
                return true;
            }
        }
        function _focusTrap() {
            var tabbables = _getElements('input:not([disabled]), button:not([disabled])')
                , first = tabbables[0]
                , last = tabbables[tabbables.length - 1];
            function _checkFocus(event) {
                if (event.which === 9 && vimeovideo.isFullscreen) {
                    if (event.target === last && !event.shiftKey) {
                        event.preventDefault();
                        first.focus();
                    } else if (event.target === first && event.shiftKey) {
                        event.preventDefault();
                        last.focus();
                    }
                }
            }
            _on(vimeovideo.container, 'keydown', _checkFocus);
        }
        function _insertChildElements(type, attributes) {
            if (_is.string(attributes)) {
                _insertElement(type, vimeovideo.media, {
                    src: attributes
                });
            } else if (attributes.constructor === Array) {
                for (var i = attributes.length - 1; i >= 0; i--) {
                    _insertElement(type, vimeovideo.media, attributes[i]);
                }
            }
        }
        function _injectControls() {
            if (config.loadSprite) {
                var iconUrl = _getIconUrl();
                if (iconUrl.absolute) {
                    _log('AJAX loading absolute SVG sprite' + (vimeovideo.browser.isIE ? ' (due to IE)' : ''));
                    loadSprite(iconUrl.url, "sprite-vimeovideo");
                } else {
                    _log('Sprite will be used as external resource directly');
                }
            }
            var html = config.html;
            _log('Injecting custom controls');
            if (!html) {
                html = _buildControls();
            }
            html = _replaceAll(html, '{seektime}', config.seekTime);
            html = _replaceAll(html, '{id}', Math.floor(Math.random() * (10000)));
            var target;
            if (_is.string(config.selectors.controls.container)) {
                target = document.querySelector(config.selectors.controls.container);
            }
            if (!_is.htmlElement(target)) {
                target = vimeovideo.container
            }
            target.insertAdjacentHTML('beforeend', html);
            if (config.tooltips.controls) {
                var labels = _getElements([config.selectors.controls.wrapper, ' ', config.selectors.labels, ' .', config.classes.hidden].join(''));
                for (var i = labels.length - 1; i >= 0; i--) {
                    var label = labels[i];
                    _toggleClass(label, config.classes.hidden, false);
                    _toggleClass(label, config.classes.tooltip, true);
                }
            }
        }
        function _findElements() {
            try {
                vimeovideo.controls = _getElement(config.selectors.controls.wrapper);
                vimeovideo.buttons = {};
                vimeovideo.buttons.seek = _getElement(config.selectors.buttons.seek);
                vimeovideo.buttons.play = _getElements(config.selectors.buttons.play);
                vimeovideo.buttons.pause = _getElement(config.selectors.buttons.pause);
                vimeovideo.buttons.restart = _getElement(config.selectors.buttons.restart);
                vimeovideo.buttons.rewind = _getElement(config.selectors.buttons.rewind);
                vimeovideo.buttons.forward = _getElement(config.selectors.buttons.forward);
                vimeovideo.buttons.fullscreen = _getElement(config.selectors.buttons.fullscreen);
                vimeovideo.buttons.mute = _getElement(config.selectors.buttons.mute);
                vimeovideo.buttons.captions = _getElement(config.selectors.buttons.captions);
                vimeovideo.progress = {};
                vimeovideo.progress.container = _getElement(config.selectors.progress.container);
                vimeovideo.progress.buffer = {};
                vimeovideo.progress.buffer.bar = _getElement(config.selectors.progress.buffer);
                vimeovideo.progress.buffer.text = vimeovideo.progress.buffer.bar && vimeovideo.progress.buffer.bar.getElementsByTagName('span')[0];
                vimeovideo.progress.played = _getElement(config.selectors.progress.played);
                vimeovideo.progress.tooltip = vimeovideo.progress.container && vimeovideo.progress.container.querySelector('.' + config.classes.tooltip);
                vimeovideo.volume = {};
                vimeovideo.volume.input = _getElement(config.selectors.volume.input);
                vimeovideo.volume.display = _getElement(config.selectors.volume.display);
                vimeovideo.duration = _getElement(config.selectors.duration);
                vimeovideo.currentTime = _getElement(config.selectors.currentTime);
                vimeovideo.seekTime = _getElements(config.selectors.seekTime);
                return true;
            } catch (e) {
                _warn('It looks like there is a problem with your controls HTML');
                _toggleNativeControls(true);
                return false;
            }
        }
        function _toggleStyleHook() {
            _toggleClass(vimeovideo.container, config.selectors.container.replace('.', ''), vimeovideo.supported.full);
        }
        function _toggleNativeControls(toggle) {
            if (toggle && _inArray(config.types.html5, vimeovideo.type)) {
                vimeovideo.media.setAttribute('controls', '');
            } else {
                vimeovideo.media.removeAttribute('controls');
            }
        }
        function _setTitle(iframe) {
            var label = config.i18n.play;
            if (_is.string(config.title) && config.title.length) {
                label += ', ' + config.title;
                vimeovideo.container.setAttribute('aria-label', config.title);
            }
            if (vimeovideo.supported.full && vimeovideo.buttons.play) {
                for (var i = vimeovideo.buttons.play.length - 1; i >= 0; i--) {
                    vimeovideo.buttons.play[i].setAttribute('aria-label', label);
                }
            }
            if (_is.htmlElement(iframe)) {
                iframe.setAttribute('title', config.i18n.frameTitle.replace('{title}', config.title));
            }
        }
        function _setupStorage() {
            var value = null;
            vimeovideo.storage = {};
            if (!_storage.supported || !config.storage.enabled) {
                return;
            }
            window.localStorage.removeItem('vimeovideo-volume');
            value = window.localStorage.getItem(config.storage.key);
            if (!value) {
                return;
            } else if (/^\d+(\.\d+)?$/.test(value)) {
                _updateStorage({
                    volume: parseFloat(value)
                });
            } else {
                vimeovideo.storage = JSON.parse(value);
            }
        }
        function _updateStorage(value) {
            if (!_storage.supported || !config.storage.enabled) {
                return;
            }
            _extend(vimeovideo.storage, value);
            window.localStorage.setItem(config.storage.key, JSON.stringify(vimeovideo.storage));
        }
        function _setupMedia() {
            if (!vimeovideo.media) {
                _warn('No media element found!');
                return;
            }
            if (vimeovideo.supported.full) {
                _toggleClass(vimeovideo.container, config.classes.type.replace('{0}', vimeovideo.type), true);
                if (_inArray(config.types.embed, vimeovideo.type)) {
                    _toggleClass(vimeovideo.container, config.classes.type.replace('{0}', 'video'), true);
                }
                _toggleClass(vimeovideo.container, config.classes.stopped, config.autoplay);
                _toggleClass(vimeovideo.container, config.classes.isIos, vimeovideo.browser.isIos);
                _toggleClass(vimeovideo.container, config.classes.isTouch, vimeovideo.browser.isTouch);
                if (vimeovideo.type === 'video') {
                    var wrapper = document.createElement('div');
                    wrapper.setAttribute('class', config.classes.videoWrapper);
                    _wrap(vimeovideo.media, wrapper);
                    vimeovideo.videoContainer = wrapper;
                }
            }
            if (_inArray(config.types.embed, vimeovideo.type)) {
                _setupEmbed();
            }
        }
        function _setupEmbed() {
            var container = document.createElement('div'), mediaId, id = vimeovideo.type + '-' + Math.floor(Math.random() * (10000));
            switch (vimeovideo.type) {
                case 'vimeo':
                    mediaId = _parseVimeoId(vimeovideo.embedId);
                    break;
                default:
                    mediaId = vimeovideo.embedId;
            }
            var containers = _getElements('[id^="' + vimeovideo.type + '-"]');
            for (var i = containers.length - 1; i >= 0; i--) {
                _remove(containers[i]);
            }
            _toggleClass(vimeovideo.media, config.classes.videoWrapper, true);
            _toggleClass(vimeovideo.media, config.classes.embedWrapper, true);
            if (vimeovideo.type === 'vimeo') {
                if (vimeovideo.supported.full) {
                    vimeovideo.media.appendChild(container);
                } else {
                    container = vimeovideo.media;
                }
                container.setAttribute('id', id);
                if (!_is.object(window.Vimeo)) {
                    _injectScript(config.urls.vimeo.api);
                    var vimeoTimer = window.setInterval(function () {
                        if (_is.object(window.Vimeo)) {
                            window.clearInterval(vimeoTimer);
                            _vimeoReady(mediaId, container);
                        }
                    }, 50);
                } else {
                    _vimeoReady(mediaId, container);
                }
            }
            ;
        }
        function _embedReady() {
            if (vimeovideo.supported.full) {
                _setupInterface();
                _ready();
            }
            _setTitle(_getElement('iframe'));
        }
        function _vimeoReady(mediaId, container) {
            vimeovideo.embed = new window.Vimeo.Player(container, {
                id: parseInt(mediaId),
                loop: config.loop,
                autoplay: config.autoplay,
                byline: false,
                autopause: false,
                portrait: true,
                title: false
            });
            vimeovideo.media.play = function () {
                vimeovideo.embed.play();
                vimeovideo.media.paused = false;
            }
                ;
            vimeovideo.media.pause = function () {
                vimeovideo.embed.pause();
                vimeovideo.media.paused = true;
            }
                ;
            vimeovideo.media.stop = function () {
                vimeovideo.embed.stop();
                vimeovideo.media.paused = true;
            }
                ;
            vimeovideo.media.paused = true;
            vimeovideo.media.currentTime = 0;
            _embedReady();
            vimeovideo.embed.getCurrentTime().then(function (value) {
                vimeovideo.media.currentTime = value;
                _triggerEvent(vimeovideo.media, 'timeupdate');
            });
            vimeovideo.embed.getDuration().then(function (value) {
                vimeovideo.media.duration = value;
                _triggerEvent(vimeovideo.media, 'durationchange');
            });
            vimeovideo.embed.on('loaded', function () {
                if (_is.htmlElement(vimeovideo.embed.element) && vimeovideo.supported.full) {
                    vimeovideo.embed.element.setAttribute('tabindex', '-1');
                }
            });
            vimeovideo.embed.on('play', function () {
                vimeovideo.media.paused = false;
                _triggerEvent(vimeovideo.media, 'play');
                _triggerEvent(vimeovideo.media, 'playing');
            });
            vimeovideo.embed.on('pause', function () {
                vimeovideo.media.paused = true;
                _triggerEvent(vimeovideo.media, 'pause');
            });
            vimeovideo.embed.on('timeupdate', function (data) {
                vimeovideo.media.seeking = false;
                vimeovideo.media.currentTime = data.seconds;
                _triggerEvent(vimeovideo.media, 'timeupdate');
            });
            vimeovideo.embed.on('progress', function (data) {
                vimeovideo.media.buffered = data.percent;
                _triggerEvent(vimeovideo.media, 'progress');
                if (parseInt(data.percent) === 1) {
                    _triggerEvent(vimeovideo.media, 'canplaythrough');
                }
            });
            vimeovideo.embed.on('seeked', function () {
                vimeovideo.media.seeking = false;
                _triggerEvent(vimeovideo.media, 'seeked');
                _triggerEvent(vimeovideo.media, 'play');
            });
            vimeovideo.embed.on('ended', function () {
                vimeovideo.media.paused = true;
                _triggerEvent(vimeovideo.media, 'ended');
            });
        }
        function _play() {
            if ('play' in vimeovideo.media) {
                vimeovideo.media.play();
            }
        }
        function _pause() {
            if ('pause' in vimeovideo.media) {
                vimeovideo.media.pause();
            }
        }
        function _togglePlay(toggle) {
            if (!_is.boolean(toggle)) {
                toggle = vimeovideo.media.paused;
            }
            if (toggle) {
                _play();
            } else {
                _pause();
            }
            return toggle;
        }
        function _rewind(seekTime) {
            if (!_is.number(seekTime)) {
                seekTime = config.seekTime;
            }
            _seek(vimeovideo.media.currentTime - seekTime);
        }
        function _forward(seekTime) {
            if (!_is.number(seekTime)) {
                seekTime = config.seekTime;
            }
            _seek(vimeovideo.media.currentTime + seekTime);
        }
        function _seek(input) {
            var targetTime = 0
                , paused = vimeovideo.media.paused
                , duration = _getDuration();
            if (_is.number(input)) {
                targetTime = input;
            } else if (_is.object(input) && _inArray(['input', 'change'], input.type)) {
                targetTime = ((input.target.value / input.target.max) * duration);
            }
            if (targetTime < 0) {
                targetTime = 0;
            } else if (targetTime > duration) {
                targetTime = duration;
            }
            _updateSeekDisplay(targetTime);
            try {
                vimeovideo.media.currentTime = targetTime.toFixed(4);
            } catch (e) { }
            if (_inArray(config.types.embed, vimeovideo.type)) {
                switch (vimeovideo.type) {
                    case 'vimeo':
                        vimeovideo.embed.setCurrentTime(targetTime.toFixed(0));
                        break;
                }
                if (paused) {
                    _pause();
                }
                _triggerEvent(vimeovideo.media, 'timeupdate');
                vimeovideo.media.seeking = true;
                _triggerEvent(vimeovideo.media, 'seeking');
            }
            _log('Seeking to ' + vimeovideo.media.currentTime + ' seconds');
            _seekManualCaptions(targetTime);
        }
        function _getDuration() {
            var duration = parseInt(config.duration)
                , mediaDuration = 0;
            if (vimeovideo.media.duration !== null && !isNaN(vimeovideo.media.duration)) {
                mediaDuration = vimeovideo.media.duration;
            }
            return (isNaN(duration) ? mediaDuration : duration);
        }
        function _checkPlaying() {
            _toggleClass(vimeovideo.container, config.classes.playing, !vimeovideo.media.paused);
            _toggleClass(vimeovideo.container, config.classes.stopped, vimeovideo.media.paused);
            _toggleControls(vimeovideo.media.paused);
        }
        function _saveScrollPosition() {
            scroll = {
                x: window.pageXOffset || 0,
                y: window.pageYOffset || 0
            };
        }
        function _restoreScrollPosition() {
            window.scrollTo(scroll.x, scroll.y);
        }
        function _toggleFullscreen(event) {
            var nativeSupport = fullscreen.supportsFullScreen;
            if (nativeSupport) {
                if (event && event.type === fullscreen.fullScreenEventName) {
                    _saveScrollPosition();
                    vimeovideo.isFullscreen = fullscreen.isFullScreen(vimeovideo.container);
                } else {
                    if (!fullscreen.isFullScreen(vimeovideo.container)) {
                        _saveScrollPosition();
                        fullscreen.requestFullScreen(vimeovideo.container);
                    } else {
                        fullscreen.cancelFullScreen();
                    }
                    vimeovideo.isFullscreen = fullscreen.isFullScreen(vimeovideo.container);
                    return;
                }
            } else {
                vimeovideo.isFullscreen = !vimeovideo.isFullscreen;
                document.body.style.overflow = vimeovideo.isFullscreen ? 'hidden' : '';
            }
            _toggleClass(vimeovideo.container, config.classes.fullscreen.active, vimeovideo.isFullscreen);
            _focusTrap(vimeovideo.isFullscreen);
            if (vimeovideo.buttons && vimeovideo.buttons.fullscreen) {
                _toggleState(vimeovideo.buttons.fullscreen, vimeovideo.isFullscreen);
            }
            _triggerEvent(vimeovideo.container, vimeovideo.isFullscreen ? 'enterfullscreen' : 'exitfullscreen', true);
            if (!vimeovideo.isFullscreen && nativeSupport) {
                _restoreScrollPosition();
            }
        }
        function _toggleMute(muted) {
            if (!_is.boolean(muted)) {
                muted = !vimeovideo.media.muted;
            }
            _toggleState(vimeovideo.buttons.mute, muted);
            vimeovideo.media.muted = muted;
            if (vimeovideo.media.volume === 0) {
                _setVolume(config.volume);
            }
            if (_inArray(config.types.embed, vimeovideo.type)) {
                switch (vimeovideo.type) {
                    case 'vimeo':
                        vimeovideo.embed.setVolume(vimeovideo.media.muted ? 0 : parseFloat(config.volume / config.volumeMax));
                        break;
                }
                _triggerEvent(vimeovideo.media, 'volumechange');
            }
        }
        function _setVolume(volume) {
            var max = config.volumeMax
                , min = config.volumeMin;
            if (_is.undefined(volume)) {
                volume = vimeovideo.storage.volume;
            }
            if (volume === null || isNaN(volume)) {
                volume = config.volume;
            }
            if (volume > max) {
                volume = max;
            }
            if (volume < min) {
                volume = min;
            }
            vimeovideo.media.volume = parseFloat(volume / max);
            if (vimeovideo.volume.display) {
                vimeovideo.volume.display.value = volume;
            }
            if (_inArray(config.types.embed, vimeovideo.type)) {
                switch (vimeovideo.type) {
                    case 'vimeo':
                        vimeovideo.embed.setVolume(vimeovideo.media.volume);
                        break;
                }
                _triggerEvent(vimeovideo.media, 'volumechange');
            }
            if (volume === 0) {
                vimeovideo.media.muted = true;
            } else if (vimeovideo.media.muted && volume > 0) {
                _toggleMute();
            }
        }
        function _increaseVolume(step) {
            var volume = vimeovideo.media.muted ? 0 : (vimeovideo.media.volume * config.volumeMax);
            if (!_is.number(step)) {
                step = config.volumeStep;
            }
            _setVolume(volume + step);
        }
        function _decreaseVolume(step) {
            var volume = vimeovideo.media.muted ? 0 : (vimeovideo.media.volume * config.volumeMax);
            if (!_is.number(step)) {
                step = config.volumeStep;
            }
            _setVolume(volume - step);
        }
        function _updateVolume() {
            var volume = vimeovideo.media.muted ? 0 : (vimeovideo.media.volume * config.volumeMax);
            if (vimeovideo.supported.full) {
                if (vimeovideo.volume.input) {
                    vimeovideo.volume.input.value = volume;
                }
                if (vimeovideo.volume.display) {
                    vimeovideo.volume.display.value = volume;
                }
            }
            _updateStorage({
                volume: volume
            });
            _toggleClass(vimeovideo.container, config.classes.muted, (volume === 0));
            if (vimeovideo.supported.full && vimeovideo.buttons.mute) {
                _toggleState(vimeovideo.buttons.mute, (volume === 0));
            }
        }
        function _toggleCaptions(show) {
            if (!vimeovideo.supported.full || !vimeovideo.buttons.captions) {
                return;
            }
            if (!_is.boolean(show)) {
                show = (vimeovideo.container.className.indexOf(config.classes.captions.active) === -1);
            }
            vimeovideo.captionsEnabled = show;
            _toggleState(vimeovideo.buttons.captions, vimeovideo.captionsEnabled);
            _toggleClass(vimeovideo.container, config.classes.captions.active, vimeovideo.captionsEnabled);
            _triggerEvent(vimeovideo.container, vimeovideo.captionsEnabled ? 'captionsenabled' : 'captionsdisabled', true);
            _updateStorage({
                captionsEnabled: vimeovideo.captionsEnabled
            });
        }
        function _checkLoading(event) {
            var loading = (event.type === 'waiting');
            clearTimeout(timers.loading);
            timers.loading = setTimeout(function () {
                _toggleClass(vimeovideo.container, config.classes.loading, loading);
                _toggleControls(loading);
            }, (loading ? 250 : 0));
        }
        function _updateProgress(event) {
            if (!vimeovideo.supported.full) {
                return;
            }
            var progress = vimeovideo.progress.played
                , value = 0
                , duration = _getDuration();
            if (event) {
                switch (event.type) {
                    case 'timeupdate':
                    case 'seeking':
                        if (vimeovideo.controls.pressed) {
                            return;
                        }
                        value = _getPercentage(vimeovideo.media.currentTime, duration);
                        if (event.type === 'timeupdate' && vimeovideo.buttons.seek) {
                            vimeovideo.buttons.seek.value = value;
                        }
                        break;
                    case 'playing':
                    case 'progress':
                        progress = vimeovideo.progress.buffer;
                        value = (function () {
                            var buffered = vimeovideo.media.buffered;
                            if (buffered && buffered.length) {
                                return _getPercentage(buffered.end(0), duration);
                            } else if (_is.number(buffered)) {
                                if ($(vimeovideo.container).find('.video-holder').children('div').css('opacity') == '0')
                                    setTimeout(function () {
                                        $(vimeovideo.container).find('.video-holder').children('div').css('opacity', '1')
                                    }, 20)
                                return (buffered * 100);
                            }
                            return 0;
                        }
                        )();
                        break;
                }
            }
            _setProgress(progress, value);
        }
        function _setProgress(progress, value) {
            if (!vimeovideo.supported.full) {
                return;
            }
            if (_is.undefined(value)) {
                value = 0;
            }
            if (_is.undefined(progress)) {
                if (vimeovideo.progress && vimeovideo.progress.buffer) {
                    progress = vimeovideo.progress.buffer;
                } else {
                    return;
                }
            }
            if (_is.htmlElement(progress)) {
                progress.value = value;
            } else if (progress) {
                if (progress.bar) {
                    progress.bar.value = value;
                }
                if (progress.text) {
                    progress.text.innerHTML = value;
                }
            }
        }
        function _updateTimeDisplay(time, element) {
            if (!element) {
                return;
            }
            if (isNaN(time)) {
                time = 0;
            }
            vimeovideo.secs = parseInt(time % 60);
            vimeovideo.mins = parseInt((time / 60) % 60);
            vimeovideo.hours = parseInt(((time / 60) / 60) % 60);
            var displayHours = (parseInt(((_getDuration() / 60) / 60) % 60) > 0);
            vimeovideo.secs = ('0' + vimeovideo.secs).slice(-2);
            vimeovideo.mins = ('0' + vimeovideo.mins).slice(-2);
            element.innerHTML = (displayHours ? vimeovideo.hours + ':' : '') + vimeovideo.mins + ':' + vimeovideo.secs;
        }
        function _displayDuration() {
            if (!vimeovideo.supported.full) {
                return;
            }
            var duration = _getDuration() || 0;
            if (!vimeovideo.duration && config.displayDuration && vimeovideo.media.paused) {
                _updateTimeDisplay(duration, vimeovideo.currentTime);
            }
            if (vimeovideo.duration) {
                _updateTimeDisplay(duration, vimeovideo.duration);
            }
            _updateSeekTooltip();
        }
        function _timeUpdate(event) {
            _updateTimeDisplay(vimeovideo.media.currentTime, vimeovideo.currentTime);
            if (event && event.type === 'timeupdate' && vimeovideo.media.seeking) {
                return;
            }
            _updateProgress(event);
        }
        function _updateSeekDisplay(time) {
            if (!_is.number(time)) {
                time = 0;
            }
            var duration = _getDuration()
                , value = _getPercentage(time, duration);
            if (vimeovideo.progress && vimeovideo.progress.played) {
                vimeovideo.progress.played.value = value;
            }
            if (vimeovideo.buttons && vimeovideo.buttons.seek) {
                vimeovideo.buttons.seek.value = value;
            }
        }
        function _updateSeekTooltip(event) {
            var duration = _getDuration();
            if (!config.tooltips.seek || !vimeovideo.progress.container || duration === 0) {
                return;
            }
            var clientRect = vimeovideo.progress.container.getBoundingClientRect()
                , percent = 0
                , visible = config.classes.tooltip + '-visible';
            if (!event) {
                if (_hasClass(vimeovideo.progress.tooltip, visible)) {
                    percent = vimeovideo.progress.tooltip.style.left.replace('%', '');
                } else {
                    return;
                }
            } else {
                percent = ((100 / clientRect.width) * (event.pageX - clientRect.left));
            }
            if (percent < 0) {
                percent = 0;
            } else if (percent > 100) {
                percent = 100;
            }
            _updateTimeDisplay(((duration / 100) * percent), vimeovideo.progress.tooltip);
            vimeovideo.progress.tooltip.style.left = percent + "%";
            if (event && _inArray(['mouseenter', 'mouseleave'], event.type)) {
                _toggleClass(vimeovideo.progress.tooltip, visible, (event.type === 'mouseenter'));
            }
        }
        function _toggleControls(toggle) {
            if (!config.hideControls || vimeovideo.type === 'audio') {
                return;
            }
            var delay = 0
                , isEnterFullscreen = false
                , show = toggle
                , loading = _hasClass(vimeovideo.container, config.classes.loading);
            if (!_is.boolean(toggle)) {
                if (toggle && toggle.type) {
                    isEnterFullscreen = (toggle.type === 'enterfullscreen');
                    show = _inArray(['mousemove', 'touchstart', 'mouseenter', 'focus'], toggle.type);
                    if (_inArray(['mousemove', 'touchmove'], toggle.type)) {
                        delay = 2000;
                    }
                    if (toggle.type === 'focus') {
                        delay = 3000;
                    }
                } else {
                    show = _hasClass(vimeovideo.container, config.classes.hideControls);
                }
            }
            window.clearTimeout(timers.hover);
            if (show || vimeovideo.media.paused || loading) {
                _toggleClass(vimeovideo.container, config.classes.hideControls, false);
                if (vimeovideo.media.paused || loading) {
                    return;
                }
                if (vimeovideo.browser.isTouch) {
                    delay = 3000;
                }
            }
            if (!show || !vimeovideo.media.paused) {
                timers.hover = window.setTimeout(function () {
                    if ((vimeovideo.controls.pressed || vimeovideo.controls.hover) && !isEnterFullscreen) {
                        return;
                    }
                    _toggleClass(vimeovideo.container, config.classes.hideControls, true);
                }, delay);
            }
        }
        function _source(source) {
            if (!_is.undefined(source)) {
                _updateSource(source);
                return;
            }
            var url;
            switch (vimeovideo.type) {
                case 'vimeo':
                    vimeovideo.embed.getVideoUrl.then(function (value) {
                        url = value;
                    });
                    break;
                default:
                    url = vimeovideo.media.currentSrc;
                    break;
            }
            return url || '';
        }
        function _updateSource(source) {
            if (!_is.object(source) || !('sources' in source) || !source.sources.length) {
                _warn('Invalid source format');
                return;
            }
            _toggleClass(vimeovideo.container, config.classes.ready, false);
            _pause();
            _updateSeekDisplay();
            _setProgress();
            _cancelRequests();
            function setup() {
                vimeovideo.embed = null;
                _remove(vimeovideo.media);
                if (vimeovideo.type === 'video' && vimeovideo.videoContainer) {
                    _remove(vimeovideo.videoContainer);
                }
                if (vimeovideo.container) {
                    vimeovideo.container.removeAttribute('class');
                }
                if ('type' in source) {
                    vimeovideo.type = source.type;
                    if (vimeovideo.type === 'video') {
                        var firstSource = source.sources[0];
                        if ('type' in firstSource && _inArray(config.types.embed, firstSource.type)) {
                            vimeovideo.type = firstSource.type;
                        }
                    }
                }
                vimeovideo.supported = supported(vimeovideo.type);
                switch (vimeovideo.type) {
                    case 'video':
                        vimeovideo.media = document.createElement('video');
                        break;
                    case 'audio':
                        vimeovideo.media = document.createElement('audio');
                        break;
                    case 'vimeo':
                        vimeovideo.media = document.createElement('div');
                        vimeovideo.embedId = source.sources[0].src;
                        break;
                }
                _prependChild(vimeovideo.container, vimeovideo.media);
                if (_is.boolean(source.autoplay)) {
                    config.autoplay = source.autoplay;
                }
                if (_inArray(config.types.html5, vimeovideo.type)) {
                    if (config.crossorigin) {
                        vimeovideo.media.setAttribute('crossorigin', '');
                    }
                    if (config.autoplay) {
                        vimeovideo.media.setAttribute('autoplay', '');
                    }
                    if ('poster' in source) {
                        vimeovideo.media.setAttribute('poster', source.poster);
                    }
                    if (config.loop) {
                        vimeovideo.media.setAttribute('loop', '');
                    }
                }
                _toggleClass(vimeovideo.container, config.classes.fullscreen.active, vimeovideo.isFullscreen);
                _toggleClass(vimeovideo.container, config.classes.captions.active, vimeovideo.captionsEnabled);
                _toggleStyleHook();
                if (_inArray(config.types.html5, vimeovideo.type)) {
                    _insertChildElements('source', source.sources);
                }
                _setupMedia();
                if (_inArray(config.types.html5, vimeovideo.type)) {
                    if ('tracks' in source) {
                        _insertChildElements('track', source.tracks);
                    }
                    vimeovideo.media.load();
                }
                if (_inArray(config.types.html5, vimeovideo.type) || (_inArray(config.types.embed, vimeovideo.type) && !vimeovideo.supported.full)) {
                    _setupInterface();
                    _ready();
                }
                config.title = source.title;
                _setTitle();
            }
            _destroy(setup, false);
        }
        function _updatePoster(source) {
            if (vimeovideo.type === 'video') {
                vimeovideo.media.setAttribute('poster', source);
            }
        }
        function _controlListeners() {
            var inputEvent = (vimeovideo.browser.isIE ? 'change' : 'input');
            function togglePlay() {
                var play = _togglePlay();
                var trigger = vimeovideo.buttons[play ? 'play' : 'pause']
                    , target = vimeovideo.buttons[play ? 'pause' : 'play'];
                if (target && target.length > 1) {
                    target = target[target.length - 1];
                } else {
                    target = target[0];
                }
                if (target) {
                    var hadTabFocus = _hasClass(trigger, config.classes.tabFocus);
                    setTimeout(function () {
                        target.focus();
                        if (hadTabFocus) {
                            _toggleClass(trigger, config.classes.tabFocus, false);
                            _toggleClass(target, config.classes.tabFocus, true);
                        }
                    }, 100);
                }
            }
            function getFocusElement() {
                var focused = document.activeElement;
                if (!focused || focused === document.body) {
                    focused = null;
                } else {
                    focused = document.querySelector(':focus');
                }
                return focused;
            }
            function getKeyCode(event) {
                return event.keyCode ? event.keyCode : event.which;
            }
            function checkTabFocus(focused) {
                for (var button in vimeovideo.buttons) {
                    var element = vimeovideo.buttons[button];
                    if (_is.nodeList(element)) {
                        for (var i = 0; i < element.length; i++) {
                            _toggleClass(element[i], config.classes.tabFocus, (element[i] === focused));
                        }
                    } else {
                        _toggleClass(element, config.classes.tabFocus, (element === focused));
                    }
                }
            }
            if (config.keyboardShorcuts.focused) {
                var last = null;
                if (config.keyboardShorcuts.global) {
                    _on(window, 'keydown keyup', function (event) {
                        var code = getKeyCode(event)
                            , focused = getFocusElement()
                            , allowed = [48, 49, 50, 51, 52, 53, 54, 56, 57, 75, 77, 70, 67]
                            , count = get().length;
                        if (count === 1 && _inArray(allowed, code) && (!_is.htmlElement(focused) || !_matches(focused, config.selectors.editable))) {
                            handleKey(event);
                        }
                    });
                }
                _on(vimeovideo.container, 'keydown keyup', handleKey);
            }
            function handleKey(event) {
                var code = getKeyCode(event)
                    , pressed = event.type === 'keydown'
                    , held = pressed && code === last;
                if (!_is.number(code)) {
                    return;
                }
                function seekByKey() {
                    var duration = vimeovideo.media.duration;
                    if (!_is.number(duration)) {
                        return;
                    }
                    _seek((duration / 10) * (code - 48));
                }
                if (pressed) {
                    var preventDefault = [48, 49, 50, 51, 52, 53, 54, 56, 57, 32, 75, 38, 40, 77, 39, 37, 70, 67];
                    if (_inArray(preventDefault, code)) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                    switch (code) {
                        case 48:
                        case 49:
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                        case 54:
                        case 55:
                        case 56:
                        case 57:
                            if (!held) {
                                seekByKey();
                            }
                            break;
                        case 32:
                        case 75:
                            if (!held) {
                                _togglePlay();
                            }
                            break;
                        case 38:
                            _increaseVolume();
                            break;
                        case 40:
                            _decreaseVolume();
                            break;
                        case 77:
                            if (!held) {
                                _toggleMute()
                            }
                            break;
                        case 39:
                            _forward();
                            break;
                        case 37:
                            _rewind();
                            break;
                        case 70:
                            _toggleFullscreen();
                            break;
                        case 67:
                            if (!held) {
                                _toggleCaptions();
                            }
                            break;
                    }
                    if (!fullscreen.supportsFullScreen && vimeovideo.isFullscreen && code === 27) {
                        _toggleFullscreen();
                    }
                    last = code;
                } else {
                    last = null;
                }
            }
            _on(window, 'keyup', function (event) {
                var code = getKeyCode(event)
                    , focused = getFocusElement();
                if (code === 9) {
                    checkTabFocus(focused);
                }
            });
            _on(document.body, 'click', function () {
                _toggleClass(_getElement('.' + config.classes.tabFocus), config.classes.tabFocus, false);
            });
            for (var button in vimeovideo.buttons) {
                var element = vimeovideo.buttons[button];
                _on(element, 'blur', function () {
                    _toggleClass(element, 'tab-focus', false);
                });
            }
            _proxyListener(vimeovideo.buttons.play, 'click', config.listeners.play, togglePlay);
            _proxyListener(vimeovideo.buttons.pause, 'click', config.listeners.pause, togglePlay);
            _proxyListener(vimeovideo.buttons.restart, 'click', config.listeners.restart, _seek);
            _proxyListener(vimeovideo.buttons.rewind, 'click', config.listeners.rewind, _rewind);
            _proxyListener(vimeovideo.buttons.forward, 'click', config.listeners.forward, _forward);
            _proxyListener(vimeovideo.buttons.seek, inputEvent, config.listeners.seek, _seek);
            _proxyListener(vimeovideo.volume.input, inputEvent, config.listeners.volume, function () {
                _setVolume(vimeovideo.volume.input.value);
            });
            _proxyListener(vimeovideo.buttons.mute, 'click', config.listeners.mute, _toggleMute);
            _proxyListener(vimeovideo.buttons.fullscreen, 'click', config.listeners.fullscreen, _toggleFullscreen);
            if (fullscreen.supportsFullScreen) {
                _on(document, fullscreen.fullScreenEventName, _toggleFullscreen);
            }
            _on(vimeovideo.buttons.captions, 'click', _toggleCaptions);
            _on(vimeovideo.progress.container, 'mouseenter mouseleave mousemove', _updateSeekTooltip);
            if (config.hideControls) {
                _on(vimeovideo.container, 'mouseenter mouseleave mousemove touchstart touchend touchcancel touchmove enterfullscreen', _toggleControls);
                _on(vimeovideo.controls, 'mouseenter mouseleave', function (event) {
                    vimeovideo.controls.hover = event.type === 'mouseenter';
                });
                _on(vimeovideo.controls, 'mousedown mouseup touchstart touchend touchcancel', function (event) {
                    vimeovideo.controls.pressed = _inArray(['mousedown', 'touchstart'], event.type);
                });
                _on(vimeovideo.controls, 'focus blur', _toggleControls, true);
            }
            _on(vimeovideo.volume.input, 'wheel', function (event) {
                event.preventDefault();
                var inverted = event.webkitDirectionInvertedFromDevice
                    , step = (config.volumeStep / 5);
                if (event.deltaY < 0 || event.deltaX > 0) {
                    if (inverted) {
                        _decreaseVolume(step);
                    } else {
                        _increaseVolume(step);
                    }
                }
                if (event.deltaY > 0 || event.deltaX < 0) {
                    if (inverted) {
                        _increaseVolume(step);
                    } else {
                        _decreaseVolume(step);
                    }
                }
            });
        }
        function _mediaListeners() {
            _on(vimeovideo.media, 'timeupdate seeking', _timeUpdate);
            _on(vimeovideo.media, 'timeupdate', _seekManualCaptions);
            _on(vimeovideo.media, 'durationchange loadedmetadata', _displayDuration);
            _on(vimeovideo.media, 'ended', function () {
                if (vimeovideo.type === 'video' && config.showPosterOnEnd) {
                    if (vimeovideo.type === 'video') {
                        _setCaption();
                    }
                    _seek();
                    vimeovideo.media.load();
                }
            });
            _on(vimeovideo.media, 'progress playing', _updateProgress);
            _on(vimeovideo.media, 'volumechange', _updateVolume);
            _on(vimeovideo.media, 'play pause ended', _checkPlaying);
            _on(vimeovideo.media, 'waiting canplay seeked', _checkLoading);
            if (config.clickToPlay && vimeovideo.type !== 'audio') {
                var wrapper = _getElement('.' + config.classes.videoWrapper);
                if (!wrapper) {
                    return;
                }
                wrapper.style.cursor = "pointer";
                _on(wrapper, 'click', function () {
                    if (config.hideControls && vimeovideo.browser.isTouch && !vimeovideo.media.paused) {
                        return;
                    }
                    if (vimeovideo.media.paused) {
                        _play();
                    } else if (vimeovideo.media.ended) {
                        _seek();
                        _play();
                    } else {
                        _pause();
                    }
                });
            }
            if (config.disableContextMenu) {
                _on(vimeovideo.media, 'contextmenu', function (event) {
                    event.preventDefault();
                });
            }
            _on(vimeovideo.media, config.events.concat(['keyup', 'keydown']).join(' '), function (event) {
                _triggerEvent(vimeovideo.container, event.type, true);
            });
        }
        function _cancelRequests() {
            if (!_inArray(config.types.html5, vimeovideo.type)) {
                return;
            }
            var sources = vimeovideo.media.querySelectorAll('source');
            for (var i = 0; i < sources.length; i++) {
                _remove(sources[i]);
            }
            vimeovideo.media.setAttribute('src', 'https://cdn.selz.com/vimeovideo/blank.mp4');
            vimeovideo.media.load();
            _log('Cancelled network requests');
        }
        function _destroy(callback, restore) {
            if (!vimeovideo.init) {
                return null;
            }
            switch (vimeovideo.type) {
                case 'vimeo':
                    vimeovideo.embed.unload().then(cleanUp);
                    timers.cleanUp = window.setTimeout(cleanUp, 200);
                    break;
                case 'video':
                case 'audio':
                    _toggleNativeControls(true);
                    cleanUp();
                    break;
            }
            function cleanUp() {
                clearTimeout(timers.cleanUp);
                if (!_is.boolean(restore)) {
                    restore = true;
                }
                if (_is.function(callback)) {
                    callback.call(original);
                }
                if (!restore) {
                    return;
                }
                vimeovideo.init = false;
                vimeovideo.container.parentNode.replaceChild(original, vimeovideo.container);
                document.body.style.overflow = '';
                _triggerEvent(original, 'destroyed', true);
            }
        }
        function _init() {
            if (vimeovideo.init) {
                return null;
            }
            fullscreen = _fullscreen();
            vimeovideo.browser = _browserSniff();
            if (!_is.htmlElement(vimeovideo.media)) {
                return;
            }
            _setupStorage();
            var tagName = media.tagName.toLowerCase();
            if (tagName === 'div') {
                vimeovideo.type = media.getAttribute('data-type');
                vimeovideo.embedId = media.getAttribute('data-video-id');
                media.removeAttribute('data-type');
                media.removeAttribute('data-video-id');
            } else {
                vimeovideo.type = tagName;
                config.crossorigin = (media.getAttribute('crossorigin') !== null);
                config.autoplay = (config.autoplay || (media.getAttribute('autoplay') !== null));
                config.loop = (config.loop || (media.getAttribute('loop') !== null));
            }
            vimeovideo.supported = supported(vimeovideo.type);
            if (!vimeovideo.supported.basic) {
                return;
            }
            vimeovideo.container = _wrap(media, document.createElement('div'));
            vimeovideo.container.setAttribute('tabindex', 0);
            _toggleStyleHook();
            _log('' + vimeovideo.browser.name + ' ' + vimeovideo.browser.version);
            _setupMedia();
            if (_inArray(config.types.html5, vimeovideo.type) || (_inArray(config.types.embed, vimeovideo.type) && !vimeovideo.supported.full)) {
                _setupInterface();
                _ready();
                _setTitle();
            }
            vimeovideo.init = true;
        }
        function _setupInterface() {
            if (!vimeovideo.supported.full) {
                _warn('Basic support only', vimeovideo.type);
                _remove(_getElement(config.selectors.controls.wrapper));
                _remove(_getElement(config.selectors.buttons.play));
                _toggleNativeControls(true);
                return;
            }
            var controlsMissing = !_getElements(config.selectors.controls.wrapper).length;
            if (controlsMissing) {
                _injectControls();
            }
            if (!_findElements()) {
                return;
            }
            if (controlsMissing) {
                _controlListeners();
            }
            _mediaListeners();
            _toggleNativeControls();
            _setupFullscreen();
            _setupCaptions();
            _setVolume();
            _updateVolume();
            _timeUpdate();
            _checkPlaying();
            var color = $('.single-holder').data('controls');
            $('.vimeovideo-play-large').css('border-color', color);
            $('.vimeovideo-play-large span').css({
                'borderLeftColor': color
            });
            $('.vimeovideo-progress-played').css({
                'color': color
            });
        }
        api = {
            getOriginal: function () {
                return original;
            },
            getContainer: function () {
                return vimeovideo.container
            },
            getEmbed: function () {
                return vimeovideo.embed;
            },
            getMedia: function () {
                return vimeovideo.media;
            },
            getType: function () {
                return vimeovideo.type;
            },
            getDuration: _getDuration,
            getCurrentTime: function () {
                return vimeovideo.media.currentTime;
            },
            getVolume: function () {
                return vimeovideo.media.volume;
            },
            isMuted: function () {
                return vimeovideo.media.muted;
            },
            isReady: function () {
                return _hasClass(vimeovideo.container, config.classes.ready);
            },
            isLoading: function () {
                return _hasClass(vimeovideo.container, config.classes.loading);
            },
            isPaused: function () {
                return vimeovideo.media.paused;
            },
            on: function (event, callback) {
                _on(vimeovideo.container, event, callback);
                return this;
            },
            play: _play,
            pause: _pause,
            stop: function () {
                _pause();
                _seek();
            },
            restart: _seek,
            rewind: _rewind,
            forward: _forward,
            seek: _seek,
            source: _source,
            poster: _updatePoster,
            setVolume: _setVolume,
            togglePlay: _togglePlay,
            toggleMute: _toggleMute,
            toggleCaptions: _toggleCaptions,
            toggleFullscreen: _toggleFullscreen,
            toggleControls: _toggleControls,
            isFullscreen: function () {
                return vimeovideo.isFullscreen || false;
            },
            support: function (mimeType) {
                return _supportMime(vimeovideo, mimeType);
            },
            destroy: _destroy
        };
        function _ready() {
            window.setTimeout(function () {
                _triggerEvent(vimeovideo.media, 'ready');
            }, 0);
            _toggleClass(vimeovideo.media, defaults.classes.setup, true);
            _toggleClass(vimeovideo.container, config.classes.ready, true);
            vimeovideo.media.vimeovideo = api;
            if (config.autoplay) {
                _play();
            }
        }
        _init();
        if (!vimeovideo.init) {
            return null;
        }
        return api;
    }
    function loadSprite(url, id) {
        var x = new XMLHttpRequest();
        if (_is.string(id) && _is.htmlElement(document.querySelector('#' + id))) {
            return;
        }
        var container = document.createElement('div');
        container.setAttribute('hidden', '');
        if (_is.string(id)) {
            container.setAttribute('id', id);
        }
        document.body.insertBefore(container, document.body.childNodes[0]);
        if ('withCredentials' in x) {
            x.open('GET', url, true);
        } else {
            return;
        }
        x.onload = function () {
            container.innerHTML = x.responseText;
        }
        x.send();
    }
    function supported(type) {
        var browser = _browserSniff()
            , isOldIE = (browser.isIE && browser.version <= 9)
            , isIos = browser.isIos
            , isIphone = browser.isIphone
            , audioSupport = !!document.createElement('audio').canPlayType
            , videoSupport = !!document.createElement('video').canPlayType
            , basic = false
            , full = false;
        switch (type) {
            case 'video':
                basic = videoSupport;
                full = (basic && (!isOldIE && !isIphone));
                break;
            case 'audio':
                basic = audioSupport;
                full = (basic && !isOldIE);
                break;
            case 'vimeo':
                basic = true;
                full = (!isOldIE && !isIos);
                break;
            default:
                basic = (audioSupport && videoSupport);
                full = (basic && !isOldIE);
        }
        return {
            basic: basic,
            full: full
        };
    }
    function setup(targets, options) {
        var players = []
            , instances = []
            , selector = [defaults.selectors.html5, defaults.selectors.embed].join(',');
        if (_is.string(targets)) {
            targets = document.querySelectorAll(targets);
        } else if (_is.htmlElement(targets)) {
            targets = [targets];
        } else if (!_is.nodeList(targets) && !_is.array(targets) && !_is.string(targets)) {
            if (_is.undefined(options) && _is.object(targets)) {
                options = targets;
            }
            targets = document.querySelectorAll(selector);
        }
        if (_is.nodeList(targets)) {
            targets = Array.prototype.slice.call(targets);
        }
        if (!supported().basic || !targets.length) {
            return false;
        }
        function add(target, media) {
            if (!_hasClass(media, defaults.classes.hook)) {
                players.push({
                    target: target,
                    media: media
                });
            }
        }
        for (var i = 0; i < targets.length; i++) {
            var target = targets[i];
            var children = target.querySelectorAll(selector);
            if (children.length) {
                for (var x = 0; x < children.length; x++) {
                    add(target, children[x]);
                }
            } else if (_matches(target, selector)) {
                add(target, target);
            }
        }
        players.forEach(function (player) {
            var element = player.target
                , media = player.media
                , match = false;
            if (media === element) {
                match = true;
            }
            var data = {};
            try {
                data = JSON.parse(element.getAttribute('data-vimeovideo'));
            } catch (e) { }
            var config = _extend({}, defaults, options, data);
            if (!config.enabled) {
                return null;
            }
            var instance = new vimeovideo(media, config);
            if (!_is.object(instance)) {
                return;
            }
            if (config.debug) {
                var events = config.events.concat(['setup', 'statechange', 'enterfullscreen', 'exitfullscreen', 'captionsenabled', 'captionsdisabled']);
                _on(instance.getContainer(), events.join(' '), function (event) {
                    console.log([config.logPrefix, 'event:', event.type].join(' '), event.detail.vimeovideo);
                });
            }
            _event(instance.getContainer(), 'setup', true, {
                vimeovideo: instance
            });
            instances.push(instance);
        });
        return instances;
    }
    function get(container) {
        if (_is.string(container)) {
            container = document.querySelector(container);
        } else if (_is.undefined(container)) {
            container = document.body;
        }
        if (_is.htmlElement(container)) {
            var elements = container.querySelectorAll('.' + defaults.classes.setup)
                , instances = [];
            Array.prototype.slice.call(elements).forEach(function (element) {
                if (_is.object(element.vimeovideo)) {
                    instances.push(element.vimeovideo);
                }
            });
            return instances;
        }
        return [];
    }
    return {
        setup: setup,
        supported: supported,
        loadSprite: loadSprite,
        get: get
    };
}));
(function () {
    if (typeof window.CustomEvent === 'function') {
        return;
    }
    function CustomEvent(event, params) {
        params = params || {
            bubbles: false,
            cancelable: false,
            detail: undefined
        };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    }
    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
}
)();
/*!
 * Isotope PACKAGED v3.0.4
 *
 * Licensed GPLv3 for open source use
 * or Isotope Commercial License for commercial use
 *
 * http://isotope.metafizzy.co
 * Copyright 2017 Metafizzy
 */
!function (t, e) {
    "function" == typeof define && define.amd ? define("jquery-bridget/jquery-bridget", ["jquery"], function (i) {
        return e(t, i)
    }) : "object" == typeof module && module.exports ? module.exports = e(t, require("jquery")) : t.jQueryBridget = e(t, t.jQuery)
}(window, function (t, e) {
    "use strict";
    function i(i, s, a) {
        function u(t, e, o) {
            var n, s = "$()." + i + '("' + e + '")';
            return t.each(function (t, u) {
                var h = a.data(u, i);
                if (!h)
                    return void r(i + " not initialized. Cannot call methods, i.e. " + s);
                var d = h[e];
                if (!d || "_" == e.charAt(0))
                    return void r(s + " is not a valid method");
                var l = d.apply(h, o);
                n = void 0 === n ? l : n
            }),
                void 0 !== n ? n : t
        }
        function h(t, e) {
            t.each(function (t, o) {
                var n = a.data(o, i);
                n ? (n.option(e),
                    n._init()) : (n = new s(o, e),
                        a.data(o, i, n))
            })
        }
        a = a || e || t.jQuery,
            a && (s.prototype.option || (s.prototype.option = function (t) {
                a.isPlainObject(t) && (this.options = a.extend(!0, this.options, t))
            }
            ),
                a.fn[i] = function (t) {
                    if ("string" == typeof t) {
                        var e = n.call(arguments, 1);
                        return u(this, t, e)
                    }
                    return h(this, t),
                        this
                }
                ,
                o(a))
    }
    function o(t) {
        !t || t && t.bridget || (t.bridget = i)
    }
    var n = Array.prototype.slice
        , s = t.console
        , r = "undefined" == typeof s ? function () { }
            : function (t) {
                s.error(t)
            }
        ;
    return o(e || t.jQuery),
        i
}),
    function (t, e) {
        "function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", e) : "object" == typeof module && module.exports ? module.exports = e() : t.EvEmitter = e()
    }("undefined" != typeof window ? window : this, function () {
        function t() { }
        var e = t.prototype;
        return e.on = function (t, e) {
            if (t && e) {
                var i = this._events = this._events || {}
                    , o = i[t] = i[t] || [];
                return o.indexOf(e) == -1 && o.push(e),
                    this
            }
        }
            ,
            e.once = function (t, e) {
                if (t && e) {
                    this.on(t, e);
                    var i = this._onceEvents = this._onceEvents || {}
                        , o = i[t] = i[t] || {};
                    return o[e] = !0,
                        this
                }
            }
            ,
            e.off = function (t, e) {
                var i = this._events && this._events[t];
                if (i && i.length) {
                    var o = i.indexOf(e);
                    return o != -1 && i.splice(o, 1),
                        this
                }
            }
            ,
            e.emitEvent = function (t, e) {
                var i = this._events && this._events[t];
                if (i && i.length) {
                    var o = 0
                        , n = i[o];
                    e = e || [];
                    for (var s = this._onceEvents && this._onceEvents[t]; n;) {
                        var r = s && s[n];
                        r && (this.off(t, n),
                            delete s[n]),
                            n.apply(this, e),
                            o += r ? 0 : 1,
                            n = i[o]
                    }
                    return this
                }
            }
            ,
            t
    }),
    function (t, e) {
        "use strict";
        "function" == typeof define && define.amd ? define("get-size/get-size", [], function () {
            return e()
        }) : "object" == typeof module && module.exports ? module.exports = e() : t.getSize = e()
    }(window, function () {
        "use strict";
        function t(t) {
            var e = parseFloat(t)
                , i = t.indexOf("%") == -1 && !isNaN(e);
            return i && e
        }
        function e() { }
        function i() {
            for (var t = {
                width: 0,
                height: 0,
                innerWidth: 0,
                innerHeight: 0,
                outerWidth: 0,
                outerHeight: 0
            }, e = 0; e < h; e++) {
                var i = u[e];
                t[i] = 0
            }
            return t
        }
        function o(t) {
            var e = getComputedStyle(t);
            return e || a("Style returned " + e + ". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1"),
                e
        }
        function n() {
            if (!d) {
                d = !0;
                var e = document.createElement("div");
                e.style.width = "200px",
                    e.style.padding = "1px 2px 3px 4px",
                    e.style.borderStyle = "solid",
                    e.style.borderWidth = "1px 2px 3px 4px",
                    e.style.boxSizing = "border-box";
                var i = document.body || document.documentElement;
                i.appendChild(e);
                var n = o(e);
                s.isBoxSizeOuter = r = 200 == t(n.width),
                    i.removeChild(e)
            }
        }
        function s(e) {
            if (n(),
                "string" == typeof e && (e = document.querySelector(e)),
                e && "object" == typeof e && e.nodeType) {
                var s = o(e);
                if ("none" == s.display)
                    return i();
                var a = {};
                a.width = e.offsetWidth,
                    a.height = e.offsetHeight;
                for (var d = a.isBorderBox = "border-box" == s.boxSizing, l = 0; l < h; l++) {
                    var f = u[l]
                        , c = s[f]
                        , m = parseFloat(c);
                    a[f] = isNaN(m) ? 0 : m
                }
                var p = a.paddingLeft + a.paddingRight
                    , y = a.paddingTop + a.paddingBottom
                    , g = a.marginLeft + a.marginRight
                    , v = a.marginTop + a.marginBottom
                    , _ = a.borderLeftWidth + a.borderRightWidth
                    , I = a.borderTopWidth + a.borderBottomWidth
                    , z = d && r
                    , x = t(s.width);
                x !== !1 && (a.width = x + (z ? 0 : p + _));
                var S = t(s.height);
                return S !== !1 && (a.height = S + (z ? 0 : y + I)),
                    a.innerWidth = a.width - (p + _),
                    a.innerHeight = a.height - (y + I),
                    a.outerWidth = a.width + g,
                    a.outerHeight = a.height + v,
                    a
            }
        }
        var r, a = "undefined" == typeof console ? e : function (t) {
            console.error(t)
        }
            , u = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"], h = u.length, d = !1;
        return s
    }),
    function (t, e) {
        "use strict";
        "function" == typeof define && define.amd ? define("desandro-matches-selector/matches-selector", e) : "object" == typeof module && module.exports ? module.exports = e() : t.matchesSelector = e()
    }(window, function () {
        "use strict";
        var t = function () {
            var t = window.Element.prototype;
            if (t.matches)
                return "matches";
            if (t.matchesSelector)
                return "matchesSelector";
            for (var e = ["webkit", "moz", "ms", "o"], i = 0; i < e.length; i++) {
                var o = e[i]
                    , n = o + "MatchesSelector";
                if (t[n])
                    return n
            }
        }();
        return function (e, i) {
            return e[t](i)
        }
    }),
    function (t, e) {
        "function" == typeof define && define.amd ? define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], function (i) {
            return e(t, i)
        }) : "object" == typeof module && module.exports ? module.exports = e(t, require("desandro-matches-selector")) : t.fizzyUIUtils = e(t, t.matchesSelector)
    }(window, function (t, e) {
        var i = {};
        i.extend = function (t, e) {
            for (var i in e)
                t[i] = e[i];
            return t
        }
            ,
            i.modulo = function (t, e) {
                return (t % e + e) % e
            }
            ,
            i.makeArray = function (t) {
                var e = [];
                if (Array.isArray(t))
                    e = t;
                else if (t && "object" == typeof t && "number" == typeof t.length)
                    for (var i = 0; i < t.length; i++)
                        e.push(t[i]);
                else
                    e.push(t);
                return e
            }
            ,
            i.removeFrom = function (t, e) {
                var i = t.indexOf(e);
                i != -1 && t.splice(i, 1)
            }
            ,
            i.getParent = function (t, i) {
                for (; t.parentNode && t != document.body;)
                    if (t = t.parentNode,
                        e(t, i))
                        return t
            }
            ,
            i.getQueryElement = function (t) {
                return "string" == typeof t ? document.querySelector(t) : t
            }
            ,
            i.handleEvent = function (t) {
                var e = "on" + t.type;
                this[e] && this[e](t)
            }
            ,
            i.filterFindElements = function (t, o) {
                t = i.makeArray(t);
                var n = [];
                return t.forEach(function (t) {
                    if (t instanceof HTMLElement) {
                        if (!o)
                            return void n.push(t);
                        e(t, o) && n.push(t);
                        for (var i = t.querySelectorAll(o), s = 0; s < i.length; s++)
                            n.push(i[s])
                    }
                }),
                    n
            }
            ,
            i.debounceMethod = function (t, e, i) {
                var o = t.prototype[e]
                    , n = e + "Timeout";
                t.prototype[e] = function () {
                    var t = this[n];
                    t && clearTimeout(t);
                    var e = arguments
                        , s = this;
                    this[n] = setTimeout(function () {
                        o.apply(s, e),
                            delete s[n]
                    }, i || 100)
                }
            }
            ,
            i.docReady = function (t) {
                var e = document.readyState;
                "complete" == e || "interactive" == e ? setTimeout(t) : document.addEventListener("DOMContentLoaded", t)
            }
            ,
            i.toDashed = function (t) {
                return t.replace(/(.)([A-Z])/g, function (t, e, i) {
                    return e + "-" + i
                }).toLowerCase()
            }
            ;
        var o = t.console;
        return i.htmlInit = function (e, n) {
            i.docReady(function () {
                var s = i.toDashed(n)
                    , r = "data-" + s
                    , a = document.querySelectorAll("[" + r + "]")
                    , u = document.querySelectorAll(".js-" + s)
                    , h = i.makeArray(a).concat(i.makeArray(u))
                    , d = r + "-options"
                    , l = t.jQuery;
                h.forEach(function (t) {
                    var i, s = t.getAttribute(r) || t.getAttribute(d);
                    try {
                        i = s && JSON.parse(s)
                    } catch (a) {
                        return void (o && o.error("Error parsing " + r + " on " + t.className + ": " + a))
                    }
                    var u = new e(t, i);
                    l && l.data(t, n, u)
                })
            })
        }
            ,
            i
    }),
    function (t, e) {
        "function" == typeof define && define.amd ? define("outlayer/item", ["ev-emitter/ev-emitter", "get-size/get-size"], e) : "object" == typeof module && module.exports ? module.exports = e(require("ev-emitter"), require("get-size")) : (t.Outlayer = {},
            t.Outlayer.Item = e(t.EvEmitter, t.getSize))
    }(window, function (t, e) {
        "use strict";
        function i(t) {
            for (var e in t)
                return !1;
            return e = null,
                !0
        }
        function o(t, e) {
            t && (this.element = t,
                this.layout = e,
                this.position = {
                    x: 0,
                    y: 0
                },
                this._create())
        }
        function n(t) {
            return t.replace(/([A-Z])/g, function (t) {
                return "-" + t.toLowerCase()
            })
        }
        var s = document.documentElement.style
            , r = "string" == typeof s.transition ? "transition" : "WebkitTransition"
            , a = "string" == typeof s.transform ? "transform" : "WebkitTransform"
            , u = {
                WebkitTransition: "webkitTransitionEnd",
                transition: "transitionend"
            }[r]
            , h = {
                transform: a,
                transition: r,
                transitionDuration: r + "Duration",
                transitionProperty: r + "Property",
                transitionDelay: r + "Delay"
            }
            , d = o.prototype = Object.create(t.prototype);
        d.constructor = o,
            d._create = function () {
                this._transn = {
                    ingProperties: {},
                    clean: {},
                    onEnd: {}
                },
                    this.css({
                        position: "absolute"
                    })
            }
            ,
            d.handleEvent = function (t) {
                var e = "on" + t.type;
                this[e] && this[e](t)
            }
            ,
            d.getSize = function () {
                this.size = e(this.element)
            }
            ,
            d.css = function (t) {
                var e = this.element.style;
                for (var i in t) {
                    var o = h[i] || i;
                    e[o] = t[i]
                }
            }
            ,
            d.getPosition = function () {
                var t = getComputedStyle(this.element)
                    , e = this.layout._getOption("originLeft")
                    , i = this.layout._getOption("originTop")
                    , o = t[e ? "left" : "right"]
                    , n = t[i ? "top" : "bottom"]
                    , s = this.layout.size
                    , r = o.indexOf("%") != -1 ? parseFloat(o) / 100 * s.width : parseInt(o, 10)
                    , a = n.indexOf("%") != -1 ? parseFloat(n) / 100 * s.height : parseInt(n, 10);
                r = isNaN(r) ? 0 : r,
                    a = isNaN(a) ? 0 : a,
                    r -= e ? s.paddingLeft : s.paddingRight,
                    a -= i ? s.paddingTop : s.paddingBottom,
                    this.position.x = r,
                    this.position.y = a
            }
            ,
            d.layoutPosition = function () {
                var t = this.layout.size
                    , e = {}
                    , i = this.layout._getOption("originLeft")
                    , o = this.layout._getOption("originTop")
                    , n = i ? "paddingLeft" : "paddingRight"
                    , s = i ? "left" : "right"
                    , r = i ? "right" : "left"
                    , a = this.position.x + t[n];
                e[s] = this.getXValue(a),
                    e[r] = "";
                var u = o ? "paddingTop" : "paddingBottom"
                    , h = o ? "top" : "bottom"
                    , d = o ? "bottom" : "top"
                    , l = this.position.y + t[u];
                e[h] = this.getYValue(l),
                    e[d] = "",
                    this.css(e),
                    this.emitEvent("layout", [this])
            }
            ,
            d.getXValue = function (t) {
                var e = this.layout._getOption("horizontal");
                return this.layout.options.percentPosition && !e ? t / this.layout.size.width * 100 + "%" : t + "px"
            }
            ,
            d.getYValue = function (t) {
                var e = this.layout._getOption("horizontal");
                return this.layout.options.percentPosition && e ? t / this.layout.size.height * 100 + "%" : t + "px"
            }
            ,
            d._transitionTo = function (t, e) {
                this.getPosition();
                var i = this.position.x
                    , o = this.position.y
                    , n = parseInt(t, 10)
                    , s = parseInt(e, 10)
                    , r = n === this.position.x && s === this.position.y;
                if (this.setPosition(t, e),
                    r && !this.isTransitioning)
                    return void this.layoutPosition();
                var a = t - i
                    , u = e - o
                    , h = {};
                h.transform = this.getTranslate(a, u),
                    this.transition({
                        to: h,
                        onTransitionEnd: {
                            transform: this.layoutPosition
                        },
                        isCleaning: !0
                    })
            }
            ,
            d.getTranslate = function (t, e) {
                var i = this.layout._getOption("originLeft")
                    , o = this.layout._getOption("originTop");
                return t = i ? t : -t,
                    e = o ? e : -e,
                    "translate3d(" + t + "px, " + e + "px, 0)"
            }
            ,
            d.goTo = function (t, e) {
                this.setPosition(t, e),
                    this.layoutPosition()
            }
            ,
            d.moveTo = d._transitionTo,
            d.setPosition = function (t, e) {
                this.position.x = parseInt(t, 10),
                    this.position.y = parseInt(e, 10)
            }
            ,
            d._nonTransition = function (t) {
                this.css(t.to),
                    t.isCleaning && this._removeStyles(t.to);
                for (var e in t.onTransitionEnd)
                    t.onTransitionEnd[e].call(this)
            }
            ,
            d.transition = function (t) {
                if (!parseFloat(this.layout.options.transitionDuration))
                    return void this._nonTransition(t);
                var e = this._transn;
                for (var i in t.onTransitionEnd)
                    e.onEnd[i] = t.onTransitionEnd[i];
                for (i in t.to)
                    e.ingProperties[i] = !0,
                        t.isCleaning && (e.clean[i] = !0);
                if (t.from) {
                    this.css(t.from);
                    var o = this.element.offsetHeight;
                    o = null
                }
                this.enableTransition(t.to),
                    this.css(t.to),
                    this.isTransitioning = !0
            }
            ;
        var l = "opacity," + n(a);
        d.enableTransition = function () {
            if (!this.isTransitioning) {
                var t = this.layout.options.transitionDuration;
                t = "number" == typeof t ? t + "ms" : t,
                    this.css({
                        transitionProperty: l,
                        transitionDuration: t,
                        transitionDelay: this.staggerDelay || 0
                    }),
                    this.element.addEventListener(u, this, !1)
            }
        }
            ,
            d.onwebkitTransitionEnd = function (t) {
                this.ontransitionend(t)
            }
            ,
            d.onotransitionend = function (t) {
                this.ontransitionend(t)
            }
            ;
        var f = {
            "-webkit-transform": "transform"
        };
        d.ontransitionend = function (t) {
            if (t.target === this.element) {
                var e = this._transn
                    , o = f[t.propertyName] || t.propertyName;
                if (delete e.ingProperties[o],
                    i(e.ingProperties) && this.disableTransition(),
                    o in e.clean && (this.element.style[t.propertyName] = "",
                        delete e.clean[o]),
                    o in e.onEnd) {
                    var n = e.onEnd[o];
                    n.call(this),
                        delete e.onEnd[o]
                }
                this.emitEvent("transitionEnd", [this])
            }
        }
            ,
            d.disableTransition = function () {
                this.removeTransitionStyles(),
                    this.element.removeEventListener(u, this, !1),
                    this.isTransitioning = !1
            }
            ,
            d._removeStyles = function (t) {
                var e = {};
                for (var i in t)
                    e[i] = "";
                this.css(e)
            }
            ;
        var c = {
            transitionProperty: "",
            transitionDuration: "",
            transitionDelay: ""
        };
        return d.removeTransitionStyles = function () {
            this.css(c)
        }
            ,
            d.stagger = function (t) {
                t = isNaN(t) ? 0 : t,
                    this.staggerDelay = t + "ms"
            }
            ,
            d.removeElem = function () {
                this.element.parentNode.removeChild(this.element),
                    this.css({
                        display: ""
                    }),
                    this.emitEvent("remove", [this])
            }
            ,
            d.remove = function () {
                return r && parseFloat(this.layout.options.transitionDuration) ? (this.once("transitionEnd", function () {
                    this.removeElem()
                }),
                    void this.hide()) : void this.removeElem()
            }
            ,
            d.reveal = function () {
                delete this.isHidden,
                    this.css({
                        display: ""
                    });
                var t = this.layout.options
                    , e = {}
                    , i = this.getHideRevealTransitionEndProperty("visibleStyle");
                e[i] = this.onRevealTransitionEnd,
                    this.transition({
                        from: t.hiddenStyle,
                        to: t.visibleStyle,
                        isCleaning: !0,
                        onTransitionEnd: e
                    })
            }
            ,
            d.onRevealTransitionEnd = function () {
                this.isHidden || this.emitEvent("reveal")
            }
            ,
            d.getHideRevealTransitionEndProperty = function (t) {
                var e = this.layout.options[t];
                if (e.opacity)
                    return "opacity";
                for (var i in e)
                    return i
            }
            ,
            d.hide = function () {
                this.isHidden = !0,
                    this.css({
                        display: ""
                    });
                var t = this.layout.options
                    , e = {}
                    , i = this.getHideRevealTransitionEndProperty("hiddenStyle");
                e[i] = this.onHideTransitionEnd,
                    this.transition({
                        from: t.visibleStyle,
                        to: t.hiddenStyle,
                        isCleaning: !0,
                        onTransitionEnd: e
                    })
            }
            ,
            d.onHideTransitionEnd = function () {
                this.isHidden && (this.css({
                    display: "none"
                }),
                    this.emitEvent("hide"))
            }
            ,
            d.destroy = function () {
                this.css({
                    position: "",
                    left: "",
                    right: "",
                    top: "",
                    bottom: "",
                    transition: "",
                    transform: ""
                })
            }
            ,
            o
    }),
    function (t, e) {
        "use strict";
        "function" == typeof define && define.amd ? define("outlayer/outlayer", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item"], function (i, o, n, s) {
            return e(t, i, o, n, s)
        }) : "object" == typeof module && module.exports ? module.exports = e(t, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./item")) : t.Outlayer = e(t, t.EvEmitter, t.getSize, t.fizzyUIUtils, t.Outlayer.Item)
    }(window, function (t, e, i, o, n) {
        "use strict";
        function s(t, e) {
            var i = o.getQueryElement(t);
            if (!i)
                return void (u && u.error("Bad element for " + this.constructor.namespace + ": " + (i || t)));
            this.element = i,
                h && (this.$element = h(this.element)),
                this.options = o.extend({}, this.constructor.defaults),
                this.option(e);
            var n = ++l;
            this.element.outlayerGUID = n,
                f[n] = this,
                this._create();
            var s = this._getOption("initLayout");
            s && this.layout()
        }
        function r(t) {
            function e() {
                t.apply(this, arguments)
            }
            return e.prototype = Object.create(t.prototype),
                e.prototype.constructor = e,
                e
        }
        function a(t) {
            if ("number" == typeof t)
                return t;
            var e = t.match(/(^\d*\.?\d*)(\w*)/)
                , i = e && e[1]
                , o = e && e[2];
            if (!i.length)
                return 0;
            i = parseFloat(i);
            var n = m[o] || 1;
            return i * n
        }
        var u = t.console
            , h = t.jQuery
            , d = function () { }
            , l = 0
            , f = {};
        s.namespace = "outlayer",
            s.Item = n,
            s.defaults = {
                containerStyle: {
                    position: "relative"
                },
                initLayout: !0,
                originLeft: !0,
                originTop: !0,
                resize: !0,
                resizeContainer: !0,
                transitionDuration: "0.4s",
                hiddenStyle: {
                    opacity: 0,
                    transform: "scale(0.001)"
                },
                visibleStyle: {
                    opacity: 1,
                    transform: "scale(1)"
                }
            };
        var c = s.prototype;
        o.extend(c, e.prototype),
            c.option = function (t) {
                o.extend(this.options, t)
            }
            ,
            c._getOption = function (t) {
                var e = this.constructor.compatOptions[t];
                return e && void 0 !== this.options[e] ? this.options[e] : this.options[t]
            }
            ,
            s.compatOptions = {
                initLayout: "isInitLayout",
                horizontal: "isHorizontal",
                layoutInstant: "isLayoutInstant",
                originLeft: "isOriginLeft",
                originTop: "isOriginTop",
                resize: "isResizeBound",
                resizeContainer: "isResizingContainer"
            },
            c._create = function () {
                this.reloadItems(),
                    this.stamps = [],
                    this.stamp(this.options.stamp),
                    o.extend(this.element.style, this.options.containerStyle);
                var t = this._getOption("resize");
                t && this.bindResize()
            }
            ,
            c.reloadItems = function () {
                this.items = this._itemize(this.element.children)
            }
            ,
            c._itemize = function (t) {
                for (var e = this._filterFindItemElements(t), i = this.constructor.Item, o = [], n = 0; n < e.length; n++) {
                    var s = e[n]
                        , r = new i(s, this);
                    o.push(r)
                }
                return o
            }
            ,
            c._filterFindItemElements = function (t) {
                return o.filterFindElements(t, this.options.itemSelector)
            }
            ,
            c.getItemElements = function () {
                return this.items.map(function (t) {
                    return t.element
                })
            }
            ,
            c.layout = function () {
                this._resetLayout(),
                    this._manageStamps();
                var t = this._getOption("layoutInstant")
                    , e = void 0 !== t ? t : !this._isLayoutInited;
                this.layoutItems(this.items, e),
                    this._isLayoutInited = !0
            }
            ,
            c._init = c.layout,
            c._resetLayout = function () {
                this.getSize()
            }
            ,
            c.getSize = function () {
                this.size = i(this.element)
            }
            ,
            c._getMeasurement = function (t, e) {
                var o, n = this.options[t];
                n ? ("string" == typeof n ? o = this.element.querySelector(n) : n instanceof HTMLElement && (o = n),
                    this[t] = o ? i(o)[e] : n) : this[t] = 0
            }
            ,
            c.layoutItems = function (t, e) {
                t = this._getItemsForLayout(t),
                    this._layoutItems(t, e),
                    this._postLayout()
            }
            ,
            c._getItemsForLayout = function (t) {
                return t.filter(function (t) {
                    return !t.isIgnored
                })
            }
            ,
            c._layoutItems = function (t, e) {
                if (this._emitCompleteOnItems("layout", t),
                    t && t.length) {
                    var i = [];
                    t.forEach(function (t) {
                        var o = this._getItemLayoutPosition(t);
                        o.item = t,
                            o.isInstant = e || t.isLayoutInstant,
                            i.push(o)
                    }, this),
                        this._processLayoutQueue(i)
                }
            }
            ,
            c._getItemLayoutPosition = function () {
                return {
                    x: 0,
                    y: 0
                }
            }
            ,
            c._processLayoutQueue = function (t) {
                this.updateStagger(),
                    t.forEach(function (t, e) {
                        this._positionItem(t.item, t.x, t.y, t.isInstant, e)
                    }, this)
            }
            ,
            c.updateStagger = function () {
                var t = this.options.stagger;
                return null === t || void 0 === t ? void (this.stagger = 0) : (this.stagger = a(t),
                    this.stagger)
            }
            ,
            c._positionItem = function (t, e, i, o, n) {
                o ? t.goTo(e, i) : (t.stagger(n * this.stagger),
                    t.moveTo(e, i))
            }
            ,
            c._postLayout = function () {
                this.resizeContainer()
            }
            ,
            c.resizeContainer = function () {
                var t = this._getOption("resizeContainer");
                if (t) {
                    var e = this._getContainerSize();
                    e && (this._setContainerMeasure(e.width, !0),
                        this._setContainerMeasure(e.height, !1))
                }
            }
            ,
            c._getContainerSize = d,
            c._setContainerMeasure = function (t, e) {
                if (void 0 !== t) {
                    var i = this.size;
                    i.isBorderBox && (t += e ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth),
                        t = Math.max(t, 0),
                        this.element.style[e ? "width" : "height"] = t + "px"
                }
            }
            ,
            c._emitCompleteOnItems = function (t, e) {
                function i() {
                    n.dispatchEvent(t + "Complete", null, [e])
                }
                function o() {
                    r++ ,
                        r == s && i()
                }
                var n = this
                    , s = e.length;
                if (!e || !s)
                    return void i();
                var r = 0;
                e.forEach(function (e) {
                    e.once(t, o)
                })
            }
            ,
            c.dispatchEvent = function (t, e, i) {
                var o = e ? [e].concat(i) : i;
                if (this.emitEvent(t, o),
                    h)
                    if (this.$element = this.$element || h(this.element),
                        e) {
                        var n = h.Event(e);
                        n.type = t,
                            this.$element.trigger(n, i)
                    } else
                        this.$element.trigger(t, i)
            }
            ,
            c.ignore = function (t) {
                var e = this.getItem(t);
                e && (e.isIgnored = !0)
            }
            ,
            c.unignore = function (t) {
                var e = this.getItem(t);
                e && delete e.isIgnored
            }
            ,
            c.stamp = function (t) {
                t = this._find(t),
                    t && (this.stamps = this.stamps.concat(t),
                        t.forEach(this.ignore, this))
            }
            ,
            c.unstamp = function (t) {
                t = this._find(t),
                    t && t.forEach(function (t) {
                        o.removeFrom(this.stamps, t),
                            this.unignore(t)
                    }, this)
            }
            ,
            c._find = function (t) {
                if (t)
                    return "string" == typeof t && (t = this.element.querySelectorAll(t)),
                        t = o.makeArray(t)
            }
            ,
            c._manageStamps = function () {
                this.stamps && this.stamps.length && (this._getBoundingRect(),
                    this.stamps.forEach(this._manageStamp, this))
            }
            ,
            c._getBoundingRect = function () {
                var t = this.element.getBoundingClientRect()
                    , e = this.size;
                this._boundingRect = {
                    left: t.left + e.paddingLeft + e.borderLeftWidth,
                    top: t.top + e.paddingTop + e.borderTopWidth,
                    right: t.right - (e.paddingRight + e.borderRightWidth),
                    bottom: t.bottom - (e.paddingBottom + e.borderBottomWidth)
                }
            }
            ,
            c._manageStamp = d,
            c._getElementOffset = function (t) {
                var e = t.getBoundingClientRect()
                    , o = this._boundingRect
                    , n = i(t)
                    , s = {
                        left: e.left - o.left - n.marginLeft,
                        top: e.top - o.top - n.marginTop,
                        right: o.right - e.right - n.marginRight,
                        bottom: o.bottom - e.bottom - n.marginBottom
                    };
                return s
            }
            ,
            c.handleEvent = o.handleEvent,
            c.bindResize = function () {
                t.addEventListener("resize", this),
                    this.isResizeBound = !0
            }
            ,
            c.unbindResize = function () {
                t.removeEventListener("resize", this),
                    this.isResizeBound = !1
            }
            ,
            c.onresize = function () {
                this.resize()
            }
            ,
            o.debounceMethod(s, "onresize", 100),
            c.resize = function () {
                this.isResizeBound && this.needsResizeLayout() && this.layout()
            }
            ,
            c.needsResizeLayout = function () {
                var t = i(this.element)
                    , e = this.size && t;
                return e && t.innerWidth !== this.size.innerWidth
            }
            ,
            c.addItems = function (t) {
                var e = this._itemize(t);
                return e.length && (this.items = this.items.concat(e)),
                    e
            }
            ,
            c.appended = function (t) {
                var e = this.addItems(t);
                e.length && (this.layoutItems(e, !0),
                    this.reveal(e))
            }
            ,
            c.prepended = function (t) {
                var e = this._itemize(t);
                if (e.length) {
                    var i = this.items.slice(0);
                    this.items = e.concat(i),
                        this._resetLayout(),
                        this._manageStamps(),
                        this.layoutItems(e, !0),
                        this.reveal(e),
                        this.layoutItems(i)
                }
            }
            ,
            c.reveal = function (t) {
                if (this._emitCompleteOnItems("reveal", t),
                    t && t.length) {
                    var e = this.updateStagger();
                    t.forEach(function (t, i) {
                        t.stagger(i * e),
                            t.reveal()
                    })
                }
            }
            ,
            c.hide = function (t) {
                if (this._emitCompleteOnItems("hide", t),
                    t && t.length) {
                    var e = this.updateStagger();
                    t.forEach(function (t, i) {
                        t.stagger(i * e),
                            t.hide()
                    })
                }
            }
            ,
            c.revealItemElements = function (t) {
                var e = this.getItems(t);
                this.reveal(e)
            }
            ,
            c.hideItemElements = function (t) {
                var e = this.getItems(t);
                this.hide(e)
            }
            ,
            c.getItem = function (t) {
                for (var e = 0; e < this.items.length; e++) {
                    var i = this.items[e];
                    if (i.element == t)
                        return i
                }
            }
            ,
            c.getItems = function (t) {
                t = o.makeArray(t);
                var e = [];
                return t.forEach(function (t) {
                    var i = this.getItem(t);
                    i && e.push(i)
                }, this),
                    e
            }
            ,
            c.remove = function (t) {
                var e = this.getItems(t);
                this._emitCompleteOnItems("remove", e),
                    e && e.length && e.forEach(function (t) {
                        t.remove(),
                            o.removeFrom(this.items, t)
                    }, this)
            }
            ,
            c.destroy = function () {
                var t = this.element.style;
                t.height = "",
                    t.position = "",
                    t.width = "",
                    this.items.forEach(function (t) {
                        t.destroy()
                    }),
                    this.unbindResize();
                var e = this.element.outlayerGUID;
                delete f[e],
                    delete this.element.outlayerGUID,
                    h && h.removeData(this.element, this.constructor.namespace)
            }
            ,
            s.data = function (t) {
                t = o.getQueryElement(t);
                var e = t && t.outlayerGUID;
                return e && f[e]
            }
            ,
            s.create = function (t, e) {
                var i = r(s);
                return i.defaults = o.extend({}, s.defaults),
                    o.extend(i.defaults, e),
                    i.compatOptions = o.extend({}, s.compatOptions),
                    i.namespace = t,
                    i.data = s.data,
                    i.Item = r(n),
                    o.htmlInit(i, t),
                    h && h.bridget && h.bridget(t, i),
                    i
            }
            ;
        var m = {
            ms: 1,
            s: 1e3
        };
        return s.Item = n,
            s
    }),
    function (t, e) {
        "function" == typeof define && define.amd ? define("isotope/js/item", ["outlayer/outlayer"], e) : "object" == typeof module && module.exports ? module.exports = e(require("outlayer")) : (t.Isotope = t.Isotope || {},
            t.Isotope.Item = e(t.Outlayer))
    }(window, function (t) {
        "use strict";
        function e() {
            t.Item.apply(this, arguments)
        }
        var i = e.prototype = Object.create(t.Item.prototype)
            , o = i._create;
        i._create = function () {
            this.id = this.layout.itemGUID++ ,
                o.call(this),
                this.sortData = {}
        }
            ,
            i.updateSortData = function () {
                if (!this.isIgnored) {
                    this.sortData.id = this.id,
                        this.sortData["original-order"] = this.id,
                        this.sortData.random = Math.random();
                    var t = this.layout.options.getSortData
                        , e = this.layout._sorters;
                    for (var i in t) {
                        var o = e[i];
                        this.sortData[i] = o(this.element, this)
                    }
                }
            }
            ;
        var n = i.destroy;
        return i.destroy = function () {
            n.apply(this, arguments),
                this.css({
                    display: ""
                })
        }
            ,
            e
    }),
    function (t, e) {
        "function" == typeof define && define.amd ? define("isotope/js/layout-mode", ["get-size/get-size", "outlayer/outlayer"], e) : "object" == typeof module && module.exports ? module.exports = e(require("get-size"), require("outlayer")) : (t.Isotope = t.Isotope || {},
            t.Isotope.LayoutMode = e(t.getSize, t.Outlayer))
    }(window, function (t, e) {
        "use strict";
        function i(t) {
            this.isotope = t,
                t && (this.options = t.options[this.namespace],
                    this.element = t.element,
                    this.items = t.filteredItems,
                    this.size = t.size)
        }
        var o = i.prototype
            , n = ["_resetLayout", "_getItemLayoutPosition", "_manageStamp", "_getContainerSize", "_getElementOffset", "needsResizeLayout", "_getOption"];
        return n.forEach(function (t) {
            o[t] = function () {
                return e.prototype[t].apply(this.isotope, arguments)
            }
        }),
            o.needsVerticalResizeLayout = function () {
                var e = t(this.isotope.element)
                    , i = this.isotope.size && e;
                return i && e.innerHeight != this.isotope.size.innerHeight
            }
            ,
            o._getMeasurement = function () {
                this.isotope._getMeasurement.apply(this, arguments)
            }
            ,
            o.getColumnWidth = function () {
                this.getSegmentSize("column", "Width")
            }
            ,
            o.getRowHeight = function () {
                this.getSegmentSize("row", "Height")
            }
            ,
            o.getSegmentSize = function (t, e) {
                var i = t + e
                    , o = "outer" + e;
                if (this._getMeasurement(i, o),
                    !this[i]) {
                    var n = this.getFirstItemSize();
                    this[i] = n && n[o] || this.isotope.size["inner" + e]
                }
            }
            ,
            o.getFirstItemSize = function () {
                var e = this.isotope.filteredItems[0];
                return e && e.element && t(e.element)
            }
            ,
            o.layout = function () {
                this.isotope.layout.apply(this.isotope, arguments)
            }
            ,
            o.getSize = function () {
                this.isotope.getSize(),
                    this.size = this.isotope.size
            }
            ,
            i.modes = {},
            i.create = function (t, e) {
                function n() {
                    i.apply(this, arguments)
                }
                return n.prototype = Object.create(o),
                    n.prototype.constructor = n,
                    e && (n.options = e),
                    n.prototype.namespace = t,
                    i.modes[t] = n,
                    n
            }
            ,
            i
    }),
    function (t, e) {
        "function" == typeof define && define.amd ? define("masonry/masonry", ["outlayer/outlayer", "get-size/get-size"], e) : "object" == typeof module && module.exports ? module.exports = e(require("outlayer"), require("get-size")) : t.Masonry = e(t.Outlayer, t.getSize)
    }(window, function (t, e) {
        var i = t.create("masonry");
        i.compatOptions.fitWidth = "isFitWidth";
        var o = i.prototype;
        return o._resetLayout = function () {
            this.getSize(),
                this._getMeasurement("columnWidth", "outerWidth"),
                this._getMeasurement("gutter", "outerWidth"),
                this.measureColumns(),
                this.colYs = [];
            for (var t = 0; t < this.cols; t++)
                this.colYs.push(0);
            this.maxY = 0,
                this.horizontalColIndex = 0
        }
            ,
            o.measureColumns = function () {
                if (this.getContainerWidth(),
                    !this.columnWidth) {
                    var t = this.items[0]
                        , i = t && t.element;
                    this.columnWidth = i && e(i).outerWidth || this.containerWidth
                }
                var o = this.columnWidth += this.gutter
                    , n = this.containerWidth + this.gutter
                    , s = n / o
                    , r = o - n % o
                    , a = r && r < 1 ? "round" : "floor";
                s = Math[a](s),
                    this.cols = Math.max(s, 1)
            }
            ,
            o.getContainerWidth = function () {
                var t = this._getOption("fitWidth")
                    , i = t ? this.element.parentNode : this.element
                    , o = e(i);
                this.containerWidth = o && o.innerWidth
            }
            ,
            o._getItemLayoutPosition = function (t) {
                t.getSize();
                var e = t.size.outerWidth % this.columnWidth
                    , i = e && e < 1 ? "round" : "ceil"
                    , o = Math[i](t.size.outerWidth / this.columnWidth);
                o = Math.min(o, this.cols);
                for (var n = this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition", s = this[n](o, t), r = {
                    x: this.columnWidth * s.col,
                    y: s.y
                }, a = s.y + t.size.outerHeight, u = o + s.col, h = s.col; h < u; h++)
                    this.colYs[h] = a;
                return r
            }
            ,
            o._getTopColPosition = function (t) {
                var e = this._getTopColGroup(t)
                    , i = Math.min.apply(Math, e);
                return {
                    col: e.indexOf(i),
                    y: i
                }
            }
            ,
            o._getTopColGroup = function (t) {
                if (t < 2)
                    return this.colYs;
                for (var e = [], i = this.cols + 1 - t, o = 0; o < i; o++)
                    e[o] = this._getColGroupY(o, t);
                return e
            }
            ,
            o._getColGroupY = function (t, e) {
                if (e < 2)
                    return this.colYs[t];
                var i = this.colYs.slice(t, t + e);
                return Math.max.apply(Math, i)
            }
            ,
            o._getHorizontalColPosition = function (t, e) {
                var i = this.horizontalColIndex % this.cols
                    , o = t > 1 && i + t > this.cols;
                i = o ? 0 : i;
                var n = e.size.outerWidth && e.size.outerHeight;
                return this.horizontalColIndex = n ? i + t : this.horizontalColIndex,
                    {
                        col: i,
                        y: this._getColGroupY(i, t)
                    }
            }
            ,
            o._manageStamp = function (t) {
                var i = e(t)
                    , o = this._getElementOffset(t)
                    , n = this._getOption("originLeft")
                    , s = n ? o.left : o.right
                    , r = s + i.outerWidth
                    , a = Math.floor(s / this.columnWidth);
                a = Math.max(0, a);
                var u = Math.floor(r / this.columnWidth);
                u -= r % this.columnWidth ? 0 : 1,
                    u = Math.min(this.cols - 1, u);
                for (var h = this._getOption("originTop"), d = (h ? o.top : o.bottom) + i.outerHeight, l = a; l <= u; l++)
                    this.colYs[l] = Math.max(d, this.colYs[l])
            }
            ,
            o._getContainerSize = function () {
                this.maxY = Math.max.apply(Math, this.colYs);
                var t = {
                    height: this.maxY
                };
                return this._getOption("fitWidth") && (t.width = this._getContainerFitWidth()),
                    t
            }
            ,
            o._getContainerFitWidth = function () {
                for (var t = 0, e = this.cols; --e && 0 === this.colYs[e];)
                    t++;
                return (this.cols - t) * this.columnWidth - this.gutter
            }
            ,
            o.needsResizeLayout = function () {
                var t = this.containerWidth;
                return this.getContainerWidth(),
                    t != this.containerWidth
            }
            ,
            i
    }),
    function (t, e) {
        "function" == typeof define && define.amd ? define("isotope/js/layout-modes/masonry", ["../layout-mode", "masonry/masonry"], e) : "object" == typeof module && module.exports ? module.exports = e(require("../layout-mode"), require("masonry-layout")) : e(t.Isotope.LayoutMode, t.Masonry)
    }(window, function (t, e) {
        "use strict";
        var i = t.create("masonry")
            , o = i.prototype
            , n = {
                _getElementOffset: !0,
                layout: !0,
                _getMeasurement: !0
            };
        for (var s in e.prototype)
            n[s] || (o[s] = e.prototype[s]);
        var r = o.measureColumns;
        o.measureColumns = function () {
            this.items = this.isotope.filteredItems,
                r.call(this)
        }
            ;
        var a = o._getOption;
        return o._getOption = function (t) {
            return "fitWidth" == t ? void 0 !== this.options.isFitWidth ? this.options.isFitWidth : this.options.fitWidth : a.apply(this.isotope, arguments)
        }
            ,
            i
    }),
    function (t, e) {
        "function" == typeof define && define.amd ? define("isotope/js/layout-modes/fit-rows", ["../layout-mode"], e) : "object" == typeof exports ? module.exports = e(require("../layout-mode")) : e(t.Isotope.LayoutMode)
    }(window, function (t) {
        "use strict";
        var e = t.create("fitRows")
            , i = e.prototype;
        return i._resetLayout = function () {
            this.x = 0,
                this.y = 0,
                this.maxY = 0,
                this._getMeasurement("gutter", "outerWidth")
        }
            ,
            i._getItemLayoutPosition = function (t) {
                t.getSize();
                var e = t.size.outerWidth + this.gutter
                    , i = this.isotope.size.innerWidth + this.gutter;
                0 !== this.x && e + this.x > i && (this.x = 0,
                    this.y = this.maxY);
                var o = {
                    x: this.x,
                    y: this.y
                };
                return this.maxY = Math.max(this.maxY, this.y + t.size.outerHeight),
                    this.x += e,
                    o
            }
            ,
            i._getContainerSize = function () {
                return {
                    height: this.maxY
                }
            }
            ,
            e
    }),
    function (t, e) {
        "function" == typeof define && define.amd ? define("isotope/js/layout-modes/vertical", ["../layout-mode"], e) : "object" == typeof module && module.exports ? module.exports = e(require("../layout-mode")) : e(t.Isotope.LayoutMode)
    }(window, function (t) {
        "use strict";
        var e = t.create("vertical", {
            horizontalAlignment: 0
        })
            , i = e.prototype;
        return i._resetLayout = function () {
            this.y = 0
        }
            ,
            i._getItemLayoutPosition = function (t) {
                t.getSize();
                var e = (this.isotope.size.innerWidth - t.size.outerWidth) * this.options.horizontalAlignment
                    , i = this.y;
                return this.y += t.size.outerHeight,
                    {
                        x: e,
                        y: i
                    }
            }
            ,
            i._getContainerSize = function () {
                return {
                    height: this.y
                }
            }
            ,
            e
    }),
    function (t, e) {
        "function" == typeof define && define.amd ? define(["outlayer/outlayer", "get-size/get-size", "desandro-matches-selector/matches-selector", "fizzy-ui-utils/utils", "isotope/js/item", "isotope/js/layout-mode", "isotope/js/layout-modes/masonry", "isotope/js/layout-modes/fit-rows", "isotope/js/layout-modes/vertical"], function (i, o, n, s, r, a) {
            return e(t, i, o, n, s, r, a)
        }) : "object" == typeof module && module.exports ? module.exports = e(t, require("outlayer"), require("get-size"), require("desandro-matches-selector"), require("fizzy-ui-utils"), require("isotope/js/item"), require("isotope/js/layout-mode"), require("isotope/js/layout-modes/masonry"), require("isotope/js/layout-modes/fit-rows"), require("isotope/js/layout-modes/vertical")) : t.Isotope = e(t, t.Outlayer, t.getSize, t.matchesSelector, t.fizzyUIUtils, t.Isotope.Item, t.Isotope.LayoutMode)
    }(window, function (t, e, i, o, n, s, r) {
        function a(t, e) {
            return function (i, o) {
                for (var n = 0; n < t.length; n++) {
                    var s = t[n]
                        , r = i.sortData[s]
                        , a = o.sortData[s];
                    if (r > a || r < a) {
                        var u = void 0 !== e[s] ? e[s] : e
                            , h = u ? 1 : -1;
                        return (r > a ? 1 : -1) * h
                    }
                }
                return 0
            }
        }
        var u = t.jQuery
            , h = String.prototype.trim ? function (t) {
                return t.trim()
            }
                : function (t) {
                    return t.replace(/^\s+|\s+$/g, "")
                }
            , d = e.create("isotope", {
                layoutMode: "masonry",
                isJQueryFiltering: !0,
                sortAscending: !0
            });
        d.Item = s,
            d.LayoutMode = r;
        var l = d.prototype;
        l._create = function () {
            this.itemGUID = 0,
                this._sorters = {},
                this._getSorters(),
                e.prototype._create.call(this),
                this.modes = {},
                this.filteredItems = this.items,
                this.sortHistory = ["original-order"];
            for (var t in r.modes)
                this._initLayoutMode(t)
        }
            ,
            l.reloadItems = function () {
                this.itemGUID = 0,
                    e.prototype.reloadItems.call(this)
            }
            ,
            l._itemize = function () {
                for (var t = e.prototype._itemize.apply(this, arguments), i = 0; i < t.length; i++) {
                    var o = t[i];
                    o.id = this.itemGUID++
                }
                return this._updateItemsSortData(t),
                    t
            }
            ,
            l._initLayoutMode = function (t) {
                var e = r.modes[t]
                    , i = this.options[t] || {};
                this.options[t] = e.options ? n.extend(e.options, i) : i,
                    this.modes[t] = new e(this)
            }
            ,
            l.layout = function () {
                return !this._isLayoutInited && this._getOption("initLayout") ? void this.arrange() : void this._layout()
            }
            ,
            l._layout = function () {
                var t = this._getIsInstant();
                this._resetLayout(),
                    this._manageStamps(),
                    this.layoutItems(this.filteredItems, t),
                    this._isLayoutInited = !0
            }
            ,
            l.arrange = function (t) {
                this.option(t),
                    this._getIsInstant();
                var e = this._filter(this.items);
                this.filteredItems = e.matches,
                    this._bindArrangeComplete(),
                    this._isInstant ? this._noTransition(this._hideReveal, [e]) : this._hideReveal(e),
                    this._sort(),
                    this._layout()
            }
            ,
            l._init = l.arrange,
            l._hideReveal = function (t) {
                this.reveal(t.needReveal),
                    this.hide(t.needHide)
            }
            ,
            l._getIsInstant = function () {
                var t = this._getOption("layoutInstant")
                    , e = void 0 !== t ? t : !this._isLayoutInited;
                return this._isInstant = e,
                    e
            }
            ,
            l._bindArrangeComplete = function () {
                function t() {
                    e && i && o && n.dispatchEvent("arrangeComplete", null, [n.filteredItems])
                }
                var e, i, o, n = this;
                this.once("layoutComplete", function () {
                    e = !0,
                        t()
                }),
                    this.once("hideComplete", function () {
                        i = !0,
                            t()
                    }),
                    this.once("revealComplete", function () {
                        o = !0,
                            t()
                    })
            }
            ,
            l._filter = function (t) {
                var e = this.options.filter;
                e = e || "*";
                for (var i = [], o = [], n = [], s = this._getFilterTest(e), r = 0; r < t.length; r++) {
                    var a = t[r];
                    if (!a.isIgnored) {
                        var u = s(a);
                        u && i.push(a),
                            u && a.isHidden ? o.push(a) : u || a.isHidden || n.push(a)
                    }
                }
                return {
                    matches: i,
                    needReveal: o,
                    needHide: n
                }
            }
            ,
            l._getFilterTest = function (t) {
                return u && this.options.isJQueryFiltering ? function (e) {
                    return u(e.element).is(t)
                }
                    : "function" == typeof t ? function (e) {
                        return t(e.element)
                    }
                        : function (e) {
                            return o(e.element, t)
                        }
            }
            ,
            l.updateSortData = function (t) {
                var e;
                t ? (t = n.makeArray(t),
                    e = this.getItems(t)) : e = this.items,
                    this._getSorters(),
                    this._updateItemsSortData(e)
            }
            ,
            l._getSorters = function () {
                var t = this.options.getSortData;
                for (var e in t) {
                    var i = t[e];
                    this._sorters[e] = f(i)
                }
            }
            ,
            l._updateItemsSortData = function (t) {
                for (var e = t && t.length, i = 0; e && i < e; i++) {
                    var o = t[i];
                    o.updateSortData()
                }
            }
            ;
        var f = function () {
            function t(t) {
                if ("string" != typeof t)
                    return t;
                var i = h(t).split(" ")
                    , o = i[0]
                    , n = o.match(/^\[(.+)\]$/)
                    , s = n && n[1]
                    , r = e(s, o)
                    , a = d.sortDataParsers[i[1]];
                return t = a ? function (t) {
                    return t && a(r(t))
                }
                    : function (t) {
                        return t && r(t)
                    }
            }
            function e(t, e) {
                return t ? function (e) {
                    return e.getAttribute(t)
                }
                    : function (t) {
                        var i = t.querySelector(e);
                        return i && i.textContent
                    }
            }
            return t
        }();
        d.sortDataParsers = {
            parseInt: function (t) {
                return parseInt(t, 10)
            },
            parseFloat: function (t) {
                return parseFloat(t)
            }
        },
            l._sort = function () {
                if (this.options.sortBy) {
                    var t = n.makeArray(this.options.sortBy);
                    this._getIsSameSortBy(t) || (this.sortHistory = t.concat(this.sortHistory));
                    var e = a(this.sortHistory, this.options.sortAscending);
                    this.filteredItems.sort(e)
                }
            }
            ,
            l._getIsSameSortBy = function (t) {
                for (var e = 0; e < t.length; e++)
                    if (t[e] != this.sortHistory[e])
                        return !1;
                return !0
            }
            ,
            l._mode = function () {
                var t = this.options.layoutMode
                    , e = this.modes[t];
                if (!e)
                    throw new Error("No layout mode: " + t);
                return e.options = this.options[t],
                    e
            }
            ,
            l._resetLayout = function () {
                e.prototype._resetLayout.call(this),
                    this._mode()._resetLayout()
            }
            ,
            l._getItemLayoutPosition = function (t) {
                return this._mode()._getItemLayoutPosition(t)
            }
            ,
            l._manageStamp = function (t) {
                this._mode()._manageStamp(t)
            }
            ,
            l._getContainerSize = function () {
                return this._mode()._getContainerSize()
            }
            ,
            l.needsResizeLayout = function () {
                return this._mode().needsResizeLayout()
            }
            ,
            l.appended = function (t) {
                var e = this.addItems(t);
                if (e.length) {
                    var i = this._filterRevealAdded(e);
                    this.filteredItems = this.filteredItems.concat(i)
                }
            }
            ,
            l.prepended = function (t) {
                var e = this._itemize(t);
                if (e.length) {
                    this._resetLayout(),
                        this._manageStamps();
                    var i = this._filterRevealAdded(e);
                    this.layoutItems(this.filteredItems),
                        this.filteredItems = i.concat(this.filteredItems),
                        this.items = e.concat(this.items)
                }
            }
            ,
            l._filterRevealAdded = function (t) {
                var e = this._filter(t);
                return this.hide(e.needHide),
                    this.reveal(e.matches),
                    this.layoutItems(e.matches, !0),
                    e.matches
            }
            ,
            l.insert = function (t) {
                var e = this.addItems(t);
                if (e.length) {
                    var i, o, n = e.length;
                    for (i = 0; i < n; i++)
                        o = e[i],
                            this.element.appendChild(o.element);
                    var s = this._filter(e).matches;
                    for (i = 0; i < n; i++)
                        e[i].isLayoutInstant = !0;
                    for (this.arrange(),
                        i = 0; i < n; i++)
                        delete e[i].isLayoutInstant;
                    this.reveal(s)
                }
            }
            ;
        var c = l.remove;
        return l.remove = function (t) {
            t = n.makeArray(t);
            var e = this.getItems(t);
            c.call(this, t);
            for (var i = e && e.length, o = 0; i && o < i; o++) {
                var s = e[o];
                n.removeFrom(this.filteredItems, s)
            }
        }
            ,
            l.shuffle = function () {
                for (var t = 0; t < this.items.length; t++) {
                    var e = this.items[t];
                    e.sortData.random = Math.random()
                }
                this.options.sortBy = "random",
                    this._sort(),
                    this._layout()
            }
            ,
            l._noTransition = function (t, e) {
                var i = this.options.transitionDuration;
                this.options.transitionDuration = 0;
                var o = t.apply(this, e);
                return this.options.transitionDuration = i,
                    o
            }
            ,
            l.getFilteredItemElements = function () {
                return this.filteredItems.map(function (t) {
                    return t.element
                })
            }
            ,
            d
    });
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (factory((global.THREE = {})));
}(this, (function (exports) {
    'use strict';
    if (Number.EPSILON === undefined) {
        Number.EPSILON = Math.pow(2, -52);
    }
    if (Number.isInteger === undefined) {
        Number.isInteger = function (value) {
            return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
        }
            ;
    }
    if (Math.sign === undefined) {
        Math.sign = function (x) {
            return (x < 0) ? -1 : (x > 0) ? 1 : +x;
        }
            ;
    }
    if ('name' in Function.prototype === false) {
        Object.defineProperty(Function.prototype, 'name', {
            get: function () {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
            }
        });
    }
    if (Object.assign === undefined) {
        (function () {
            Object.assign = function (target) {
                if (target === undefined || target === null) {
                    throw new TypeError('Cannot convert undefined or null to object');
                }
                var output = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (source !== undefined && source !== null) {
                        for (var nextKey in source) {
                            if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                                output[nextKey] = source[nextKey];
                            }
                        }
                    }
                }
                return output;
            }
                ;
        }
        )();
    }
    function EventDispatcher() { }
    Object.assign(EventDispatcher.prototype, {
        addEventListener: function (type, listener) {
            if (this._listeners === undefined)
                this._listeners = {};
            var listeners = this._listeners;
            if (listeners[type] === undefined) {
                listeners[type] = [];
            }
            if (listeners[type].indexOf(listener) === -1) {
                listeners[type].push(listener);
            }
        },
        hasEventListener: function (type, listener) {
            if (this._listeners === undefined)
                return false;
            var listeners = this._listeners;
            return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
        },
        removeEventListener: function (type, listener) {
            if (this._listeners === undefined)
                return;
            var listeners = this._listeners;
            var listenerArray = listeners[type];
            if (listenerArray !== undefined) {
                var index = listenerArray.indexOf(listener);
                if (index !== -1) {
                    listenerArray.splice(index, 1);
                }
            }
        },
        dispatchEvent: function (event) {
            if (this._listeners === undefined)
                return;
            var listeners = this._listeners;
            var listenerArray = listeners[event.type];
            if (listenerArray !== undefined) {
                event.target = this;
                var array = listenerArray.slice(0);
                for (var i = 0, l = array.length; i < l; i++) {
                    array[i].call(this, event);
                }
            }
        }
    });
    var REVISION = '93';
    var MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var FrontFaceDirectionCW = 0;
    var FrontFaceDirectionCCW = 1;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var Uncharted2ToneMapping = 3;
    var CineonToneMapping = 4;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var SphericalReflectionMapping = 305;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var NearestFilter = 1003;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipMapLinearFilter = 1008;
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RGB_S3TC_DXT1_Format = 33776;
    var RGBA_S3TC_DXT1_Format = 33777;
    var RGBA_S3TC_DXT3_Format = 33778;
    var RGBA_S3TC_DXT5_Format = 33779;
    var RGB_PVRTC_4BPPV1_Format = 35840;
    var RGB_PVRTC_2BPPV1_Format = 35841;
    var RGBA_PVRTC_4BPPV1_Format = 35842;
    var RGBA_PVRTC_2BPPV1_Format = 35843;
    var RGB_ETC1_Format = 36196;
    var RGBA_ASTC_4x4_Format = 37808;
    var RGBA_ASTC_5x4_Format = 37809;
    var RGBA_ASTC_5x5_Format = 37810;
    var RGBA_ASTC_6x5_Format = 37811;
    var RGBA_ASTC_6x6_Format = 37812;
    var RGBA_ASTC_8x5_Format = 37813;
    var RGBA_ASTC_8x6_Format = 37814;
    var RGBA_ASTC_8x8_Format = 37815;
    var RGBA_ASTC_10x5_Format = 37816;
    var RGBA_ASTC_10x6_Format = 37817;
    var RGBA_ASTC_10x8_Format = 37818;
    var RGBA_ASTC_10x10_Format = 37819;
    var RGBA_ASTC_12x10_Format = 37820;
    var RGBA_ASTC_12x12_Format = 37821;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;
    var _Math = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: (function () {
            var lut = [];
            for (var i = 0; i < 256; i++) {
                lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
            }
            return function generateUUID() {
                var d0 = Math.random() * 0xffffffff | 0;
                var d1 = Math.random() * 0xffffffff | 0;
                var d2 = Math.random() * 0xffffffff | 0;
                var d3 = Math.random() * 0xffffffff | 0;
                var uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];
                return uuid.toUpperCase();
            }
                ;
        }
        )(),
        clamp: function (value, min, max) {
            return Math.max(min, Math.min(max, value));
        },
        euclideanModulo: function (n, m) {
            return ((n % m) + m) % m;
        },
        mapLinear: function (x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        },
        lerp: function (x, y, t) {
            return (1 - t) * x + t * y;
        },
        smoothstep: function (x, min, max) {
            if (x <= min)
                return 0;
            if (x >= max)
                return 1;
            x = (x - min) / (max - min);
            return x * x * (3 - 2 * x);
        },
        smootherstep: function (x, min, max) {
            if (x <= min)
                return 0;
            if (x >= max)
                return 1;
            x = (x - min) / (max - min);
            return x * x * x * (x * (x * 6 - 15) + 10);
        },
        randInt: function (low, high) {
            return low + Math.floor(Math.random() * (high - low + 1));
        },
        randFloat: function (low, high) {
            return low + Math.random() * (high - low);
        },
        randFloatSpread: function (range) {
            return range * (0.5 - Math.random());
        },
        degToRad: function (degrees) {
            return degrees * _Math.DEG2RAD;
        },
        radToDeg: function (radians) {
            return radians * _Math.RAD2DEG;
        },
        isPowerOfTwo: function (value) {
            return (value & (value - 1)) === 0 && value !== 0;
        },
        ceilPowerOfTwo: function (value) {
            return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
        },
        floorPowerOfTwo: function (value) {
            return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
        }
    };
    function Vector2(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    Object.defineProperties(Vector2.prototype, {
        "width": {
            get: function () {
                return this.x;
            },
            set: function (value) {
                this.x = value;
            }
        },
        "height": {
            get: function () {
                return this.y;
            },
            set: function (value) {
                this.y = value;
            }
        }
    });
    Object.assign(Vector2.prototype, {
        isVector2: true,
        set: function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        },
        setScalar: function (scalar) {
            this.x = scalar;
            this.y = scalar;
            return this;
        },
        setX: function (x) {
            this.x = x;
            return this;
        },
        setY: function (y) {
            this.y = y;
            return this;
        },
        setComponent: function (index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);
            }
            return this;
        },
        getComponent: function (index) {
            switch (index) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error('index is out of range: ' + index);
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y);
        },
        copy: function (v) {
            this.x = v.x;
            this.y = v.y;
            return this;
        },
        add: function (v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            return this;
        },
        addScalar: function (s) {
            this.x += s;
            this.y += s;
            return this;
        },
        addVectors: function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this;
        },
        addScaledVector: function (v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            return this;
        },
        sub: function (v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            return this;
        },
        subScalar: function (s) {
            this.x -= s;
            this.y -= s;
            return this;
        },
        subVectors: function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;
        },
        multiply: function (v) {
            this.x *= v.x;
            this.y *= v.y;
            return this;
        },
        multiplyScalar: function (scalar) {
            this.x *= scalar;
            this.y *= scalar;
            return this;
        },
        divide: function (v) {
            this.x /= v.x;
            this.y /= v.y;
            return this;
        },
        divideScalar: function (scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        applyMatrix3: function (m) {
            var x = this.x
                , y = this.y;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6];
            this.y = e[1] * x + e[4] * y + e[7];
            return this;
        },
        min: function (v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            return this;
        },
        max: function (v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            return this;
        },
        clamp: function (min, max) {
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            return this;
        },
        clampScalar: function () {
            var min = new Vector2();
            var max = new Vector2();
            return function clampScalar(minVal, maxVal) {
                min.set(minVal, minVal);
                max.set(maxVal, maxVal);
                return this.clamp(min, max);
            }
                ;
        }(),
        clampLength: function (min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            return this;
        },
        ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            return this;
        },
        round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            return this;
        },
        roundToZero: function () {
            this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
            return this;
        },
        negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        },
        dot: function (v) {
            return this.x * v.x + this.y * v.y;
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y;
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y);
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1);
        },
        angle: function () {
            var angle = Math.atan2(this.y, this.x);
            if (angle < 0)
                angle += 2 * Math.PI;
            return angle;
        },
        distanceTo: function (v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function (v) {
            var dx = this.x - v.x
                , dy = this.y - v.y;
            return dx * dx + dy * dy;
        },
        manhattanDistanceTo: function (v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
        },
        setLength: function (length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            return this;
        },
        lerpVectors: function (v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function (v) {
            return ((v.x === this.x) && (v.y === this.y));
        },
        fromArray: function (array, offset) {
            if (offset === undefined)
                offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            return this;
        },
        toArray: function (array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            return array;
        },
        fromBufferAttribute: function (attribute, index, offset) {
            if (offset !== undefined) {
                console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            return this;
        },
        rotateAround: function (center, angle) {
            var c = Math.cos(angle)
                , s = Math.sin(angle);
            var x = this.x - center.x;
            var y = this.y - center.y;
            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;
            return this;
        }
    });
    function Matrix4() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        if (arguments.length > 0) {
            console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
        }
    }
    Object.assign(Matrix4.prototype, {
        isMatrix4: true,
        set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            te[0] = n11;
            te[4] = n12;
            te[8] = n13;
            te[12] = n14;
            te[1] = n21;
            te[5] = n22;
            te[9] = n23;
            te[13] = n24;
            te[2] = n31;
            te[6] = n32;
            te[10] = n33;
            te[14] = n34;
            te[3] = n41;
            te[7] = n42;
            te[11] = n43;
            te[15] = n44;
            return this;
        },
        identity: function () {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        },
        clone: function () {
            return new Matrix4().fromArray(this.elements);
        },
        copy: function (m) {
            var te = this.elements;
            var me = m.elements;
            te[0] = me[0];
            te[1] = me[1];
            te[2] = me[2];
            te[3] = me[3];
            te[4] = me[4];
            te[5] = me[5];
            te[6] = me[6];
            te[7] = me[7];
            te[8] = me[8];
            te[9] = me[9];
            te[10] = me[10];
            te[11] = me[11];
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            te[15] = me[15];
            return this;
        },
        copyPosition: function (m) {
            var te = this.elements
                , me = m.elements;
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            return this;
        },
        extractBasis: function (xAxis, yAxis, zAxis) {
            xAxis.setFromMatrixColumn(this, 0);
            yAxis.setFromMatrixColumn(this, 1);
            zAxis.setFromMatrixColumn(this, 2);
            return this;
        },
        makeBasis: function (xAxis, yAxis, zAxis) {
            this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
            return this;
        },
        extractRotation: function () {
            var v1 = new Vector3();
            return function extractRotation(m) {
                var te = this.elements;
                var me = m.elements;
                var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
                var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
                var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
                te[0] = me[0] * scaleX;
                te[1] = me[1] * scaleX;
                te[2] = me[2] * scaleX;
                te[3] = 0;
                te[4] = me[4] * scaleY;
                te[5] = me[5] * scaleY;
                te[6] = me[6] * scaleY;
                te[7] = 0;
                te[8] = me[8] * scaleZ;
                te[9] = me[9] * scaleZ;
                te[10] = me[10] * scaleZ;
                te[11] = 0;
                te[12] = 0;
                te[13] = 0;
                te[14] = 0;
                te[15] = 1;
                return this;
            }
                ;
        }(),
        makeRotationFromEuler: function (euler) {
            if (!(euler && euler.isEuler)) {
                console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
            }
            var te = this.elements;
            var x = euler.x
                , y = euler.y
                , z = euler.z;
            var a = Math.cos(x)
                , b = Math.sin(x);
            var c = Math.cos(y)
                , d = Math.sin(y);
            var e = Math.cos(z)
                , f = Math.sin(z);
            if (euler.order === 'XYZ') {
                var ae = a * e
                    , af = a * f
                    , be = b * e
                    , bf = b * f;
                te[0] = c * e;
                te[4] = -c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
            } else if (euler.order === 'YXZ') {
                var ce = c * e
                    , cf = c * f
                    , de = d * e
                    , df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e;
                te[9] = -b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
            } else if (euler.order === 'ZXY') {
                var ce = c * e
                    , cf = c * f
                    , de = d * e
                    , df = d * f;
                te[0] = ce - df * b;
                te[4] = -a * f;
                te[8] = de + cf * b;
                te[1] = cf + de * b;
                te[5] = a * e;
                te[9] = df - ce * b;
                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
            } else if (euler.order === 'ZYX') {
                var ae = a * e
                    , af = a * f
                    , be = b * e
                    , bf = b * f;
                te[0] = c * e;
                te[4] = be * d - af;
                te[8] = ae * d + bf;
                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;
                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
            } else if (euler.order === 'YZX') {
                var ac = a * c
                    , ad = a * d
                    , bc = b * c
                    , bd = b * d;
                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e;
                te[9] = -b * e;
                te[2] = -d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
            } else if (euler.order === 'XZY') {
                var ac = a * c
                    , ad = a * d
                    , bc = b * c
                    , bd = b * d;
                te[0] = c * e;
                te[4] = -f;
                te[8] = d * e;
                te[1] = ac * f + bd;
                te[5] = a * e;
                te[9] = ad * f - bc;
                te[2] = bc * f - ad;
                te[6] = b * e;
                te[10] = bd * f + ac;
            }
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        },
        makeRotationFromQuaternion: function () {
            var zero = new Vector3(0, 0, 0);
            var one = new Vector3(1, 1, 1);
            return function makeRotationFromQuaternion(q) {
                return this.compose(zero, q, one);
            }
                ;
        }(),
        lookAt: function () {
            var x = new Vector3();
            var y = new Vector3();
            var z = new Vector3();
            return function lookAt(eye, target, up) {
                var te = this.elements;
                z.subVectors(eye, target);
                if (z.lengthSq() === 0) {
                    z.z = 1;
                }
                z.normalize();
                x.crossVectors(up, z);
                if (x.lengthSq() === 0) {
                    if (Math.abs(up.z) === 1) {
                        z.x += 0.0001;
                    } else {
                        z.z += 0.0001;
                    }
                    z.normalize();
                    x.crossVectors(up, z);
                }
                x.normalize();
                y.crossVectors(z, x);
                te[0] = x.x;
                te[4] = y.x;
                te[8] = z.x;
                te[1] = x.y;
                te[5] = y.y;
                te[9] = z.y;
                te[2] = x.z;
                te[6] = y.z;
                te[10] = z.z;
                return this;
            }
                ;
        }(),
        multiply: function (m, n) {
            if (n !== undefined) {
                console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
                return this.multiplyMatrices(m, n);
            }
            return this.multiplyMatrices(this, m);
        },
        premultiply: function (m) {
            return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function (a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0]
                , a12 = ae[4]
                , a13 = ae[8]
                , a14 = ae[12];
            var a21 = ae[1]
                , a22 = ae[5]
                , a23 = ae[9]
                , a24 = ae[13];
            var a31 = ae[2]
                , a32 = ae[6]
                , a33 = ae[10]
                , a34 = ae[14];
            var a41 = ae[3]
                , a42 = ae[7]
                , a43 = ae[11]
                , a44 = ae[15];
            var b11 = be[0]
                , b12 = be[4]
                , b13 = be[8]
                , b14 = be[12];
            var b21 = be[1]
                , b22 = be[5]
                , b23 = be[9]
                , b24 = be[13];
            var b31 = be[2]
                , b32 = be[6]
                , b33 = be[10]
                , b34 = be[14];
            var b41 = be[3]
                , b42 = be[7]
                , b43 = be[11]
                , b44 = be[15];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        },
        multiplyScalar: function (s) {
            var te = this.elements;
            te[0] *= s;
            te[4] *= s;
            te[8] *= s;
            te[12] *= s;
            te[1] *= s;
            te[5] *= s;
            te[9] *= s;
            te[13] *= s;
            te[2] *= s;
            te[6] *= s;
            te[10] *= s;
            te[14] *= s;
            te[3] *= s;
            te[7] *= s;
            te[11] *= s;
            te[15] *= s;
            return this;
        },
        applyToBufferAttribute: function () {
            var v1 = new Vector3();
            return function applyToBufferAttribute(attribute) {
                for (var i = 0, l = attribute.count; i < l; i++) {
                    v1.x = attribute.getX(i);
                    v1.y = attribute.getY(i);
                    v1.z = attribute.getZ(i);
                    v1.applyMatrix4(this);
                    attribute.setXYZ(i, v1.x, v1.y, v1.z);
                }
                return attribute;
            }
                ;
        }(),
        determinant: function () {
            var te = this.elements;
            var n11 = te[0]
                , n12 = te[4]
                , n13 = te[8]
                , n14 = te[12];
            var n21 = te[1]
                , n22 = te[5]
                , n23 = te[9]
                , n24 = te[13];
            var n31 = te[2]
                , n32 = te[6]
                , n33 = te[10]
                , n34 = te[14];
            var n41 = te[3]
                , n42 = te[7]
                , n43 = te[11]
                , n44 = te[15];
            return (n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31));
        },
        transpose: function () {
            var te = this.elements;
            var tmp;
            tmp = te[1];
            te[1] = te[4];
            te[4] = tmp;
            tmp = te[2];
            te[2] = te[8];
            te[8] = tmp;
            tmp = te[6];
            te[6] = te[9];
            te[9] = tmp;
            tmp = te[3];
            te[3] = te[12];
            te[12] = tmp;
            tmp = te[7];
            te[7] = te[13];
            te[13] = tmp;
            tmp = te[11];
            te[11] = te[14];
            te[14] = tmp;
            return this;
        },
        setPosition: function (v) {
            var te = this.elements;
            te[12] = v.x;
            te[13] = v.y;
            te[14] = v.z;
            return this;
        },
        getInverse: function (m, throwOnDegenerate) {
            var te = this.elements
                , me = m.elements
                , n11 = me[0]
                , n21 = me[1]
                , n31 = me[2]
                , n41 = me[3]
                , n12 = me[4]
                , n22 = me[5]
                , n32 = me[6]
                , n42 = me[7]
                , n13 = me[8]
                , n23 = me[9]
                , n33 = me[10]
                , n43 = me[11]
                , n14 = me[12]
                , n24 = me[13]
                , n34 = me[14]
                , n44 = me[15]
                , t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44
                , t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44
                , t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44
                , t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0) {
                var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (throwOnDegenerate === true) {
                    throw new Error(msg);
                } else {
                    console.warn(msg);
                }
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            te[4] = t12 * detInv;
            te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            te[8] = t13 * detInv;
            te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            te[12] = t14 * detInv;
            te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        },
        scale: function (v) {
            var te = this.elements;
            var x = v.x
                , y = v.y
                , z = v.z;
            te[0] *= x;
            te[4] *= y;
            te[8] *= z;
            te[1] *= x;
            te[5] *= y;
            te[9] *= z;
            te[2] *= x;
            te[6] *= y;
            te[10] *= z;
            te[3] *= x;
            te[7] *= y;
            te[11] *= z;
            return this;
        },
        getMaxScaleOnAxis: function () {
            var te = this.elements;
            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        },
        makeTranslation: function (x, y, z) {
            this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
            return this;
        },
        makeRotationX: function (theta) {
            var c = Math.cos(theta)
                , s = Math.sin(theta);
            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
            return this;
        },
        makeRotationY: function (theta) {
            var c = Math.cos(theta)
                , s = Math.sin(theta);
            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
            return this;
        },
        makeRotationZ: function (theta) {
            var c = Math.cos(theta)
                , s = Math.sin(theta);
            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        },
        makeRotationAxis: function (axis, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var t = 1 - c;
            var x = axis.x
                , y = axis.y
                , z = axis.z;
            var tx = t * x
                , ty = t * y;
            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
            return this;
        },
        makeScale: function (x, y, z) {
            this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
            return this;
        },
        makeShear: function (x, y, z) {
            this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
            return this;
        },
        compose: function (position, quaternion, scale) {
            var te = this.elements;
            var x = quaternion._x
                , y = quaternion._y
                , z = quaternion._z
                , w = quaternion._w;
            var x2 = x + x
                , y2 = y + y
                , z2 = z + z;
            var xx = x * x2
                , xy = x * y2
                , xz = x * z2;
            var yy = y * y2
                , yz = y * z2
                , zz = z * z2;
            var wx = w * x2
                , wy = w * y2
                , wz = w * z2;
            var sx = scale.x
                , sy = scale.y
                , sz = scale.z;
            te[0] = (1 - (yy + zz)) * sx;
            te[1] = (xy + wz) * sx;
            te[2] = (xz - wy) * sx;
            te[3] = 0;
            te[4] = (xy - wz) * sy;
            te[5] = (1 - (xx + zz)) * sy;
            te[6] = (yz + wx) * sy;
            te[7] = 0;
            te[8] = (xz + wy) * sz;
            te[9] = (yz - wx) * sz;
            te[10] = (1 - (xx + yy)) * sz;
            te[11] = 0;
            te[12] = position.x;
            te[13] = position.y;
            te[14] = position.z;
            te[15] = 1;
            return this;
        },
        decompose: function () {
            var vector = new Vector3();
            var matrix = new Matrix4();
            return function decompose(position, quaternion, scale) {
                var te = this.elements;
                var sx = vector.set(te[0], te[1], te[2]).length();
                var sy = vector.set(te[4], te[5], te[6]).length();
                var sz = vector.set(te[8], te[9], te[10]).length();
                var det = this.determinant();
                if (det < 0)
                    sx = -sx;
                position.x = te[12];
                position.y = te[13];
                position.z = te[14];
                matrix.copy(this);
                var invSX = 1 / sx;
                var invSY = 1 / sy;
                var invSZ = 1 / sz;
                matrix.elements[0] *= invSX;
                matrix.elements[1] *= invSX;
                matrix.elements[2] *= invSX;
                matrix.elements[4] *= invSY;
                matrix.elements[5] *= invSY;
                matrix.elements[6] *= invSY;
                matrix.elements[8] *= invSZ;
                matrix.elements[9] *= invSZ;
                matrix.elements[10] *= invSZ;
                quaternion.setFromRotationMatrix(matrix);
                scale.x = sx;
                scale.y = sy;
                scale.z = sz;
                return this;
            }
                ;
        }(),
        makePerspective: function (left, right, top, bottom, near, far) {
            if (far === undefined) {
                console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
            }
            var te = this.elements;
            var x = 2 * near / (right - left);
            var y = 2 * near / (top - bottom);
            var a = (right + left) / (right - left);
            var b = (top + bottom) / (top - bottom);
            var c = -(far + near) / (far - near);
            var d = -2 * far * near / (far - near);
            te[0] = x;
            te[4] = 0;
            te[8] = a;
            te[12] = 0;
            te[1] = 0;
            te[5] = y;
            te[9] = b;
            te[13] = 0;
            te[2] = 0;
            te[6] = 0;
            te[10] = c;
            te[14] = d;
            te[3] = 0;
            te[7] = 0;
            te[11] = -1;
            te[15] = 0;
            return this;
        },
        makeOrthographic: function (left, right, top, bottom, near, far) {
            var te = this.elements;
            var w = 1.0 / (right - left);
            var h = 1.0 / (top - bottom);
            var p = 1.0 / (far - near);
            var x = (right + left) * w;
            var y = (top + bottom) * h;
            var z = (far + near) * p;
            te[0] = 2 * w;
            te[4] = 0;
            te[8] = 0;
            te[12] = -x;
            te[1] = 0;
            te[5] = 2 * h;
            te[9] = 0;
            te[13] = -y;
            te[2] = 0;
            te[6] = 0;
            te[10] = -2 * p;
            te[14] = -z;
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[15] = 1;
            return this;
        },
        equals: function (matrix) {
            var te = this.elements;
            var me = matrix.elements;
            for (var i = 0; i < 16; i++) {
                if (te[i] !== me[i])
                    return false;
            }
            return true;
        },
        fromArray: function (array, offset) {
            if (offset === undefined)
                offset = 0;
            for (var i = 0; i < 16; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        },
        toArray: function (array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            array[offset + 9] = te[9];
            array[offset + 10] = te[10];
            array[offset + 11] = te[11];
            array[offset + 12] = te[12];
            array[offset + 13] = te[13];
            array[offset + 14] = te[14];
            array[offset + 15] = te[15];
            return array;
        }
    });
    function Quaternion(x, y, z, w) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._w = (w !== undefined) ? w : 1;
    }
    Object.assign(Quaternion, {
        slerp: function (qa, qb, qm, t) {
            return qm.copy(qa).slerp(qb, t);
        },
        slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
            var x0 = src0[srcOffset0 + 0]
                , y0 = src0[srcOffset0 + 1]
                , z0 = src0[srcOffset0 + 2]
                , w0 = src0[srcOffset0 + 3]
                , x1 = src1[srcOffset1 + 0]
                , y1 = src1[srcOffset1 + 1]
                , z1 = src1[srcOffset1 + 2]
                , w1 = src1[srcOffset1 + 3];
            if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                var s = 1 - t
                    , cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1
                    , dir = (cos >= 0 ? 1 : -1)
                    , sqrSin = 1 - cos * cos;
                if (sqrSin > Number.EPSILON) {
                    var sin = Math.sqrt(sqrSin)
                        , len = Math.atan2(sin, cos * dir);
                    s = Math.sin(s * len) / sin;
                    t = Math.sin(t * len) / sin;
                }
                var tDir = t * dir;
                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir;
                if (s === 1 - t) {
                    var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                    x0 *= f;
                    y0 *= f;
                    z0 *= f;
                    w0 *= f;
                }
            }
            dst[dstOffset] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
        }
    });
    Object.defineProperties(Quaternion.prototype, {
        x: {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
                this.onChangeCallback();
            }
        },
        y: {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
                this.onChangeCallback();
            }
        },
        z: {
            get: function () {
                return this._z;
            },
            set: function (value) {
                this._z = value;
                this.onChangeCallback();
            }
        },
        w: {
            get: function () {
                return this._w;
            },
            set: function (value) {
                this._w = value;
                this.onChangeCallback();
            }
        }
    });
    Object.assign(Quaternion.prototype, {
        set: function (x, y, z, w) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
            this.onChangeCallback();
            return this;
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w);
        },
        copy: function (quaternion) {
            this._x = quaternion.x;
            this._y = quaternion.y;
            this._z = quaternion.z;
            this._w = quaternion.w;
            this.onChangeCallback();
            return this;
        },
        setFromEuler: function (euler, update) {
            if (!(euler && euler.isEuler)) {
                throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
            }
            var x = euler._x
                , y = euler._y
                , z = euler._z
                , order = euler.order;
            var cos = Math.cos;
            var sin = Math.sin;
            var c1 = cos(x / 2);
            var c2 = cos(y / 2);
            var c3 = cos(z / 2);
            var s1 = sin(x / 2);
            var s2 = sin(y / 2);
            var s3 = sin(z / 2);
            if (order === 'XYZ') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === 'YXZ') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            } else if (order === 'ZXY') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === 'ZYX') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            } else if (order === 'YZX') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if (order === 'XZY') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            if (update !== false)
                this.onChangeCallback();
            return this;
        },
        setFromAxisAngle: function (axis, angle) {
            var halfAngle = angle / 2
                , s = Math.sin(halfAngle);
            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = Math.cos(halfAngle);
            this.onChangeCallback();
            return this;
        },
        setFromRotationMatrix: function (m) {
            var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                this._w = 0.25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
            } else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this._w = (m32 - m23) / s;
                this._x = 0.25 * s;
                this._y = (m12 + m21) / s;
                this._z = (m13 + m31) / s;
            } else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this._w = (m13 - m31) / s;
                this._x = (m12 + m21) / s;
                this._y = 0.25 * s;
                this._z = (m23 + m32) / s;
            } else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this._w = (m21 - m12) / s;
                this._x = (m13 + m31) / s;
                this._y = (m23 + m32) / s;
                this._z = 0.25 * s;
            }
            this.onChangeCallback();
            return this;
        },
        setFromUnitVectors: function () {
            var v1 = new Vector3();
            var r;
            var EPS = 0.000001;
            return function setFromUnitVectors(vFrom, vTo) {
                if (v1 === undefined)
                    v1 = new Vector3();
                r = vFrom.dot(vTo) + 1;
                if (r < EPS) {
                    r = 0;
                    if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                        v1.set(-vFrom.y, vFrom.x, 0);
                    } else {
                        v1.set(0, -vFrom.z, vFrom.y);
                    }
                } else {
                    v1.crossVectors(vFrom, vTo);
                }
                this._x = v1.x;
                this._y = v1.y;
                this._z = v1.z;
                this._w = r;
                return this.normalize();
            }
                ;
        }(),
        inverse: function () {
            return this.conjugate();
        },
        conjugate: function () {
            this._x *= -1;
            this._y *= -1;
            this._z *= -1;
            this.onChangeCallback();
            return this;
        },
        dot: function (v) {
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
        },
        lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        },
        length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        },
        normalize: function () {
            var l = this.length();
            if (l === 0) {
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
            } else {
                l = 1 / l;
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
            }
            this.onChangeCallback();
            return this;
        },
        multiply: function (q, p) {
            if (p !== undefined) {
                console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
                return this.multiplyQuaternions(q, p);
            }
            return this.multiplyQuaternions(this, q);
        },
        premultiply: function (q) {
            return this.multiplyQuaternions(q, this);
        },
        multiplyQuaternions: function (a, b) {
            var qax = a._x
                , qay = a._y
                , qaz = a._z
                , qaw = a._w;
            var qbx = b._x
                , qby = b._y
                , qbz = b._z
                , qbw = b._w;
            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            this.onChangeCallback();
            return this;
        },
        slerp: function (qb, t) {
            if (t === 0)
                return this;
            if (t === 1)
                return this.copy(qb);
            var x = this._x
                , y = this._y
                , z = this._z
                , w = this._w;
            var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (cosHalfTheta < 0) {
                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;
                cosHalfTheta = -cosHalfTheta;
            } else {
                this.copy(qb);
            }
            if (cosHalfTheta >= 1.0) {
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
                return this;
            }
            var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < 0.001) {
                this._w = 0.5 * (w + this._w);
                this._x = 0.5 * (x + this._x);
                this._y = 0.5 * (y + this._y);
                this._z = 0.5 * (z + this._z);
                return this;
            }
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta
                , ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this._w = (w * ratioA + this._w * ratioB);
            this._x = (x * ratioA + this._x * ratioB);
            this._y = (y * ratioA + this._y * ratioB);
            this._z = (z * ratioA + this._z * ratioB);
            this.onChangeCallback();
            return this;
        },
        equals: function (quaternion) {
            return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
        },
        fromArray: function (array, offset) {
            if (offset === undefined)
                offset = 0;
            this._x = array[offset];
            this._y = array[offset + 1];
            this._z = array[offset + 2];
            this._w = array[offset + 3];
            this.onChangeCallback();
            return this;
        },
        toArray: function (array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._w;
            return array;
        },
        onChange: function (callback) {
            this.onChangeCallback = callback;
            return this;
        },
        onChangeCallback: function () { }
    });
    function Vector3(x, y, z) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
    }
    Object.assign(Vector3.prototype, {
        isVector3: true,
        set: function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        },
        setScalar: function (scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            return this;
        },
        setX: function (x) {
            this.x = x;
            return this;
        },
        setY: function (y) {
            this.y = y;
            return this;
        },
        setZ: function (z) {
            this.z = z;
            return this;
        },
        setComponent: function (index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);
            }
            return this;
        },
        getComponent: function (index) {
            switch (index) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error('index is out of range: ' + index);
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z);
        },
        copy: function (v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        },
        add: function (v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        },
        addScalar: function (s) {
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
        },
        addVectors: function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this;
        },
        addScaledVector: function (v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            return this;
        },
        sub: function (v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        },
        subScalar: function (s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            return this;
        },
        subVectors: function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
        },
        multiply: function (v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
                return this.multiplyVectors(v, w);
            }
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            return this;
        },
        multiplyScalar: function (scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            return this;
        },
        multiplyVectors: function (a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this;
        },
        applyEuler: function () {
            var quaternion = new Quaternion();
            return function applyEuler(euler) {
                if (!(euler && euler.isEuler)) {
                    console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
                }
                return this.applyQuaternion(quaternion.setFromEuler(euler));
            }
                ;
        }(),
        applyAxisAngle: function () {
            var quaternion = new Quaternion();
            return function applyAxisAngle(axis, angle) {
                return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
            }
                ;
        }(),
        applyMatrix3: function (m) {
            var x = this.x
                , y = this.y
                , z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;
            return this;
        },
        applyMatrix4: function (m) {
            var x = this.x
                , y = this.y
                , z = this.z;
            var e = m.elements;
            var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
            this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
            this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
            return this;
        },
        applyQuaternion: function (q) {
            var x = this.x
                , y = this.y
                , z = this.z;
            var qx = q.x
                , qy = q.y
                , qz = q.z
                , qw = q.w;
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        },
        project: function () {
            var matrix = new Matrix4();
            return function project(camera) {
                matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
                return this.applyMatrix4(matrix);
            }
                ;
        }(),
        unproject: function () {
            var matrix = new Matrix4();
            return function unproject(camera) {
                matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
                return this.applyMatrix4(matrix);
            }
                ;
        }(),
        transformDirection: function (m) {
            var x = this.x
                , y = this.y
                , z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z;
            this.y = e[1] * x + e[5] * y + e[9] * z;
            this.z = e[2] * x + e[6] * y + e[10] * z;
            return this.normalize();
        },
        divide: function (v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            return this;
        },
        divideScalar: function (scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        min: function (v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            return this;
        },
        max: function (v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            return this;
        },
        clamp: function (min, max) {
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            this.z = Math.max(min.z, Math.min(max.z, this.z));
            return this;
        },
        clampScalar: function () {
            var min = new Vector3();
            var max = new Vector3();
            return function clampScalar(minVal, maxVal) {
                min.set(minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal);
                return this.clamp(min, max);
            }
                ;
        }(),
        clampLength: function (min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            return this;
        },
        ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            return this;
        },
        round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            return this;
        },
        roundToZero: function () {
            this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
            return this;
        },
        negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            return this;
        },
        dot: function (v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1);
        },
        setLength: function (length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        },
        lerpVectors: function (v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        cross: function (v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
                return this.crossVectors(v, w);
            }
            return this.crossVectors(this, v);
        },
        crossVectors: function (a, b) {
            var ax = a.x
                , ay = a.y
                , az = a.z;
            var bx = b.x
                , by = b.y
                , bz = b.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
        },
        projectOnVector: function (vector) {
            var scalar = vector.dot(this) / vector.lengthSq();
            return this.copy(vector).multiplyScalar(scalar);
        },
        projectOnPlane: function () {
            var v1 = new Vector3();
            return function projectOnPlane(planeNormal) {
                v1.copy(this).projectOnVector(planeNormal);
                return this.sub(v1);
            }
                ;
        }(),
        reflect: function () {
            var v1 = new Vector3();
            return function reflect(normal) {
                return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
            }
                ;
        }(),
        angleTo: function (v) {
            var theta = this.dot(v) / (Math.sqrt(this.lengthSq() * v.lengthSq()));
            return Math.acos(_Math.clamp(theta, -1, 1));
        },
        distanceTo: function (v) {
            return Math.sqrt(this.distanceToSquared(v));
        },
        distanceToSquared: function (v) {
            var dx = this.x - v.x
                , dy = this.y - v.y
                , dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        },
        manhattanDistanceTo: function (v) {
            return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
        },
        setFromSpherical: function (s) {
            var sinPhiRadius = Math.sin(s.phi) * s.radius;
            this.x = sinPhiRadius * Math.sin(s.theta);
            this.y = Math.cos(s.phi) * s.radius;
            this.z = sinPhiRadius * Math.cos(s.theta);
            return this;
        },
        setFromCylindrical: function (c) {
            this.x = c.radius * Math.sin(c.theta);
            this.y = c.y;
            this.z = c.radius * Math.cos(c.theta);
            return this;
        },
        setFromMatrixPosition: function (m) {
            var e = m.elements;
            this.x = e[12];
            this.y = e[13];
            this.z = e[14];
            return this;
        },
        setFromMatrixScale: function (m) {
            var sx = this.setFromMatrixColumn(m, 0).length();
            var sy = this.setFromMatrixColumn(m, 1).length();
            var sz = this.setFromMatrixColumn(m, 2).length();
            this.x = sx;
            this.y = sy;
            this.z = sz;
            return this;
        },
        setFromMatrixColumn: function (m, index) {
            return this.fromArray(m.elements, index * 4);
        },
        equals: function (v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
        },
        fromArray: function (array, offset) {
            if (offset === undefined)
                offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            return this;
        },
        toArray: function (array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            return array;
        },
        fromBufferAttribute: function (attribute, index, offset) {
            if (offset !== undefined) {
                console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            return this;
        }
    });
    function Matrix3() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (arguments.length > 0) {
            console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
        }
    }
    Object.assign(Matrix3.prototype, {
        isMatrix3: true,
        set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var te = this.elements;
            te[0] = n11;
            te[1] = n21;
            te[2] = n31;
            te[3] = n12;
            te[4] = n22;
            te[5] = n32;
            te[6] = n13;
            te[7] = n23;
            te[8] = n33;
            return this;
        },
        identity: function () {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
        },
        clone: function () {
            return new this.constructor().fromArray(this.elements);
        },
        copy: function (m) {
            var te = this.elements;
            var me = m.elements;
            te[0] = me[0];
            te[1] = me[1];
            te[2] = me[2];
            te[3] = me[3];
            te[4] = me[4];
            te[5] = me[5];
            te[6] = me[6];
            te[7] = me[7];
            te[8] = me[8];
            return this;
        },
        setFromMatrix4: function (m) {
            var me = m.elements;
            this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
            return this;
        },
        applyToBufferAttribute: function () {
            var v1 = new Vector3();
            return function applyToBufferAttribute(attribute) {
                for (var i = 0, l = attribute.count; i < l; i++) {
                    v1.x = attribute.getX(i);
                    v1.y = attribute.getY(i);
                    v1.z = attribute.getZ(i);
                    v1.applyMatrix3(this);
                    attribute.setXYZ(i, v1.x, v1.y, v1.z);
                }
                return attribute;
            }
                ;
        }(),
        multiply: function (m) {
            return this.multiplyMatrices(this, m);
        },
        premultiply: function (m) {
            return this.multiplyMatrices(m, this);
        },
        multiplyMatrices: function (a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0]
                , a12 = ae[3]
                , a13 = ae[6];
            var a21 = ae[1]
                , a22 = ae[4]
                , a23 = ae[7];
            var a31 = ae[2]
                , a32 = ae[5]
                , a33 = ae[8];
            var b11 = be[0]
                , b12 = be[3]
                , b13 = be[6];
            var b21 = be[1]
                , b22 = be[4]
                , b23 = be[7];
            var b31 = be[2]
                , b32 = be[5]
                , b33 = be[8];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31;
            te[3] = a11 * b12 + a12 * b22 + a13 * b32;
            te[6] = a11 * b13 + a12 * b23 + a13 * b33;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31;
            te[4] = a21 * b12 + a22 * b22 + a23 * b32;
            te[7] = a21 * b13 + a22 * b23 + a23 * b33;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31;
            te[5] = a31 * b12 + a32 * b22 + a33 * b32;
            te[8] = a31 * b13 + a32 * b23 + a33 * b33;
            return this;
        },
        multiplyScalar: function (s) {
            var te = this.elements;
            te[0] *= s;
            te[3] *= s;
            te[6] *= s;
            te[1] *= s;
            te[4] *= s;
            te[7] *= s;
            te[2] *= s;
            te[5] *= s;
            te[8] *= s;
            return this;
        },
        determinant: function () {
            var te = this.elements;
            var a = te[0]
                , b = te[1]
                , c = te[2]
                , d = te[3]
                , e = te[4]
                , f = te[5]
                , g = te[6]
                , h = te[7]
                , i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        },
        getInverse: function (matrix, throwOnDegenerate) {
            if (matrix && matrix.isMatrix4) {
                console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            }
            var me = matrix.elements
                , te = this.elements
                , n11 = me[0]
                , n21 = me[1]
                , n31 = me[2]
                , n12 = me[3]
                , n22 = me[4]
                , n32 = me[5]
                , n13 = me[6]
                , n23 = me[7]
                , n33 = me[8]
                , t11 = n33 * n22 - n32 * n23
                , t12 = n32 * n13 - n33 * n12
                , t13 = n23 * n12 - n22 * n13
                , det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) {
                var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (throwOnDegenerate === true) {
                    throw new Error(msg);
                } else { }
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        },
        transpose: function () {
            var tmp, m = this.elements;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        },
        getNormalMatrix: function (matrix4) {
            return this.setFromMatrix4(matrix4).getInverse(this).transpose();
        },
        transposeIntoArray: function (r) {
            var m = this.elements;
            r[0] = m[0];
            r[1] = m[3];
            r[2] = m[6];
            r[3] = m[1];
            r[4] = m[4];
            r[5] = m[7];
            r[6] = m[2];
            r[7] = m[5];
            r[8] = m[8];
            return this;
        },
        setUvTransform: function (tx, ty, sx, sy, rotation, cx, cy) {
            var c = Math.cos(rotation);
            var s = Math.sin(rotation);
            this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        },
        scale: function (sx, sy) {
            var te = this.elements;
            te[0] *= sx;
            te[3] *= sx;
            te[6] *= sx;
            te[1] *= sy;
            te[4] *= sy;
            te[7] *= sy;
            return this;
        },
        rotate: function (theta) {
            var c = Math.cos(theta);
            var s = Math.sin(theta);
            var te = this.elements;
            var a11 = te[0]
                , a12 = te[3]
                , a13 = te[6];
            var a21 = te[1]
                , a22 = te[4]
                , a23 = te[7];
            te[0] = c * a11 + s * a21;
            te[3] = c * a12 + s * a22;
            te[6] = c * a13 + s * a23;
            te[1] = -s * a11 + c * a21;
            te[4] = -s * a12 + c * a22;
            te[7] = -s * a13 + c * a23;
            return this;
        },
        translate: function (tx, ty) {
            var te = this.elements;
            te[0] += tx * te[2];
            te[3] += tx * te[5];
            te[6] += tx * te[8];
            te[1] += ty * te[2];
            te[4] += ty * te[5];
            te[7] += ty * te[8];
            return this;
        },
        equals: function (matrix) {
            var te = this.elements;
            var me = matrix.elements;
            for (var i = 0; i < 9; i++) {
                if (te[i] !== me[i])
                    return false;
            }
            return true;
        },
        fromArray: function (array, offset) {
            if (offset === undefined)
                offset = 0;
            for (var i = 0; i < 9; i++) {
                this.elements[i] = array[i + offset];
            }
            return this;
        },
        toArray: function (array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            var te = this.elements;
            array[offset] = te[0];
            array[offset + 1] = te[1];
            array[offset + 2] = te[2];
            array[offset + 3] = te[3];
            array[offset + 4] = te[4];
            array[offset + 5] = te[5];
            array[offset + 6] = te[6];
            array[offset + 7] = te[7];
            array[offset + 8] = te[8];
            return array;
        }
    });
    var textureId = 0;
    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        Object.defineProperty(this, 'id', {
            value: textureId++
        });
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
        this.mipmaps = [];
        this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
        this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
        this.format = format !== undefined ? format : RGBAFormat;
        this.type = type !== undefined ? type : UnsignedByteType;
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.center = new Vector2(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix3();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4;
        this.encoding = encoding !== undefined ? encoding : LinearEncoding;
        this.version = 0;
        this.onUpdate = null;
    }
    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Texture,
        isTexture: true,
        updateMatrix: function () {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (source) {
            this.name = source.name;
            this.image = source.image;
            this.mipmaps = source.mipmaps.slice(0);
            this.mapping = source.mapping;
            this.wrapS = source.wrapS;
            this.wrapT = source.wrapT;
            this.magFilter = source.magFilter;
            this.minFilter = source.minFilter;
            this.anisotropy = source.anisotropy;
            this.format = source.format;
            this.type = source.type;
            this.offset.copy(source.offset);
            this.repeat.copy(source.repeat);
            this.center.copy(source.center);
            this.rotation = source.rotation;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrix.copy(source.matrix);
            this.generateMipmaps = source.generateMipmaps;
            this.premultiplyAlpha = source.premultiplyAlpha;
            this.flipY = source.flipY;
            this.unpackAlignment = source.unpackAlignment;
            this.encoding = source.encoding;
            return this;
        },
        toJSON: function (meta) {
            var isRootObject = (meta === undefined || typeof meta === 'string');
            if (!isRootObject && meta.textures[this.uuid] !== undefined) {
                return meta.textures[this.uuid];
            }
            function getDataURL(image) {
                var canvas;
                if (image instanceof HTMLCanvasElement) {
                    canvas = image;
                } else {
                    canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    var context = canvas.getContext('2d');
                    if (image instanceof ImageData) {
                        context.putImageData(image, 0, 0);
                    } else {
                        context.drawImage(image, 0, 0, image.width, image.height);
                    }
                }
                if (canvas.width > 2048 || canvas.height > 2048) {
                    return canvas.toDataURL('image/jpeg', 0.6);
                } else {
                    return canvas.toDataURL('image/png');
                }
            }
            var output = {
                metadata: {
                    version: 4.5,
                    type: 'Texture',
                    generator: 'Texture.toJSON'
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (this.image !== undefined) {
                var image = this.image;
                if (image.uuid === undefined) {
                    image.uuid = _Math.generateUUID();
                }
                if (!isRootObject && meta.images[image.uuid] === undefined) {
                    meta.images[image.uuid] = {
                        uuid: image.uuid,
                        url: getDataURL(image)
                    };
                }
                output.image = image.uuid;
            }
            if (!isRootObject) {
                meta.textures[this.uuid] = output;
            }
            return output;
        },
        dispose: function () {
            this.dispatchEvent({
                type: 'dispose'
            });
        },
        transformUv: function (uv) {
            if (this.mapping !== UVMapping)
                return;
            uv.applyMatrix3(this.matrix);
            if (uv.x < 0 || uv.x > 1) {
                switch (this.wrapS) {
                    case RepeatWrapping:
                        uv.x = uv.x - Math.floor(uv.x);
                        break;
                    case ClampToEdgeWrapping:
                        uv.x = uv.x < 0 ? 0 : 1;
                        break;
                    case MirroredRepeatWrapping:
                        if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                            uv.x = Math.ceil(uv.x) - uv.x;
                        } else {
                            uv.x = uv.x - Math.floor(uv.x);
                        }
                        break;
                }
            }
            if (uv.y < 0 || uv.y > 1) {
                switch (this.wrapT) {
                    case RepeatWrapping:
                        uv.y = uv.y - Math.floor(uv.y);
                        break;
                    case ClampToEdgeWrapping:
                        uv.y = uv.y < 0 ? 0 : 1;
                        break;
                    case MirroredRepeatWrapping:
                        if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                            uv.y = Math.ceil(uv.y) - uv.y;
                        } else {
                            uv.y = uv.y - Math.floor(uv.y);
                        }
                        break;
                }
            }
            if (this.flipY) {
                uv.y = 1 - uv.y;
            }
        }
    });
    Object.defineProperty(Texture.prototype, "needsUpdate", {
        set: function (value) {
            if (value === true)
                this.version++;
        }
    });
    function Vector4(x, y, z, w) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = (w !== undefined) ? w : 1;
    }
    Object.assign(Vector4.prototype, {
        isVector4: true,
        set: function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        },
        setScalar: function (scalar) {
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            this.w = scalar;
            return this;
        },
        setX: function (x) {
            this.x = x;
            return this;
        },
        setY: function (y) {
            this.y = y;
            return this;
        },
        setZ: function (z) {
            this.z = z;
            return this;
        },
        setW: function (w) {
            this.w = w;
            return this;
        },
        setComponent: function (index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                case 3:
                    this.w = value;
                    break;
                default:
                    throw new Error('index is out of range: ' + index);
            }
            return this;
        },
        getComponent: function (index) {
            switch (index) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error('index is out of range: ' + index);
            }
        },
        clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w);
        },
        copy: function (v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = (v.w !== undefined) ? v.w : 1;
            return this;
        },
        add: function (v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                return this.addVectors(v, w);
            }
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
            return this;
        },
        addScalar: function (s) {
            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;
            return this;
        },
        addVectors: function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this;
        },
        addScaledVector: function (v, s) {
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            this.w += v.w * s;
            return this;
        },
        sub: function (v, w) {
            if (w !== undefined) {
                console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                return this.subVectors(v, w);
            }
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
            return this;
        },
        subScalar: function (s) {
            this.x -= s;
            this.y -= s;
            this.z -= s;
            this.w -= s;
            return this;
        },
        subVectors: function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this;
        },
        multiplyScalar: function (scalar) {
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
            return this;
        },
        applyMatrix4: function (m) {
            var x = this.x
                , y = this.y
                , z = this.z
                , w = this.w;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
            return this;
        },
        divideScalar: function (scalar) {
            return this.multiplyScalar(1 / scalar);
        },
        setAxisAngleFromQuaternion: function (q) {
            this.w = 2 * Math.acos(q.w);
            var s = Math.sqrt(1 - q.w * q.w);
            if (s < 0.0001) {
                this.x = 1;
                this.y = 0;
                this.z = 0;
            } else {
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
            }
            return this;
        },
        setAxisAngleFromRotationMatrix: function (m) {
            var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            if ((Math.abs(m12 - m21) < epsilon) && (Math.abs(m13 - m31) < epsilon) && (Math.abs(m23 - m32) < epsilon)) {
                if ((Math.abs(m12 + m21) < epsilon2) && (Math.abs(m13 + m31) < epsilon2) && (Math.abs(m23 + m32) < epsilon2) && (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
                    this.set(1, 0, 0, 0);
                    return this;
                }
                angle = Math.PI;
                var xx = (m11 + 1) / 2;
                var yy = (m22 + 1) / 2;
                var zz = (m33 + 1) / 2;
                var xy = (m12 + m21) / 4;
                var xz = (m13 + m31) / 4;
                var yz = (m23 + m32) / 4;
                if ((xx > yy) && (xx > zz)) {
                    if (xx < epsilon) {
                        x = 0;
                        y = 0.707106781;
                        z = 0.707106781;
                    } else {
                        x = Math.sqrt(xx);
                        y = xy / x;
                        z = xz / x;
                    }
                } else if (yy > zz) {
                    if (yy < epsilon) {
                        x = 0.707106781;
                        y = 0;
                        z = 0.707106781;
                    } else {
                        y = Math.sqrt(yy);
                        x = xy / y;
                        z = yz / y;
                    }
                } else {
                    if (zz < epsilon) {
                        x = 0.707106781;
                        y = 0.707106781;
                        z = 0;
                    } else {
                        z = Math.sqrt(zz);
                        x = xz / z;
                        y = yz / z;
                    }
                }
                this.set(x, y, z, angle);
                return this;
            }
            var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
            if (Math.abs(s) < 0.001)
                s = 1;
            this.x = (m32 - m23) / s;
            this.y = (m13 - m31) / s;
            this.z = (m21 - m12) / s;
            this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
            return this;
        },
        min: function (v) {
            this.x = Math.min(this.x, v.x);
            this.y = Math.min(this.y, v.y);
            this.z = Math.min(this.z, v.z);
            this.w = Math.min(this.w, v.w);
            return this;
        },
        max: function (v) {
            this.x = Math.max(this.x, v.x);
            this.y = Math.max(this.y, v.y);
            this.z = Math.max(this.z, v.z);
            this.w = Math.max(this.w, v.w);
            return this;
        },
        clamp: function (min, max) {
            this.x = Math.max(min.x, Math.min(max.x, this.x));
            this.y = Math.max(min.y, Math.min(max.y, this.y));
            this.z = Math.max(min.z, Math.min(max.z, this.z));
            this.w = Math.max(min.w, Math.min(max.w, this.w));
            return this;
        },
        clampScalar: function () {
            var min, max;
            return function clampScalar(minVal, maxVal) {
                if (min === undefined) {
                    min = new Vector4();
                    max = new Vector4();
                }
                min.set(minVal, minVal, minVal, minVal);
                max.set(maxVal, maxVal, maxVal, maxVal);
                return this.clamp(min, max);
            }
                ;
        }(),
        clampLength: function (min, max) {
            var length = this.length();
            return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
        },
        floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.z = Math.floor(this.z);
            this.w = Math.floor(this.w);
            return this;
        },
        ceil: function () {
            this.x = Math.ceil(this.x);
            this.y = Math.ceil(this.y);
            this.z = Math.ceil(this.z);
            this.w = Math.ceil(this.w);
            return this;
        },
        round: function () {
            this.x = Math.round(this.x);
            this.y = Math.round(this.y);
            this.z = Math.round(this.z);
            this.w = Math.round(this.w);
            return this;
        },
        roundToZero: function () {
            this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
            this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
            this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
            this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
            return this;
        },
        negate: function () {
            this.x = -this.x;
            this.y = -this.y;
            this.z = -this.z;
            this.w = -this.w;
            return this;
        },
        dot: function (v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        },
        lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        },
        length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        },
        manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        },
        normalize: function () {
            return this.divideScalar(this.length() || 1);
        },
        setLength: function (length) {
            return this.normalize().multiplyScalar(length);
        },
        lerp: function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            this.w += (v.w - this.w) * alpha;
            return this;
        },
        lerpVectors: function (v1, v2, alpha) {
            return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        },
        equals: function (v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
        },
        fromArray: function (array, offset) {
            if (offset === undefined)
                offset = 0;
            this.x = array[offset];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
            return this;
        },
        toArray: function (array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this.x;
            array[offset + 1] = this.y;
            array[offset + 2] = this.z;
            array[offset + 3] = this.w;
            return array;
        },
        fromBufferAttribute: function (attribute, index, offset) {
            if (offset !== undefined) {
                console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
            }
            this.x = attribute.getX(index);
            this.y = attribute.getY(index);
            this.z = attribute.getZ(index);
            this.w = attribute.getW(index);
            return this;
        }
    });
    function WebGLRenderTarget(width, height, options) {
        this.width = width;
        this.height = height;
        this.scissor = new Vector4(0, 0, width, height);
        this.scissorTest = false;
        this.viewport = new Vector4(0, 0, width, height);
        options = options || {};
        if (options.minFilter === undefined)
            options.minFilter = LinearFilter;
        this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : true;
        this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
        this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    }
    WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: WebGLRenderTarget,
        isWebGLRenderTarget: true,
        setSize: function (width, height) {
            if (this.width !== width || this.height !== height) {
                this.width = width;
                this.height = height;
                this.dispose();
            }
            this.viewport.set(0, 0, width, height);
            this.scissor.set(0, 0, width, height);
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (source) {
            this.width = source.width;
            this.height = source.height;
            this.viewport.copy(source.viewport);
            this.texture = source.texture.clone();
            this.depthBuffer = source.depthBuffer;
            this.stencilBuffer = source.stencilBuffer;
            this.depthTexture = source.depthTexture;
            return this;
        },
        dispose: function () {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });
    function WebGLRenderTargetCube(width, height, options) {
        WebGLRenderTarget.call(this, width, height, options);
        this.activeCubeFace = 0;
        this.activeMipMapLevel = 0;
    }
    WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
    WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = {
            data: data,
            width: width,
            height: height
        };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
    }
    DataTexture.prototype = Object.create(Texture.prototype);
    DataTexture.prototype.constructor = DataTexture;
    DataTexture.prototype.isDataTexture = true;
    function Box3(min, max) {
        this.min = (min !== undefined) ? min : new Vector3(+Infinity, +Infinity, +Infinity);
        this.max = (max !== undefined) ? max : new Vector3(-Infinity, -Infinity, -Infinity);
    }
    Object.assign(Box3.prototype, {
        isBox3: true,
        set: function (min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        },
        setFromArray: function (array) {
            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for (var i = 0, l = array.length; i < l; i += 3) {
                var x = array[i];
                var y = array[i + 1];
                var z = array[i + 2];
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (z < minZ)
                    minZ = z;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
                if (z > maxZ)
                    maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
            return this;
        },
        setFromBufferAttribute: function (attribute) {
            var minX = +Infinity;
            var minY = +Infinity;
            var minZ = +Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;
            var maxZ = -Infinity;
            for (var i = 0, l = attribute.count; i < l; i++) {
                var x = attribute.getX(i);
                var y = attribute.getY(i);
                var z = attribute.getZ(i);
                if (x < minX)
                    minX = x;
                if (y < minY)
                    minY = y;
                if (z < minZ)
                    minZ = z;
                if (x > maxX)
                    maxX = x;
                if (y > maxY)
                    maxY = y;
                if (z > maxZ)
                    maxZ = z;
            }
            this.min.set(minX, minY, minZ);
            this.max.set(maxX, maxY, maxZ);
            return this;
        },
        setFromPoints: function (points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        },
        setFromCenterAndSize: function () {
            var v1 = new Vector3();
            return function setFromCenterAndSize(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(0.5);
                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
            }
                ;
        }(),
        setFromObject: function (object) {
            this.makeEmpty();
            return this.expandByObject(object);
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        },
        makeEmpty: function () {
            this.min.x = this.min.y = this.min.z = +Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this;
        },
        isEmpty: function () {
            return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
        },
        getCenter: function (target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .getCenter() target is now required');
                target = new Vector3();
            }
            return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        },
        getSize: function (target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .getSize() target is now required');
                target = new Vector3();
            }
            return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
        },
        expandByPoint: function (point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        },
        expandByVector: function (vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        },
        expandByScalar: function (scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        },
        expandByObject: function () {
            var scope, i, l;
            var v1 = new Vector3();
            function traverse(node) {
                var geometry = node.geometry;
                if (geometry !== undefined) {
                    if (geometry.isGeometry) {
                        var vertices = geometry.vertices;
                        for (i = 0,
                            l = vertices.length; i < l; i++) {
                            v1.copy(vertices[i]);
                            v1.applyMatrix4(node.matrixWorld);
                            scope.expandByPoint(v1);
                        }
                    } else if (geometry.isBufferGeometry) {
                        var attribute = geometry.attributes.position;
                        if (attribute !== undefined) {
                            for (i = 0,
                                l = attribute.count; i < l; i++) {
                                v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                                scope.expandByPoint(v1);
                            }
                        }
                    }
                }
            }
            return function expandByObject(object) {
                scope = this;
                object.updateMatrixWorld(true);
                object.traverse(traverse);
                return this;
            }
                ;
        }(),
        containsPoint: function (point) {
            return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
        },
        containsBox: function (box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
        },
        getParameter: function (point, target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .getParameter() target is now required');
                target = new Vector3();
            }
            return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
        },
        intersectsBox: function (box) {
            return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
        },
        intersectsSphere: (function () {
            var closestPoint = new Vector3();
            return function intersectsSphere(sphere) {
                this.clampPoint(sphere.center, closestPoint);
                return closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
            }
                ;
        }
        )(),
        intersectsPlane: function (plane) {
            var min, max;
            if (plane.normal.x > 0) {
                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
            } else {
                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
            }
            if (plane.normal.y > 0) {
                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
            } else {
                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
            }
            if (plane.normal.z > 0) {
                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
            } else {
                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
            }
            return (min <= plane.constant && max >= plane.constant);
        },
        intersectsTriangle: (function () {
            var v0 = new Vector3();
            var v1 = new Vector3();
            var v2 = new Vector3();
            var f0 = new Vector3();
            var f1 = new Vector3();
            var f2 = new Vector3();
            var testAxis = new Vector3();
            var center = new Vector3();
            var extents = new Vector3();
            var triangleNormal = new Vector3();
            function satForAxes(axes) {
                var i, j;
                for (i = 0,
                    j = axes.length - 3; i <= j; i += 3) {
                    testAxis.fromArray(axes, i);
                    var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
                    var p0 = v0.dot(testAxis);
                    var p1 = v1.dot(testAxis);
                    var p2 = v2.dot(testAxis);
                    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                        return false;
                    }
                }
                return true;
            }
            return function intersectsTriangle(triangle) {
                if (this.isEmpty()) {
                    return false;
                }
                this.getCenter(center);
                extents.subVectors(this.max, center);
                v0.subVectors(triangle.a, center);
                v1.subVectors(triangle.b, center);
                v2.subVectors(triangle.c, center);
                f0.subVectors(v1, v0);
                f1.subVectors(v2, v1);
                f2.subVectors(v0, v2);
                var axes = [0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y, f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x, -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0];
                if (!satForAxes(axes)) {
                    return false;
                }
                axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                if (!satForAxes(axes)) {
                    return false;
                }
                triangleNormal.crossVectors(f0, f1);
                axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];
                return satForAxes(axes);
            }
                ;
        }
        )(),
        clampPoint: function (point, target) {
            if (target === undefined) {
                console.warn('THREE.Box3: .clampPoint() target is now required');
                target = new Vector3();
            }
            return target.copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function () {
            var v1 = new Vector3();
            return function distanceToPoint(point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
            }
                ;
        }(),
        getBoundingSphere: function () {
            var v1 = new Vector3();
            return function getBoundingSphere(target) {
                if (target === undefined) {
                    console.warn('THREE.Box3: .getBoundingSphere() target is now required');
                    target = new Sphere();
                }
                this.getCenter(target.center);
                target.radius = this.getSize(v1).length() * 0.5;
                return target;
            }
                ;
        }(),
        intersect: function (box) {
            this.min.max(box.min);
            this.max.min(box.max);
            if (this.isEmpty())
                this.makeEmpty();
            return this;
        },
        union: function (box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        },
        applyMatrix4: function (matrix) {
            if (this.isEmpty())
                return this;
            var m = matrix.elements;
            var xax = m[0] * this.min.x
                , xay = m[1] * this.min.x
                , xaz = m[2] * this.min.x;
            var xbx = m[0] * this.max.x
                , xby = m[1] * this.max.x
                , xbz = m[2] * this.max.x;
            var yax = m[4] * this.min.y
                , yay = m[5] * this.min.y
                , yaz = m[6] * this.min.y;
            var ybx = m[4] * this.max.y
                , yby = m[5] * this.max.y
                , ybz = m[6] * this.max.y;
            var zax = m[8] * this.min.z
                , zay = m[9] * this.min.z
                , zaz = m[10] * this.min.z;
            var zbx = m[8] * this.max.z
                , zby = m[9] * this.max.z
                , zbz = m[10] * this.max.z;
            this.min.x = Math.min(xax, xbx) + Math.min(yax, ybx) + Math.min(zax, zbx) + m[12];
            this.min.y = Math.min(xay, xby) + Math.min(yay, yby) + Math.min(zay, zby) + m[13];
            this.min.z = Math.min(xaz, xbz) + Math.min(yaz, ybz) + Math.min(zaz, zbz) + m[14];
            this.max.x = Math.max(xax, xbx) + Math.max(yax, ybx) + Math.max(zax, zbx) + m[12];
            this.max.y = Math.max(xay, xby) + Math.max(yay, yby) + Math.max(zay, zby) + m[13];
            this.max.z = Math.max(xaz, xbz) + Math.max(yaz, ybz) + Math.max(zaz, zbz) + m[14];
            return this;
        },
        translate: function (offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        },
        equals: function (box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    });
    function Sphere(center, radius) {
        this.center = (center !== undefined) ? center : new Vector3();
        this.radius = (radius !== undefined) ? radius : 0;
    }
    Object.assign(Sphere.prototype, {
        set: function (center, radius) {
            this.center.copy(center);
            this.radius = radius;
            return this;
        },
        setFromPoints: function () {
            var box = new Box3();
            return function setFromPoints(points, optionalCenter) {
                var center = this.center;
                if (optionalCenter !== undefined) {
                    center.copy(optionalCenter);
                } else {
                    box.setFromPoints(points).getCenter(center);
                }
                var maxRadiusSq = 0;
                for (var i = 0, il = points.length; i < il; i++) {
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                }
                this.radius = Math.sqrt(maxRadiusSq);
                return this;
            }
                ;
        }(),
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (sphere) {
            this.center.copy(sphere.center);
            this.radius = sphere.radius;
            return this;
        },
        empty: function () {
            return (this.radius <= 0);
        },
        containsPoint: function (point) {
            return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
        },
        distanceToPoint: function (point) {
            return (point.distanceTo(this.center) - this.radius);
        },
        intersectsSphere: function (sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
        },
        intersectsBox: function (box) {
            return box.intersectsSphere(this);
        },
        intersectsPlane: function (plane) {
            return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
        },
        clampPoint: function (point, target) {
            var deltaLengthSq = this.center.distanceToSquared(point);
            if (target === undefined) {
                console.warn('THREE.Sphere: .clampPoint() target is now required');
                target = new Vector3();
            }
            target.copy(point);
            if (deltaLengthSq > (this.radius * this.radius)) {
                target.sub(this.center).normalize();
                target.multiplyScalar(this.radius).add(this.center);
            }
            return target;
        },
        getBoundingBox: function (target) {
            if (target === undefined) {
                console.warn('THREE.Sphere: .getBoundingBox() target is now required');
                target = new Box3();
            }
            target.set(this.center, this.center);
            target.expandByScalar(this.radius);
            return target;
        },
        applyMatrix4: function (matrix) {
            this.center.applyMatrix4(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        },
        translate: function (offset) {
            this.center.add(offset);
            return this;
        },
        equals: function (sphere) {
            return sphere.center.equals(this.center) && (sphere.radius === this.radius);
        }
    });
    function Plane(normal, constant) {
        this.normal = (normal !== undefined) ? normal : new Vector3(1, 0, 0);
        this.constant = (constant !== undefined) ? constant : 0;
    }
    Object.assign(Plane.prototype, {
        set: function (normal, constant) {
            this.normal.copy(normal);
            this.constant = constant;
            return this;
        },
        setComponents: function (x, y, z, w) {
            this.normal.set(x, y, z);
            this.constant = w;
            return this;
        },
        setFromNormalAndCoplanarPoint: function (normal, point) {
            this.normal.copy(normal);
            this.constant = -point.dot(this.normal);
            return this;
        },
        setFromCoplanarPoints: function () {
            var v1 = new Vector3();
            var v2 = new Vector3();
            return function setFromCoplanarPoints(a, b, c) {
                var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
                this.setFromNormalAndCoplanarPoint(normal, a);
                return this;
            }
                ;
        }(),
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (plane) {
            this.normal.copy(plane.normal);
            this.constant = plane.constant;
            return this;
        },
        normalize: function () {
            var inverseNormalLength = 1.0 / this.normal.length();
            this.normal.multiplyScalar(inverseNormalLength);
            this.constant *= inverseNormalLength;
            return this;
        },
        negate: function () {
            this.constant *= -1;
            this.normal.negate();
            return this;
        },
        distanceToPoint: function (point) {
            return this.normal.dot(point) + this.constant;
        },
        distanceToSphere: function (sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        },
        projectPoint: function (point, target) {
            if (target === undefined) {
                console.warn('THREE.Plane: .projectPoint() target is now required');
                target = new Vector3();
            }
            return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
        },
        intersectLine: function () {
            var v1 = new Vector3();
            return function intersectLine(line, target) {
                if (target === undefined) {
                    console.warn('THREE.Plane: .intersectLine() target is now required');
                    target = new Vector3();
                }
                var direction = line.delta(v1);
                var denominator = this.normal.dot(direction);
                if (denominator === 0) {
                    if (this.distanceToPoint(line.start) === 0) {
                        return target.copy(line.start);
                    }
                    return undefined;
                }
                var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                if (t < 0 || t > 1) {
                    return undefined;
                }
                return target.copy(direction).multiplyScalar(t).add(line.start);
            }
                ;
        }(),
        intersectsLine: function (line) {
            var startSign = this.distanceToPoint(line.start);
            var endSign = this.distanceToPoint(line.end);
            return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
        },
        intersectsBox: function (box) {
            return box.intersectsPlane(this);
        },
        intersectsSphere: function (sphere) {
            return sphere.intersectsPlane(this);
        },
        coplanarPoint: function (target) {
            if (target === undefined) {
                console.warn('THREE.Plane: .coplanarPoint() target is now required');
                target = new Vector3();
            }
            return target.copy(this.normal).multiplyScalar(-this.constant);
        },
        applyMatrix4: function () {
            var v1 = new Vector3();
            var m1 = new Matrix3();
            return function applyMatrix4(matrix, optionalNormalMatrix) {
                var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
                var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
                var normal = this.normal.applyMatrix3(normalMatrix).normalize();
                this.constant = -referencePoint.dot(normal);
                return this;
            }
                ;
        }(),
        translate: function (offset) {
            this.constant -= offset.dot(this.normal);
            return this;
        },
        equals: function (plane) {
            return plane.normal.equals(this.normal) && (plane.constant === this.constant);
        }
    });
    function Frustum(p0, p1, p2, p3, p4, p5) {
        this.planes = [(p0 !== undefined) ? p0 : new Plane(), (p1 !== undefined) ? p1 : new Plane(), (p2 !== undefined) ? p2 : new Plane(), (p3 !== undefined) ? p3 : new Plane(), (p4 !== undefined) ? p4 : new Plane(), (p5 !== undefined) ? p5 : new Plane()];
    }
    Object.assign(Frustum.prototype, {
        set: function (p0, p1, p2, p3, p4, p5) {
            var planes = this.planes;
            planes[0].copy(p0);
            planes[1].copy(p1);
            planes[2].copy(p2);
            planes[3].copy(p3);
            planes[4].copy(p4);
            planes[5].copy(p5);
            return this;
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (frustum) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                planes[i].copy(frustum.planes[i]);
            }
            return this;
        },
        setFromMatrix: function (m) {
            var planes = this.planes;
            var me = m.elements;
            var me0 = me[0]
                , me1 = me[1]
                , me2 = me[2]
                , me3 = me[3];
            var me4 = me[4]
                , me5 = me[5]
                , me6 = me[6]
                , me7 = me[7];
            var me8 = me[8]
                , me9 = me[9]
                , me10 = me[10]
                , me11 = me[11];
            var me12 = me[12]
                , me13 = me[13]
                , me14 = me[14]
                , me15 = me[15];
            planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
            return this;
        },
        intersectsObject: function () {
            var sphere = new Sphere();
            return function intersectsObject(object) {
                var geometry = object.geometry;
                if (geometry.boundingSphere === null)
                    geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
                return this.intersectsSphere(sphere);
            }
                ;
        }(),
        intersectsSprite: function () {
            var sphere = new Sphere();
            return function intersectsSprite(sprite) {
                sphere.center.set(0, 0, 0);
                sphere.radius = 0.7071067811865476;
                sphere.applyMatrix4(sprite.matrixWorld);
                return this.intersectsSphere(sphere);
            }
                ;
        }(),
        intersectsSphere: function (sphere) {
            var planes = this.planes;
            var center = sphere.center;
            var negRadius = -sphere.radius;
            for (var i = 0; i < 6; i++) {
                var distance = planes[i].distanceToPoint(center);
                if (distance < negRadius) {
                    return false;
                }
            }
            return true;
        },
        intersectsBox: function () {
            var p1 = new Vector3()
                , p2 = new Vector3();
            return function intersectsBox(box) {
                var planes = this.planes;
                for (var i = 0; i < 6; i++) {
                    var plane = planes[i];
                    p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                    p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                    p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                    p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                    p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                    p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                    var d1 = plane.distanceToPoint(p1);
                    var d2 = plane.distanceToPoint(p2);
                    if (d1 < 0 && d2 < 0) {
                        return false;
                    }
                }
                return true;
            }
                ;
        }(),
        containsPoint: function (point) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                if (planes[i].distanceToPoint(point) < 0) {
                    return false;
                }
            }
            return true;
        }
    });
    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
    var begin_vertex = "\nvec3 transformed = vec3( position );\n";
    var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
    var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n";
    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
    var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
    var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";
    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
    var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";
    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
    var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";
    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
    var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
    var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";
    var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";
    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";
    var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";
    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
    var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n";
    var lights_pars_maps = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
    var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n";
    var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n";
    var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
    var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";
    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
    var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
    var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";
    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";
    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
    var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n";
    var normal_fragment_maps = "#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
    var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";
    var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";
    var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";
    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";
    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";
    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
    var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
    var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
    var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";
    var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";
    var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";
    var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";
    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
    var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";
    var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";
    var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
    var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
    var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";
    var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";
    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n";
    var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";
    var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
    var ShaderChunk = {
        alphamap_fragment: alphamap_fragment,
        alphamap_pars_fragment: alphamap_pars_fragment,
        alphatest_fragment: alphatest_fragment,
        aomap_fragment: aomap_fragment,
        aomap_pars_fragment: aomap_pars_fragment,
        begin_vertex: begin_vertex,
        beginnormal_vertex: beginnormal_vertex,
        bsdfs: bsdfs,
        bumpmap_pars_fragment: bumpmap_pars_fragment,
        clipping_planes_fragment: clipping_planes_fragment,
        clipping_planes_pars_fragment: clipping_planes_pars_fragment,
        clipping_planes_pars_vertex: clipping_planes_pars_vertex,
        clipping_planes_vertex: clipping_planes_vertex,
        color_fragment: color_fragment,
        color_pars_fragment: color_pars_fragment,
        color_pars_vertex: color_pars_vertex,
        color_vertex: color_vertex,
        common: common,
        cube_uv_reflection_fragment: cube_uv_reflection_fragment,
        defaultnormal_vertex: defaultnormal_vertex,
        displacementmap_pars_vertex: displacementmap_pars_vertex,
        displacementmap_vertex: displacementmap_vertex,
        emissivemap_fragment: emissivemap_fragment,
        emissivemap_pars_fragment: emissivemap_pars_fragment,
        encodings_fragment: encodings_fragment,
        encodings_pars_fragment: encodings_pars_fragment,
        envmap_fragment: envmap_fragment,
        envmap_pars_fragment: envmap_pars_fragment,
        envmap_pars_vertex: envmap_pars_vertex,
        envmap_vertex: envmap_vertex,
        fog_vertex: fog_vertex,
        fog_pars_vertex: fog_pars_vertex,
        fog_fragment: fog_fragment,
        fog_pars_fragment: fog_pars_fragment,
        gradientmap_pars_fragment: gradientmap_pars_fragment,
        lightmap_fragment: lightmap_fragment,
        lightmap_pars_fragment: lightmap_pars_fragment,
        lights_lambert_vertex: lights_lambert_vertex,
        lights_pars_begin: lights_pars_begin,
        lights_pars_maps: lights_pars_maps,
        lights_phong_fragment: lights_phong_fragment,
        lights_phong_pars_fragment: lights_phong_pars_fragment,
        lights_physical_fragment: lights_physical_fragment,
        lights_physical_pars_fragment: lights_physical_pars_fragment,
        lights_fragment_begin: lights_fragment_begin,
        lights_fragment_maps: lights_fragment_maps,
        lights_fragment_end: lights_fragment_end,
        logdepthbuf_fragment: logdepthbuf_fragment,
        logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
        logdepthbuf_vertex: logdepthbuf_vertex,
        map_fragment: map_fragment,
        map_pars_fragment: map_pars_fragment,
        map_particle_fragment: map_particle_fragment,
        map_particle_pars_fragment: map_particle_pars_fragment,
        metalnessmap_fragment: metalnessmap_fragment,
        metalnessmap_pars_fragment: metalnessmap_pars_fragment,
        morphnormal_vertex: morphnormal_vertex,
        morphtarget_pars_vertex: morphtarget_pars_vertex,
        morphtarget_vertex: morphtarget_vertex,
        normal_fragment_begin: normal_fragment_begin,
        normal_fragment_maps: normal_fragment_maps,
        normalmap_pars_fragment: normalmap_pars_fragment,
        packing: packing,
        premultiplied_alpha_fragment: premultiplied_alpha_fragment,
        project_vertex: project_vertex,
        dithering_fragment: dithering_fragment,
        dithering_pars_fragment: dithering_pars_fragment,
        roughnessmap_fragment: roughnessmap_fragment,
        roughnessmap_pars_fragment: roughnessmap_pars_fragment,
        shadowmap_pars_fragment: shadowmap_pars_fragment,
        shadowmap_pars_vertex: shadowmap_pars_vertex,
        shadowmap_vertex: shadowmap_vertex,
        shadowmask_pars_fragment: shadowmask_pars_fragment,
        skinbase_vertex: skinbase_vertex,
        skinning_pars_vertex: skinning_pars_vertex,
        skinning_vertex: skinning_vertex,
        skinnormal_vertex: skinnormal_vertex,
        specularmap_fragment: specularmap_fragment,
        specularmap_pars_fragment: specularmap_pars_fragment,
        tonemapping_fragment: tonemapping_fragment,
        tonemapping_pars_fragment: tonemapping_pars_fragment,
        uv_pars_fragment: uv_pars_fragment,
        uv_pars_vertex: uv_pars_vertex,
        uv_vertex: uv_vertex,
        uv2_pars_fragment: uv2_pars_fragment,
        uv2_pars_vertex: uv2_pars_vertex,
        uv2_vertex: uv2_vertex,
        worldpos_vertex: worldpos_vertex,
        cube_frag: cube_frag,
        cube_vert: cube_vert,
        depth_frag: depth_frag,
        depth_vert: depth_vert,
        distanceRGBA_frag: distanceRGBA_frag,
        distanceRGBA_vert: distanceRGBA_vert,
        equirect_frag: equirect_frag,
        equirect_vert: equirect_vert,
        linedashed_frag: linedashed_frag,
        linedashed_vert: linedashed_vert,
        meshbasic_frag: meshbasic_frag,
        meshbasic_vert: meshbasic_vert,
        meshlambert_frag: meshlambert_frag,
        meshlambert_vert: meshlambert_vert,
        meshphong_frag: meshphong_frag,
        meshphong_vert: meshphong_vert,
        meshphysical_frag: meshphysical_frag,
        meshphysical_vert: meshphysical_vert,
        normal_frag: normal_frag,
        normal_vert: normal_vert,
        points_frag: points_frag,
        points_vert: points_vert,
        shadow_frag: shadow_frag,
        shadow_vert: shadow_vert
    };
    var UniformsUtils = {
        merge: function (uniforms) {
            var merged = {};
            for (var u = 0; u < uniforms.length; u++) {
                var tmp = this.clone(uniforms[u]);
                for (var p in tmp) {
                    merged[p] = tmp[p];
                }
            }
            return merged;
        },
        clone: function (uniforms_src) {
            var uniforms_dst = {};
            for (var u in uniforms_src) {
                uniforms_dst[u] = {};
                for (var p in uniforms_src[u]) {
                    var parameter_src = uniforms_src[u][p];
                    if (parameter_src && (parameter_src.isColor || parameter_src.isMatrix3 || parameter_src.isMatrix4 || parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 || parameter_src.isTexture)) {
                        uniforms_dst[u][p] = parameter_src.clone();
                    } else if (Array.isArray(parameter_src)) {
                        uniforms_dst[u][p] = parameter_src.slice();
                    } else {
                        uniforms_dst[u][p] = parameter_src;
                    }
                }
            }
            return uniforms_dst;
        }
    };
    var ColorKeywords = {
        'aliceblue': 0xF0F8FF,
        'antiquewhite': 0xFAEBD7,
        'aqua': 0x00FFFF,
        'aquamarine': 0x7FFFD4,
        'azure': 0xF0FFFF,
        'beige': 0xF5F5DC,
        'bisque': 0xFFE4C4,
        'black': 0x000000,
        'blanchedalmond': 0xFFEBCD,
        'blue': 0x0000FF,
        'blueviolet': 0x8A2BE2,
        'brown': 0xA52A2A,
        'burlywood': 0xDEB887,
        'cadetblue': 0x5F9EA0,
        'chartreuse': 0x7FFF00,
        'chocolate': 0xD2691E,
        'coral': 0xFF7F50,
        'cornflowerblue': 0x6495ED,
        'cornsilk': 0xFFF8DC,
        'crimson': 0xDC143C,
        'cyan': 0x00FFFF,
        'darkblue': 0x00008B,
        'darkcyan': 0x008B8B,
        'darkgoldenrod': 0xB8860B,
        'darkgray': 0xA9A9A9,
        'darkgreen': 0x006400,
        'darkgrey': 0xA9A9A9,
        'darkkhaki': 0xBDB76B,
        'darkmagenta': 0x8B008B,
        'darkolivegreen': 0x556B2F,
        'darkorange': 0xFF8C00,
        'darkorchid': 0x9932CC,
        'darkred': 0x8B0000,
        'darksalmon': 0xE9967A,
        'darkseagreen': 0x8FBC8F,
        'darkslateblue': 0x483D8B,
        'darkslategray': 0x2F4F4F,
        'darkslategrey': 0x2F4F4F,
        'darkturquoise': 0x00CED1,
        'darkviolet': 0x9400D3,
        'deeppink': 0xFF1493,
        'deepskyblue': 0x00BFFF,
        'dimgray': 0x696969,
        'dimgrey': 0x696969,
        'dodgerblue': 0x1E90FF,
        'firebrick': 0xB22222,
        'floralwhite': 0xFFFAF0,
        'forestgreen': 0x228B22,
        'fuchsia': 0xFF00FF,
        'gainsboro': 0xDCDCDC,
        'ghostwhite': 0xF8F8FF,
        'gold': 0xFFD700,
        'goldenrod': 0xDAA520,
        'gray': 0x808080,
        'green': 0x008000,
        'greenyellow': 0xADFF2F,
        'grey': 0x808080,
        'honeydew': 0xF0FFF0,
        'hotpink': 0xFF69B4,
        'indianred': 0xCD5C5C,
        'indigo': 0x4B0082,
        'ivory': 0xFFFFF0,
        'khaki': 0xF0E68C,
        'lavender': 0xE6E6FA,
        'lavenderblush': 0xFFF0F5,
        'lawngreen': 0x7CFC00,
        'lemonchiffon': 0xFFFACD,
        'lightblue': 0xADD8E6,
        'lightcoral': 0xF08080,
        'lightcyan': 0xE0FFFF,
        'lightgoldenrodyellow': 0xFAFAD2,
        'lightgray': 0xD3D3D3,
        'lightgreen': 0x90EE90,
        'lightgrey': 0xD3D3D3,
        'lightpink': 0xFFB6C1,
        'lightsalmon': 0xFFA07A,
        'lightseagreen': 0x20B2AA,
        'lightskyblue': 0x87CEFA,
        'lightslategray': 0x778899,
        'lightslategrey': 0x778899,
        'lightsteelblue': 0xB0C4DE,
        'lightyellow': 0xFFFFE0,
        'lime': 0x00FF00,
        'limegreen': 0x32CD32,
        'linen': 0xFAF0E6,
        'magenta': 0xFF00FF,
        'maroon': 0x800000,
        'mediumaquamarine': 0x66CDAA,
        'mediumblue': 0x0000CD,
        'mediumorchid': 0xBA55D3,
        'mediumpurple': 0x9370DB,
        'mediumseagreen': 0x3CB371,
        'mediumslateblue': 0x7B68EE,
        'mediumspringgreen': 0x00FA9A,
        'mediumturquoise': 0x48D1CC,
        'mediumvioletred': 0xC71585,
        'midnightblue': 0x191970,
        'mintcream': 0xF5FFFA,
        'mistyrose': 0xFFE4E1,
        'moccasin': 0xFFE4B5,
        'navajowhite': 0xFFDEAD,
        'navy': 0x000080,
        'oldlace': 0xFDF5E6,
        'olive': 0x808000,
        'olivedrab': 0x6B8E23,
        'orange': 0xFFA500,
        'orangered': 0xFF4500,
        'orchid': 0xDA70D6,
        'palegoldenrod': 0xEEE8AA,
        'palegreen': 0x98FB98,
        'paleturquoise': 0xAFEEEE,
        'palevioletred': 0xDB7093,
        'papayawhip': 0xFFEFD5,
        'peachpuff': 0xFFDAB9,
        'peru': 0xCD853F,
        'pink': 0xFFC0CB,
        'plum': 0xDDA0DD,
        'powderblue': 0xB0E0E6,
        'purple': 0x800080,
        'rebeccapurple': 0x663399,
        'red': 0xFF0000,
        'rosybrown': 0xBC8F8F,
        'royalblue': 0x4169E1,
        'saddlebrown': 0x8B4513,
        'salmon': 0xFA8072,
        'sandybrown': 0xF4A460,
        'seagreen': 0x2E8B57,
        'seashell': 0xFFF5EE,
        'sienna': 0xA0522D,
        'silver': 0xC0C0C0,
        'skyblue': 0x87CEEB,
        'slateblue': 0x6A5ACD,
        'slategray': 0x708090,
        'slategrey': 0x708090,
        'snow': 0xFFFAFA,
        'springgreen': 0x00FF7F,
        'steelblue': 0x4682B4,
        'tan': 0xD2B48C,
        'teal': 0x008080,
        'thistle': 0xD8BFD8,
        'tomato': 0xFF6347,
        'turquoise': 0x40E0D0,
        'violet': 0xEE82EE,
        'wheat': 0xF5DEB3,
        'white': 0xFFFFFF,
        'whitesmoke': 0xF5F5F5,
        'yellow': 0xFFFF00,
        'yellowgreen': 0x9ACD32
    };
    function Color(r, g, b) {
        if (g === undefined && b === undefined) {
            return this.set(r);
        }
        return this.setRGB(r, g, b);
    }
    Object.assign(Color.prototype, {
        isColor: true,
        r: 1,
        g: 1,
        b: 1,
        set: function (value) {
            if (value && value.isColor) {
                this.copy(value);
            } else if (typeof value === 'number') {
                this.setHex(value);
            } else if (typeof value === 'string') {
                this.setStyle(value);
            }
            return this;
        },
        setScalar: function (scalar) {
            this.r = scalar;
            this.g = scalar;
            this.b = scalar;
            return this;
        },
        setHex: function (hex) {
            hex = Math.floor(hex);
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        },
        setRGB: function (r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
            return this;
        },
        setHSL: function () {
            function hue2rgb(p, q, t) {
                if (t < 0)
                    t += 1;
                if (t > 1)
                    t -= 1;
                if (t < 1 / 6)
                    return p + (q - p) * 6 * t;
                if (t < 1 / 2)
                    return q;
                if (t < 2 / 3)
                    return p + (q - p) * 6 * (2 / 3 - t);
                return p;
            }
            return function setHSL(h, s, l) {
                h = _Math.euclideanModulo(h, 1);
                s = _Math.clamp(s, 0, 1);
                l = _Math.clamp(l, 0, 1);
                if (s === 0) {
                    this.r = this.g = this.b = l;
                } else {
                    var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
                    var q = (2 * l) - p;
                    this.r = hue2rgb(q, p, h + 1 / 3);
                    this.g = hue2rgb(q, p, h);
                    this.b = hue2rgb(q, p, h - 1 / 3);
                }
                return this;
            }
                ;
        }(),
        setStyle: function (style) {
            function handleAlpha(string) {
                if (string === undefined)
                    return;
                if (parseFloat(string) < 1) {
                    console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
                }
            }
            var m;
            if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
                var color;
                var name = m[1];
                var components = m[2];
                switch (name) {
                    case 'rgb':
                    case 'rgba':
                        if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                            handleAlpha(color[5]);
                            return this;
                        }
                        if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                            handleAlpha(color[5]);
                            return this;
                        }
                        break;
                    case 'hsl':
                    case 'hsla':
                        if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                            var h = parseFloat(color[1]) / 360;
                            var s = parseInt(color[2], 10) / 100;
                            var l = parseInt(color[3], 10) / 100;
                            handleAlpha(color[5]);
                            return this.setHSL(h, s, l);
                        }
                        break;
                }
            } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
                var hex = m[1];
                var size = hex.length;
                if (size === 3) {
                    this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                    this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                    this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                    return this;
                } else if (size === 6) {
                    this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                    this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                    this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                    return this;
                }
            }
            if (style && style.length > 0) {
                var hex = ColorKeywords[style];
                if (hex !== undefined) {
                    this.setHex(hex);
                } else {
                    console.warn('THREE.Color: Unknown color ' + style);
                }
            }
            return this;
        },
        clone: function () {
            return new this.constructor(this.r, this.g, this.b);
        },
        copy: function (color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            return this;
        },
        copyGammaToLinear: function (color, gammaFactor) {
            if (gammaFactor === undefined)
                gammaFactor = 2.0;
            this.r = Math.pow(color.r, gammaFactor);
            this.g = Math.pow(color.g, gammaFactor);
            this.b = Math.pow(color.b, gammaFactor);
            return this;
        },
        copyLinearToGamma: function (color, gammaFactor) {
            if (gammaFactor === undefined)
                gammaFactor = 2.0;
            var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
            this.r = Math.pow(color.r, safeInverse);
            this.g = Math.pow(color.g, safeInverse);
            this.b = Math.pow(color.b, safeInverse);
            return this;
        },
        convertGammaToLinear: function (gammaFactor) {
            this.copyGammaToLinear(this, gammaFactor);
            return this;
        },
        convertLinearToGamma: function (gammaFactor) {
            this.copyLinearToGamma(this, gammaFactor);
            return this;
        },
        getHex: function () {
            return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
        },
        getHexString: function () {
            return ('000000' + this.getHex().toString(16)).slice(-6);
        },
        getHSL: function (target) {
            if (target === undefined) {
                console.warn('THREE.Color: .getHSL() target is now required');
                target = {
                    h: 0,
                    s: 0,
                    l: 0
                };
            }
            var r = this.r
                , g = this.g
                , b = this.b;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var hue, saturation;
            var lightness = (min + max) / 2.0;
            if (min === max) {
                hue = 0;
                saturation = 0;
            } else {
                var delta = max - min;
                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                switch (max) {
                    case r:
                        hue = (g - b) / delta + (g < b ? 6 : 0);
                        break;
                    case g:
                        hue = (b - r) / delta + 2;
                        break;
                    case b:
                        hue = (r - g) / delta + 4;
                        break;
                }
                hue /= 6;
            }
            target.h = hue;
            target.s = saturation;
            target.l = lightness;
            return target;
        },
        getStyle: function () {
            return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
        },
        offsetHSL: function () {
            var hsl = {};
            return function (h, s, l) {
                this.getHSL(hsl);
                hsl.h += h;
                hsl.s += s;
                hsl.l += l;
                this.setHSL(hsl.h, hsl.s, hsl.l);
                return this;
            }
                ;
        }(),
        add: function (color) {
            this.r += color.r;
            this.g += color.g;
            this.b += color.b;
            return this;
        },
        addColors: function (color1, color2) {
            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;
            return this;
        },
        addScalar: function (s) {
            this.r += s;
            this.g += s;
            this.b += s;
            return this;
        },
        sub: function (color) {
            this.r = Math.max(0, this.r - color.r);
            this.g = Math.max(0, this.g - color.g);
            this.b = Math.max(0, this.b - color.b);
            return this;
        },
        multiply: function (color) {
            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;
            return this;
        },
        multiplyScalar: function (s) {
            this.r *= s;
            this.g *= s;
            this.b *= s;
            return this;
        },
        lerp: function (color, alpha) {
            this.r += (color.r - this.r) * alpha;
            this.g += (color.g - this.g) * alpha;
            this.b += (color.b - this.b) * alpha;
            return this;
        },
        equals: function (c) {
            return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
        },
        fromArray: function (array, offset) {
            if (offset === undefined)
                offset = 0;
            this.r = array[offset];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            return this;
        },
        toArray: function (array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this.r;
            array[offset + 1] = this.g;
            array[offset + 2] = this.b;
            return array;
        },
        toJSON: function () {
            return this.getHex();
        }
    });
    var UniformsLib = {
        common: {
            diffuse: {
                value: new Color(0xeeeeee)
            },
            opacity: {
                value: 1.0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Matrix3()
            },
            alphaMap: {
                value: null
            },
        },
        specularmap: {
            specularMap: {
                value: null
            },
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1.0
            },
            refractionRatio: {
                value: 0.98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 0.00025
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2000
            },
            fogColor: {
                value: new Color(0xffffff)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new Color(0xeeeeee)
            },
            opacity: {
                value: 1.0
            },
            size: {
                value: 1.0
            },
            scale: {
                value: 1.0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new Matrix3()
            }
        }
    };
    var ShaderLib = {
        basic: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
        },
        lambert: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0x000000)
                }
            }]),
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
        },
        phong: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0x000000)
                },
                specular: {
                    value: new Color(0x111111)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
        },
        standard: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
                emissive: {
                    value: new Color(0x000000)
                },
                roughness: {
                    value: 0.5
                },
                metalness: {
                    value: 0.5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
        },
        points: {
            uniforms: UniformsUtils.merge([UniformsLib.points, UniformsLib.fog]),
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
        },
        dashed: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
        },
        depth: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.displacementmap]),
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
        },
        normal: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
                opacity: {
                    value: 1.0
                }
            }]),
            vertexShader: ShaderChunk.normal_vert,
            fragmentShader: ShaderChunk.normal_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1.0
                }
            },
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                },
            },
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
        },
        distanceRGBA: {
            uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.displacementmap, {
                referencePosition: {
                    value: new Vector3()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }]),
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
        },
        shadow: {
            uniforms: UniformsUtils.merge([UniformsLib.lights, UniformsLib.fog, {
                color: {
                    value: new Color(0x00000)
                },
                opacity: {
                    value: 1.0
                }
            },]),
            vertexShader: ShaderChunk.shadow_vert,
            fragmentShader: ShaderChunk.shadow_frag
        }
    };
    ShaderLib.physical = {
        uniforms: UniformsUtils.merge([ShaderLib.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    };
    function WebGLAnimation() {
        var context = null;
        var isAnimating = false;
        var animationLoop = null;
        function onAnimationFrame(time, frame) {
            if (isAnimating === false)
                return;
            animationLoop(time, frame);
            context.requestAnimationFrame(onAnimationFrame);
        }
        return {
            start: function () {
                if (isAnimating === true)
                    return;
                if (animationLoop === null)
                    return;
                context.requestAnimationFrame(onAnimationFrame);
                isAnimating = true;
            },
            stop: function () {
                isAnimating = false;
            },
            setAnimationLoop: function (callback) {
                animationLoop = callback;
            },
            setContext: function (value) {
                context = value;
            }
        };
    }
    function WebGLAttributes(gl) {
        var buffers = new WeakMap();
        function createBuffer(attribute, bufferType) {
            var array = attribute.array;
            var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
            var buffer = gl.createBuffer();
            gl.bindBuffer(bufferType, buffer);
            gl.bufferData(bufferType, array, usage);
            attribute.onUploadCallback();
            var type = gl.FLOAT;
            if (array instanceof Float32Array) {
                type = gl.FLOAT;
            } else if (array instanceof Float64Array) {
                console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
            } else if (array instanceof Uint16Array) {
                type = gl.UNSIGNED_SHORT;
            } else if (array instanceof Int16Array) {
                type = gl.SHORT;
            } else if (array instanceof Uint32Array) {
                type = gl.UNSIGNED_INT;
            } else if (array instanceof Int32Array) {
                type = gl.INT;
            } else if (array instanceof Int8Array) {
                type = gl.BYTE;
            } else if (array instanceof Uint8Array) {
                type = gl.UNSIGNED_BYTE;
            }
            return {
                buffer: buffer,
                type: type,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version
            };
        }
        function updateBuffer(buffer, attribute, bufferType) {
            var array = attribute.array;
            var updateRange = attribute.updateRange;
            gl.bindBuffer(bufferType, buffer);
            if (attribute.dynamic === false) {
                gl.bufferData(bufferType, array, gl.STATIC_DRAW);
            } else if (updateRange.count === -1) {
                gl.bufferSubData(bufferType, 0, array);
            } else if (updateRange.count === 0) {
                console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
            } else {
                gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
                updateRange.count = -1;
            }
        }
        function get(attribute) {
            if (attribute.isInterleavedBufferAttribute)
                attribute = attribute.data;
            return buffers.get(attribute);
        }
        function remove(attribute) {
            if (attribute.isInterleavedBufferAttribute)
                attribute = attribute.data;
            var data = buffers.get(attribute);
            if (data) {
                gl.deleteBuffer(data.buffer);
                buffers.delete(attribute);
            }
        }
        function update(attribute, bufferType) {
            if (attribute.isInterleavedBufferAttribute)
                attribute = attribute.data;
            var data = buffers.get(attribute);
            if (data === undefined) {
                buffers.set(attribute, createBuffer(attribute, bufferType));
            } else if (data.version < attribute.version) {
                updateBuffer(data.buffer, attribute, bufferType);
                data.version = attribute.version;
            }
        }
        return {
            get: get,
            remove: remove,
            update: update
        };
    }
    function Euler(x, y, z, order) {
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._order = order || Euler.DefaultOrder;
    }
    Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
    Euler.DefaultOrder = 'XYZ';
    Object.defineProperties(Euler.prototype, {
        x: {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
                this.onChangeCallback();
            }
        },
        y: {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
                this.onChangeCallback();
            }
        },
        z: {
            get: function () {
                return this._z;
            },
            set: function (value) {
                this._z = value;
                this.onChangeCallback();
            }
        },
        order: {
            get: function () {
                return this._order;
            },
            set: function (value) {
                this._order = value;
                this.onChangeCallback();
            }
        }
    });
    Object.assign(Euler.prototype, {
        isEuler: true,
        set: function (x, y, z, order) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order || this._order;
            this.onChangeCallback();
            return this;
        },
        clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order);
        },
        copy: function (euler) {
            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;
            this.onChangeCallback();
            return this;
        },
        setFromRotationMatrix: function (m, order, update) {
            var clamp = _Math.clamp;
            var te = m.elements;
            var m11 = te[0]
                , m12 = te[4]
                , m13 = te[8];
            var m21 = te[1]
                , m22 = te[5]
                , m23 = te[9];
            var m31 = te[2]
                , m32 = te[6]
                , m33 = te[10];
            order = order || this._order;
            if (order === 'XYZ') {
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.99999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
            } else if (order === 'YXZ') {
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.99999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
            } else if (order === 'ZXY') {
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.99999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
            } else if (order === 'ZYX') {
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.99999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
            } else if (order === 'YZX') {
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.99999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
            } else if (order === 'XZY') {
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.99999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
            } else {
                console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
            }
            this._order = order;
            if (update !== false)
                this.onChangeCallback();
            return this;
        },
        setFromQuaternion: function () {
            var matrix = new Matrix4();
            return function setFromQuaternion(q, order, update) {
                matrix.makeRotationFromQuaternion(q);
                return this.setFromRotationMatrix(matrix, order, update);
            }
                ;
        }(),
        setFromVector3: function (v, order) {
            return this.set(v.x, v.y, v.z, order || this._order);
        },
        reorder: function () {
            var q = new Quaternion();
            return function reorder(newOrder) {
                q.setFromEuler(this);
                return this.setFromQuaternion(q, newOrder);
            }
                ;
        }(),
        equals: function (euler) {
            return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
        },
        fromArray: function (array) {
            this._x = array[0];
            this._y = array[1];
            this._z = array[2];
            if (array[3] !== undefined)
                this._order = array[3];
            this.onChangeCallback();
            return this;
        },
        toArray: function (array, offset) {
            if (array === undefined)
                array = [];
            if (offset === undefined)
                offset = 0;
            array[offset] = this._x;
            array[offset + 1] = this._y;
            array[offset + 2] = this._z;
            array[offset + 3] = this._order;
            return array;
        },
        toVector3: function (optionalResult) {
            if (optionalResult) {
                return optionalResult.set(this._x, this._y, this._z);
            } else {
                return new Vector3(this._x, this._y, this._z);
            }
        },
        onChange: function (callback) {
            this.onChangeCallback = callback;
            return this;
        },
        onChangeCallback: function () { }
    });
    function Layers() {
        this.mask = 1 | 0;
    }
    Object.assign(Layers.prototype, {
        set: function (channel) {
            this.mask = 1 << channel | 0;
        },
        enable: function (channel) {
            this.mask |= 1 << channel | 0;
        },
        toggle: function (channel) {
            this.mask ^= 1 << channel | 0;
        },
        disable: function (channel) {
            this.mask &= ~(1 << channel | 0);
        },
        test: function (layers) {
            return (this.mask & layers.mask) !== 0;
        }
    });
    var object3DId = 0;
    function Object3D() {
        Object.defineProperty(this, 'id', {
            value: object3DId++
        });
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'Object3D';
        this.parent = null;
        this.children = [];
        this.up = Object3D.DefaultUp.clone();
        var position = new Vector3();
        var rotation = new Euler();
        var quaternion = new Quaternion();
        var scale = new Vector3(1, 1, 1);
        function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, undefined, false);
        }
        rotation.onChange(onRotationChange);
        quaternion.onChange(onQuaternionChange);
        Object.defineProperties(this, {
            position: {
                enumerable: true,
                value: position
            },
            rotation: {
                enumerable: true,
                value: rotation
            },
            quaternion: {
                enumerable: true,
                value: quaternion
            },
            scale: {
                enumerable: true,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        });
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.userData = {};
    }
    Object3D.DefaultUp = new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Object3D,
        isObject3D: true,
        onBeforeRender: function () { },
        onAfterRender: function () { },
        applyMatrix: function (matrix) {
            this.matrix.multiplyMatrices(matrix, this.matrix);
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        },
        applyQuaternion: function (q) {
            this.quaternion.premultiply(q);
            return this;
        },
        setRotationFromAxisAngle: function (axis, angle) {
            this.quaternion.setFromAxisAngle(axis, angle);
        },
        setRotationFromEuler: function (euler) {
            this.quaternion.setFromEuler(euler, true);
        },
        setRotationFromMatrix: function (m) {
            this.quaternion.setFromRotationMatrix(m);
        },
        setRotationFromQuaternion: function (q) {
            this.quaternion.copy(q);
        },
        rotateOnAxis: function () {
            var q1 = new Quaternion();
            return function rotateOnAxis(axis, angle) {
                q1.setFromAxisAngle(axis, angle);
                this.quaternion.multiply(q1);
                return this;
            }
                ;
        }(),
        rotateOnWorldAxis: function () {
            var q1 = new Quaternion();
            return function rotateOnWorldAxis(axis, angle) {
                q1.setFromAxisAngle(axis, angle);
                this.quaternion.premultiply(q1);
                return this;
            }
                ;
        }(),
        rotateX: function () {
            var v1 = new Vector3(1, 0, 0);
            return function rotateX(angle) {
                return this.rotateOnAxis(v1, angle);
            }
                ;
        }(),
        rotateY: function () {
            var v1 = new Vector3(0, 1, 0);
            return function rotateY(angle) {
                return this.rotateOnAxis(v1, angle);
            }
                ;
        }(),
        rotateZ: function () {
            var v1 = new Vector3(0, 0, 1);
            return function rotateZ(angle) {
                return this.rotateOnAxis(v1, angle);
            }
                ;
        }(),
        translateOnAxis: function () {
            var v1 = new Vector3();
            return function translateOnAxis(axis, distance) {
                v1.copy(axis).applyQuaternion(this.quaternion);
                this.position.add(v1.multiplyScalar(distance));
                return this;
            }
                ;
        }(),
        translateX: function () {
            var v1 = new Vector3(1, 0, 0);
            return function translateX(distance) {
                return this.translateOnAxis(v1, distance);
            }
                ;
        }(),
        translateY: function () {
            var v1 = new Vector3(0, 1, 0);
            return function translateY(distance) {
                return this.translateOnAxis(v1, distance);
            }
                ;
        }(),
        translateZ: function () {
            var v1 = new Vector3(0, 0, 1);
            return function translateZ(distance) {
                return this.translateOnAxis(v1, distance);
            }
                ;
        }(),
        localToWorld: function (vector) {
            return vector.applyMatrix4(this.matrixWorld);
        },
        worldToLocal: function () {
            var m1 = new Matrix4();
            return function worldToLocal(vector) {
                return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
            }
                ;
        }(),
        lookAt: function () {
            var m1 = new Matrix4();
            var vector = new Vector3();
            return function lookAt(x, y, z) {
                if (x.isVector3) {
                    vector.copy(x);
                } else {
                    vector.set(x, y, z);
                }
                if (this.isCamera) {
                    m1.lookAt(this.position, vector, this.up);
                } else {
                    m1.lookAt(vector, this.position, this.up);
                }
                this.quaternion.setFromRotationMatrix(m1);
            }
                ;
        }(),
        add: function (object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.add(arguments[i]);
                }
                return this;
            }
            if (object === this) {
                console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
                return this;
            }
            if ((object && object.isObject3D)) {
                if (object.parent !== null) {
                    object.parent.remove(object);
                }
                object.parent = this;
                object.dispatchEvent({
                    type: 'added'
                });
                this.children.push(object);
            } else {
                console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
            }
            return this;
        },
        remove: function (object) {
            if (arguments.length > 1) {
                for (var i = 0; i < arguments.length; i++) {
                    this.remove(arguments[i]);
                }
                return this;
            }
            var index = this.children.indexOf(object);
            if (index !== -1) {
                object.parent = null;
                object.dispatchEvent({
                    type: 'removed'
                });
                this.children.splice(index, 1);
            }
            return this;
        },
        getObjectById: function (id) {
            return this.getObjectByProperty('id', id);
        },
        getObjectByName: function (name) {
            return this.getObjectByProperty('name', name);
        },
        getObjectByProperty: function (name, value) {
            if (this[name] === value)
                return this;
            for (var i = 0, l = this.children.length; i < l; i++) {
                var child = this.children[i];
                var object = child.getObjectByProperty(name, value);
                if (object !== undefined) {
                    return object;
                }
            }
            return undefined;
        },
        getWorldPosition: function (target) {
            if (target === undefined) {
                console.warn('THREE.Object3D: .getWorldPosition() target is now required');
                target = new Vector3();
            }
            this.updateMatrixWorld(true);
            return target.setFromMatrixPosition(this.matrixWorld);
        },
        getWorldQuaternion: function () {
            var position = new Vector3();
            var scale = new Vector3();
            return function getWorldQuaternion(target) {
                if (target === undefined) {
                    console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
                    target = new Quaternion();
                }
                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(position, target, scale);
                return target;
            }
                ;
        }(),
        getWorldScale: function () {
            var position = new Vector3();
            var quaternion = new Quaternion();
            return function getWorldScale(target) {
                if (target === undefined) {
                    console.warn('THREE.Object3D: .getWorldScale() target is now required');
                    target = new Vector3();
                }
                this.updateMatrixWorld(true);
                this.matrixWorld.decompose(position, quaternion, target);
                return target;
            }
                ;
        }(),
        getWorldDirection: function () {
            var quaternion = new Quaternion();
            return function getWorldDirection(target) {
                if (target === undefined) {
                    console.warn('THREE.Object3D: .getWorldDirection() target is now required');
                    target = new Vector3();
                }
                this.getWorldQuaternion(quaternion);
                return target.set(0, 0, 1).applyQuaternion(quaternion);
            }
                ;
        }(),
        raycast: function () { },
        traverse: function (callback) {
            callback(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverse(callback);
            }
        },
        traverseVisible: function (callback) {
            if (this.visible === false)
                return;
            callback(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].traverseVisible(callback);
            }
        },
        traverseAncestors: function (callback) {
            var parent = this.parent;
            if (parent !== null) {
                callback(parent);
                parent.traverseAncestors(callback);
            }
        },
        updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale);
            this.matrixWorldNeedsUpdate = true;
        },
        updateMatrixWorld: function (force) {
            if (this.matrixAutoUpdate)
                this.updateMatrix();
            if (this.matrixWorldNeedsUpdate || force) {
                if (this.parent === null) {
                    this.matrixWorld.copy(this.matrix);
                } else {
                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                }
                this.matrixWorldNeedsUpdate = false;
                force = true;
            }
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].updateMatrixWorld(force);
            }
        },
        toJSON: function (meta) {
            var isRootObject = (meta === undefined || typeof meta === 'string');
            var output = {};
            if (isRootObject) {
                meta = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                };
                output.metadata = {
                    version: 4.5,
                    type: 'Object',
                    generator: 'Object3D.toJSON'
                };
            }
            var object = {};
            object.uuid = this.uuid;
            object.type = this.type;
            if (this.name !== '')
                object.name = this.name;
            if (this.castShadow === true)
                object.castShadow = true;
            if (this.receiveShadow === true)
                object.receiveShadow = true;
            if (this.visible === false)
                object.visible = false;
            if (this.frustumCulled === false)
                object.frustumCulled = false;
            if (this.renderOrder !== 0)
                object.renderOrder = this.renderOrder;
            if (JSON.stringify(this.userData) !== '{}')
                object.userData = this.userData;
            object.matrix = this.matrix.toArray();
            if (this.matrixAutoUpdate === false)
                object.matrixAutoUpdate = false;
            function serialize(library, element) {
                if (library[element.uuid] === undefined) {
                    library[element.uuid] = element.toJSON(meta);
                }
                return element.uuid;
            }
            if (this.geometry !== undefined) {
                object.geometry = serialize(meta.geometries, this.geometry);
                var parameters = this.geometry.parameters;
                if (parameters !== undefined && parameters.shapes !== undefined) {
                    var shapes = parameters.shapes;
                    if (Array.isArray(shapes)) {
                        for (var i = 0, l = shapes.length; i < l; i++) {
                            var shape = shapes[i];
                            serialize(meta.shapes, shape);
                        }
                    } else {
                        serialize(meta.shapes, shapes);
                    }
                }
            }
            if (this.material !== undefined) {
                if (Array.isArray(this.material)) {
                    var uuids = [];
                    for (var i = 0, l = this.material.length; i < l; i++) {
                        uuids.push(serialize(meta.materials, this.material[i]));
                    }
                    object.material = uuids;
                } else {
                    object.material = serialize(meta.materials, this.material);
                }
            }
            if (this.children.length > 0) {
                object.children = [];
                for (var i = 0; i < this.children.length; i++) {
                    object.children.push(this.children[i].toJSON(meta).object);
                }
            }
            if (isRootObject) {
                var geometries = extractFromCache(meta.geometries);
                var materials = extractFromCache(meta.materials);
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                var shapes = extractFromCache(meta.shapes);
                if (geometries.length > 0)
                    output.geometries = geometries;
                if (materials.length > 0)
                    output.materials = materials;
                if (textures.length > 0)
                    output.textures = textures;
                if (images.length > 0)
                    output.images = images;
                if (shapes.length > 0)
                    output.shapes = shapes;
            }
            output.object = object;
            return output;
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
        },
        clone: function (recursive) {
            return new this.constructor().copy(this, recursive);
        },
        copy: function (source, recursive) {
            if (recursive === undefined)
                recursive = true;
            this.name = source.name;
            this.up.copy(source.up);
            this.position.copy(source.position);
            this.quaternion.copy(source.quaternion);
            this.scale.copy(source.scale);
            this.matrix.copy(source.matrix);
            this.matrixWorld.copy(source.matrixWorld);
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
            this.layers.mask = source.layers.mask;
            this.visible = source.visible;
            this.castShadow = source.castShadow;
            this.receiveShadow = source.receiveShadow;
            this.frustumCulled = source.frustumCulled;
            this.renderOrder = source.renderOrder;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            if (recursive === true) {
                for (var i = 0; i < source.children.length; i++) {
                    var child = source.children[i];
                    this.add(child.clone());
                }
            }
            return this;
        }
    });
    function Camera() {
        Object3D.call(this);
        this.type = 'Camera';
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
    }
    Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Camera,
        isCamera: true,
        copy: function (source, recursive) {
            Object3D.prototype.copy.call(this, source, recursive);
            this.matrixWorldInverse.copy(source.matrixWorldInverse);
            this.projectionMatrix.copy(source.projectionMatrix);
            return this;
        },
        getWorldDirection: function () {
            var quaternion = new Quaternion();
            return function getWorldDirection(target) {
                if (target === undefined) {
                    console.warn('THREE.Camera: .getWorldDirection() target is now required');
                    target = new Vector3();
                }
                this.getWorldQuaternion(quaternion);
                return target.set(0, 0, -1).applyQuaternion(quaternion);
            }
                ;
        }(),
        updateMatrixWorld: function (force) {
            Object3D.prototype.updateMatrixWorld.call(this, force);
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        },
        clone: function () {
            return new this.constructor().copy(this);
        }
    });
    function OrthographicCamera(left, right, top, bottom, near, far) {
        Camera.call(this);
        this.type = 'OrthographicCamera';
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = (near !== undefined) ? near : 0.1;
        this.far = (far !== undefined) ? far : 2000;
        this.updateProjectionMatrix();
    }
    OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: OrthographicCamera,
        isOrthographicCamera: true,
        copy: function (source, recursive) {
            Camera.prototype.copy.call(this, source, recursive);
            this.left = source.left;
            this.right = source.right;
            this.top = source.top;
            this.bottom = source.bottom;
            this.near = source.near;
            this.far = source.far;
            this.zoom = source.zoom;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            return this;
        },
        setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
            if (this.view === null) {
                this.view = {
                    enabled: true,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                };
            }
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
            this.updateProjectionMatrix();
        },
        clearViewOffset: function () {
            if (this.view !== null) {
                this.view.enabled = false;
            }
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function () {
            var dx = (this.right - this.left) / (2 * this.zoom);
            var dy = (this.top - this.bottom) / (2 * this.zoom);
            var cx = (this.right + this.left) / 2;
            var cy = (this.top + this.bottom) / 2;
            var left = cx - dx;
            var right = cx + dx;
            var top = cy + dy;
            var bottom = cy - dy;
            if (this.view !== null && this.view.enabled) {
                var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
                var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
                var scaleW = (this.right - this.left) / this.view.width;
                var scaleH = (this.top - this.bottom) / this.view.height;
                left += scaleW * (this.view.offsetX / zoomW);
                right = left + scaleW * (this.view.width / zoomW);
                top -= scaleH * (this.view.offsetY / zoomH);
                bottom = top - scaleH * (this.view.height / zoomH);
            }
            this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        },
        toJSON: function (meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.zoom = this.zoom;
            data.object.left = this.left;
            data.object.right = this.right;
            data.object.top = this.top;
            data.object.bottom = this.bottom;
            data.object.near = this.near;
            data.object.far = this.far;
            if (this.view !== null)
                data.object.view = Object.assign({}, this.view);
            return data;
        }
    });
    function Face3(a, b, c, normal, color, materialIndex) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.normal = (normal && normal.isVector3) ? normal : new Vector3();
        this.vertexNormals = Array.isArray(normal) ? normal : [];
        this.color = (color && color.isColor) ? color : new Color();
        this.vertexColors = Array.isArray(color) ? color : [];
        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    }
    Object.assign(Face3.prototype, {
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (source) {
            this.a = source.a;
            this.b = source.b;
            this.c = source.c;
            this.normal.copy(source.normal);
            this.color.copy(source.color);
            this.materialIndex = source.materialIndex;
            for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
                this.vertexNormals[i] = source.vertexNormals[i].clone();
            }
            for (var i = 0, il = source.vertexColors.length; i < il; i++) {
                this.vertexColors[i] = source.vertexColors[i].clone();
            }
            return this;
        }
    });
    var geometryId = 0;
    function Geometry() {
        Object.defineProperty(this, 'id', {
            value: geometryId += 2
        });
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'Geometry';
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.elementsNeedUpdate = false;
        this.verticesNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.lineDistancesNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Geometry,
        isGeometry: true,
        applyMatrix: function (matrix) {
            var normalMatrix = new Matrix3().getNormalMatrix(matrix);
            for (var i = 0, il = this.vertices.length; i < il; i++) {
                var vertex = this.vertices[i];
                vertex.applyMatrix4(matrix);
            }
            for (var i = 0, il = this.faces.length; i < il; i++) {
                var face = this.faces[i];
                face.normal.applyMatrix3(normalMatrix).normalize();
                for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                    face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
                }
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            this.verticesNeedUpdate = true;
            this.normalsNeedUpdate = true;
            return this;
        },
        rotateX: function () {
            var m1 = new Matrix4();
            return function rotateX(angle) {
                m1.makeRotationX(angle);
                this.applyMatrix(m1);
                return this;
            }
                ;
        }(),
        rotateY: function () {
            var m1 = new Matrix4();
            return function rotateY(angle) {
                m1.makeRotationY(angle);
                this.applyMatrix(m1);
                return this;
            }
                ;
        }(),
        rotateZ: function () {
            var m1 = new Matrix4();
            return function rotateZ(angle) {
                m1.makeRotationZ(angle);
                this.applyMatrix(m1);
                return this;
            }
                ;
        }(),
        translate: function () {
            var m1 = new Matrix4();
            return function translate(x, y, z) {
                m1.makeTranslation(x, y, z);
                this.applyMatrix(m1);
                return this;
            }
                ;
        }(),
        scale: function () {
            var m1 = new Matrix4();
            return function scale(x, y, z) {
                m1.makeScale(x, y, z);
                this.applyMatrix(m1);
                return this;
            }
                ;
        }(),
        lookAt: function () {
            var obj = new Object3D();
            return function lookAt(vector) {
                obj.lookAt(vector);
                obj.updateMatrix();
                this.applyMatrix(obj.matrix);
            }
                ;
        }(),
        fromBufferGeometry: function (geometry) {
            var scope = this;
            var indices = geometry.index !== null ? geometry.index.array : undefined;
            var attributes = geometry.attributes;
            var positions = attributes.position.array;
            var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
            var colors = attributes.color !== undefined ? attributes.color.array : undefined;
            var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
            var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
            if (uvs2 !== undefined)
                this.faceVertexUvs[1] = [];
            var tempNormals = [];
            var tempUVs = [];
            var tempUVs2 = [];
            for (var i = 0, j = 0; i < positions.length; i += 3,
                j += 2) {
                scope.vertices.push(new Vector3(positions[i], positions[i + 1], positions[i + 2]));
                if (normals !== undefined) {
                    tempNormals.push(new Vector3(normals[i], normals[i + 1], normals[i + 2]));
                }
                if (colors !== undefined) {
                    scope.colors.push(new Color(colors[i], colors[i + 1], colors[i + 2]));
                }
                if (uvs !== undefined) {
                    tempUVs.push(new Vector2(uvs[j], uvs[j + 1]));
                }
                if (uvs2 !== undefined) {
                    tempUVs2.push(new Vector2(uvs2[j], uvs2[j + 1]));
                }
            }
            function addFace(a, b, c, materialIndex) {
                var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
                var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
                var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
                scope.faces.push(face);
                if (uvs !== undefined) {
                    scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
                }
                if (uvs2 !== undefined) {
                    scope.faceVertexUvs[1].push([tempUVs2[a].clone(), tempUVs2[b].clone(), tempUVs2[c].clone()]);
                }
            }
            var groups = geometry.groups;
            if (groups.length > 0) {
                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    var start = group.start;
                    var count = group.count;
                    for (var j = start, jl = start + count; j < jl; j += 3) {
                        if (indices !== undefined) {
                            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
                        } else {
                            addFace(j, j + 1, j + 2, group.materialIndex);
                        }
                    }
                }
            } else {
                if (indices !== undefined) {
                    for (var i = 0; i < indices.length; i += 3) {
                        addFace(indices[i], indices[i + 1], indices[i + 2]);
                    }
                } else {
                    for (var i = 0; i < positions.length / 3; i += 3) {
                        addFace(i, i + 1, i + 2);
                    }
                }
            }
            this.computeFaceNormals();
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            return this;
        },
        center: function () {
            var offset = new Vector3();
            return function center() {
                this.computeBoundingBox();
                this.boundingBox.getCenter(offset).negate();
                this.translate(offset.x, offset.y, offset.z);
                return this;
            }
                ;
        }(),
        normalize: function () {
            this.computeBoundingSphere();
            var center = this.boundingSphere.center;
            var radius = this.boundingSphere.radius;
            var s = radius === 0 ? 1 : 1.0 / radius;
            var matrix = new Matrix4();
            matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
            this.applyMatrix(matrix);
            return this;
        },
        computeFaceNormals: function () {
            var cb = new Vector3()
                , ab = new Vector3();
            for (var f = 0, fl = this.faces.length; f < fl; f++) {
                var face = this.faces[f];
                var vA = this.vertices[face.a];
                var vB = this.vertices[face.b];
                var vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                cb.normalize();
                face.normal.copy(cb);
            }
        },
        computeVertexNormals: function (areaWeighted) {
            if (areaWeighted === undefined)
                areaWeighted = true;
            var v, vl, f, fl, face, vertices;
            vertices = new Array(this.vertices.length);
            for (v = 0,
                vl = this.vertices.length; v < vl; v++) {
                vertices[v] = new Vector3();
            }
            if (areaWeighted) {
                var vA, vB, vC;
                var cb = new Vector3()
                    , ab = new Vector3();
                for (f = 0,
                    fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    vA = this.vertices[face.a];
                    vB = this.vertices[face.b];
                    vC = this.vertices[face.c];
                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb.cross(ab);
                    vertices[face.a].add(cb);
                    vertices[face.b].add(cb);
                    vertices[face.c].add(cb);
                }
            } else {
                this.computeFaceNormals();
                for (f = 0,
                    fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    vertices[face.a].add(face.normal);
                    vertices[face.b].add(face.normal);
                    vertices[face.c].add(face.normal);
                }
            }
            for (v = 0,
                vl = this.vertices.length; v < vl; v++) {
                vertices[v].normalize();
            }
            for (f = 0,
                fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(vertices[face.a]);
                    vertexNormals[1].copy(vertices[face.b]);
                    vertexNormals[2].copy(vertices[face.c]);
                } else {
                    vertexNormals[0] = vertices[face.a].clone();
                    vertexNormals[1] = vertices[face.b].clone();
                    vertexNormals[2] = vertices[face.c].clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        },
        computeFlatVertexNormals: function () {
            var f, fl, face;
            this.computeFaceNormals();
            for (f = 0,
                fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    vertexNormals[0].copy(face.normal);
                    vertexNormals[1].copy(face.normal);
                    vertexNormals[2].copy(face.normal);
                } else {
                    vertexNormals[0] = face.normal.clone();
                    vertexNormals[1] = face.normal.clone();
                    vertexNormals[2] = face.normal.clone();
                }
            }
            if (this.faces.length > 0) {
                this.normalsNeedUpdate = true;
            }
        },
        computeMorphNormals: function () {
            var i, il, f, fl, face;
            for (f = 0,
                fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                if (!face.__originalFaceNormal) {
                    face.__originalFaceNormal = face.normal.clone();
                } else {
                    face.__originalFaceNormal.copy(face.normal);
                }
                if (!face.__originalVertexNormals)
                    face.__originalVertexNormals = [];
                for (i = 0,
                    il = face.vertexNormals.length; i < il; i++) {
                    if (!face.__originalVertexNormals[i]) {
                        face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
                    } else {
                        face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
                    }
                }
            }
            var tmpGeo = new Geometry();
            tmpGeo.faces = this.faces;
            for (i = 0,
                il = this.morphTargets.length; i < il; i++) {
                if (!this.morphNormals[i]) {
                    this.morphNormals[i] = {};
                    this.morphNormals[i].faceNormals = [];
                    this.morphNormals[i].vertexNormals = [];
                    var dstNormalsFace = this.morphNormals[i].faceNormals;
                    var dstNormalsVertex = this.morphNormals[i].vertexNormals;
                    var faceNormal, vertexNormals;
                    for (f = 0,
                        fl = this.faces.length; f < fl; f++) {
                        faceNormal = new Vector3();
                        vertexNormals = {
                            a: new Vector3(),
                            b: new Vector3(),
                            c: new Vector3()
                        };
                        dstNormalsFace.push(faceNormal);
                        dstNormalsVertex.push(vertexNormals);
                    }
                }
                var morphNormals = this.morphNormals[i];
                tmpGeo.vertices = this.morphTargets[i].vertices;
                tmpGeo.computeFaceNormals();
                tmpGeo.computeVertexNormals();
                var faceNormal, vertexNormals;
                for (f = 0,
                    fl = this.faces.length; f < fl; f++) {
                    face = this.faces[f];
                    faceNormal = morphNormals.faceNormals[f];
                    vertexNormals = morphNormals.vertexNormals[f];
                    faceNormal.copy(face.normal);
                    vertexNormals.a.copy(face.vertexNormals[0]);
                    vertexNormals.b.copy(face.vertexNormals[1]);
                    vertexNormals.c.copy(face.vertexNormals[2]);
                }
            }
            for (f = 0,
                fl = this.faces.length; f < fl; f++) {
                face = this.faces[f];
                face.normal = face.__originalFaceNormal;
                face.vertexNormals = face.__originalVertexNormals;
            }
        },
        computeBoundingBox: function () {
            if (this.boundingBox === null) {
                this.boundingBox = new Box3();
            }
            this.boundingBox.setFromPoints(this.vertices);
        },
        computeBoundingSphere: function () {
            if (this.boundingSphere === null) {
                this.boundingSphere = new Sphere();
            }
            this.boundingSphere.setFromPoints(this.vertices);
        },
        merge: function (geometry, matrix, materialIndexOffset) {
            if (!(geometry && geometry.isGeometry)) {
                console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
                return;
            }
            var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry.colors;
            if (materialIndexOffset === undefined)
                materialIndexOffset = 0;
            if (matrix !== undefined) {
                normalMatrix = new Matrix3().getNormalMatrix(matrix);
            }
            for (var i = 0, il = vertices2.length; i < il; i++) {
                var vertex = vertices2[i];
                var vertexCopy = vertex.clone();
                if (matrix !== undefined)
                    vertexCopy.applyMatrix4(matrix);
                vertices1.push(vertexCopy);
            }
            for (var i = 0, il = colors2.length; i < il; i++) {
                colors1.push(colors2[i].clone());
            }
            for (i = 0,
                il = faces2.length; i < il; i++) {
                var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
                faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
                faceCopy.normal.copy(face.normal);
                if (normalMatrix !== undefined) {
                    faceCopy.normal.applyMatrix3(normalMatrix).normalize();
                }
                for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
                    normal = faceVertexNormals[j].clone();
                    if (normalMatrix !== undefined) {
                        normal.applyMatrix3(normalMatrix).normalize();
                    }
                    faceCopy.vertexNormals.push(normal);
                }
                faceCopy.color.copy(face.color);
                for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
                    color = faceVertexColors[j];
                    faceCopy.vertexColors.push(color.clone());
                }
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
                faces1.push(faceCopy);
            }
            for (i = 0,
                il = uvs2.length; i < il; i++) {
                var uv = uvs2[i]
                    , uvCopy = [];
                if (uv === undefined) {
                    continue;
                }
                for (var j = 0, jl = uv.length; j < jl; j++) {
                    uvCopy.push(uv[j].clone());
                }
                uvs1.push(uvCopy);
            }
        },
        mergeMesh: function (mesh) {
            if (!(mesh && mesh.isMesh)) {
                console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
                return;
            }
            if (mesh.matrixAutoUpdate)
                mesh.updateMatrix();
            this.merge(mesh.geometry, mesh.matrix);
        },
        mergeVertices: function () {
            var verticesMap = {};
            var unique = []
                , changes = [];
            var v, key;
            var precisionPoints = 4;
            var precision = Math.pow(10, precisionPoints);
            var i, il, face;
            var indices, j, jl;
            for (i = 0,
                il = this.vertices.length; i < il; i++) {
                v = this.vertices[i];
                key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
                if (verticesMap[key] === undefined) {
                    verticesMap[key] = i;
                    unique.push(this.vertices[i]);
                    changes[i] = unique.length - 1;
                } else {
                    changes[i] = changes[verticesMap[key]];
                }
            }
            var faceIndicesToRemove = [];
            for (i = 0,
                il = this.faces.length; i < il; i++) {
                face = this.faces[i];
                face.a = changes[face.a];
                face.b = changes[face.b];
                face.c = changes[face.c];
                indices = [face.a, face.b, face.c];
                for (var n = 0; n < 3; n++) {
                    if (indices[n] === indices[(n + 1) % 3]) {
                        faceIndicesToRemove.push(i);
                        break;
                    }
                }
            }
            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                this.faces.splice(idx, 1);
                for (j = 0,
                    jl = this.faceVertexUvs.length; j < jl; j++) {
                    this.faceVertexUvs[j].splice(idx, 1);
                }
            }
            var diff = this.vertices.length - unique.length;
            this.vertices = unique;
            return diff;
        },
        setFromPoints: function (points) {
            this.vertices = [];
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
            }
            return this;
        },
        sortFacesByMaterialIndex: function () {
            var faces = this.faces;
            var length = faces.length;
            for (var i = 0; i < length; i++) {
                faces[i]._id = i;
            }
            function materialIndexSort(a, b) {
                return a.materialIndex - b.materialIndex;
            }
            faces.sort(materialIndexSort);
            var uvs1 = this.faceVertexUvs[0];
            var uvs2 = this.faceVertexUvs[1];
            var newUvs1, newUvs2;
            if (uvs1 && uvs1.length === length)
                newUvs1 = [];
            if (uvs2 && uvs2.length === length)
                newUvs2 = [];
            for (var i = 0; i < length; i++) {
                var id = faces[i]._id;
                if (newUvs1)
                    newUvs1.push(uvs1[id]);
                if (newUvs2)
                    newUvs2.push(uvs2[id]);
            }
            if (newUvs1)
                this.faceVertexUvs[0] = newUvs1;
            if (newUvs2)
                this.faceVertexUvs[1] = newUvs2;
        },
        toJSON: function () {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Geometry',
                    generator: 'Geometry.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '')
                data.name = this.name;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                    if (parameters[key] !== undefined)
                        data[key] = parameters[key];
                }
                return data;
            }
            var vertices = [];
            for (var i = 0; i < this.vertices.length; i++) {
                var vertex = this.vertices[i];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
            var faces = [];
            var normals = [];
            var normalsHash = {};
            var colors = [];
            var colorsHash = {};
            var uvs = [];
            var uvsHash = {};
            for (var i = 0; i < this.faces.length; i++) {
                var face = this.faces[i];
                var hasMaterial = true;
                var hasFaceUv = false;
                var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
                var hasFaceNormal = face.normal.length() > 0;
                var hasFaceVertexNormal = face.vertexNormals.length > 0;
                var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                var hasFaceVertexColor = face.vertexColors.length > 0;
                var faceType = 0;
                faceType = setBit(faceType, 0, 0);
                faceType = setBit(faceType, 1, hasMaterial);
                faceType = setBit(faceType, 2, hasFaceUv);
                faceType = setBit(faceType, 3, hasFaceVertexUv);
                faceType = setBit(faceType, 4, hasFaceNormal);
                faceType = setBit(faceType, 5, hasFaceVertexNormal);
                faceType = setBit(faceType, 6, hasFaceColor);
                faceType = setBit(faceType, 7, hasFaceVertexColor);
                faces.push(faceType);
                faces.push(face.a, face.b, face.c);
                faces.push(face.materialIndex);
                if (hasFaceVertexUv) {
                    var faceVertexUvs = this.faceVertexUvs[0][i];
                    faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
                }
                if (hasFaceNormal) {
                    faces.push(getNormalIndex(face.normal));
                }
                if (hasFaceVertexNormal) {
                    var vertexNormals = face.vertexNormals;
                    faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
                }
                if (hasFaceColor) {
                    faces.push(getColorIndex(face.color));
                }
                if (hasFaceVertexColor) {
                    var vertexColors = face.vertexColors;
                    faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
                }
            }
            function setBit(value, position, enabled) {
                return enabled ? value | (1 << position) : value & (~(1 << position));
            }
            function getNormalIndex(normal) {
                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
                if (normalsHash[hash] !== undefined) {
                    return normalsHash[hash];
                }
                normalsHash[hash] = normals.length / 3;
                normals.push(normal.x, normal.y, normal.z);
                return normalsHash[hash];
            }
            function getColorIndex(color) {
                var hash = color.r.toString() + color.g.toString() + color.b.toString();
                if (colorsHash[hash] !== undefined) {
                    return colorsHash[hash];
                }
                colorsHash[hash] = colors.length;
                colors.push(color.getHex());
                return colorsHash[hash];
            }
            function getUvIndex(uv) {
                var hash = uv.x.toString() + uv.y.toString();
                if (uvsHash[hash] !== undefined) {
                    return uvsHash[hash];
                }
                uvsHash[hash] = uvs.length / 2;
                uvs.push(uv.x, uv.y);
                return uvsHash[hash];
            }
            data.data = {};
            data.data.vertices = vertices;
            data.data.normals = normals;
            if (colors.length > 0)
                data.data.colors = colors;
            if (uvs.length > 0)
                data.data.uvs = [uvs];
            data.data.faces = faces;
            return data;
        },
        clone: function () {
            return new Geometry().copy(this);
        },
        copy: function (source) {
            var i, il, j, jl, k, kl;
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.name = source.name;
            var vertices = source.vertices;
            for (i = 0,
                il = vertices.length; i < il; i++) {
                this.vertices.push(vertices[i].clone());
            }
            var colors = source.colors;
            for (i = 0,
                il = colors.length; i < il; i++) {
                this.colors.push(colors[i].clone());
            }
            var faces = source.faces;
            for (i = 0,
                il = faces.length; i < il; i++) {
                this.faces.push(faces[i].clone());
            }
            for (i = 0,
                il = source.faceVertexUvs.length; i < il; i++) {
                var faceVertexUvs = source.faceVertexUvs[i];
                if (this.faceVertexUvs[i] === undefined) {
                    this.faceVertexUvs[i] = [];
                }
                for (j = 0,
                    jl = faceVertexUvs.length; j < jl; j++) {
                    var uvs = faceVertexUvs[j]
                        , uvsCopy = [];
                    for (k = 0,
                        kl = uvs.length; k < kl; k++) {
                        var uv = uvs[k];
                        uvsCopy.push(uv.clone());
                    }
                    this.faceVertexUvs[i].push(uvsCopy);
                }
            }
            var morphTargets = source.morphTargets;
            for (i = 0,
                il = morphTargets.length; i < il; i++) {
                var morphTarget = {};
                morphTarget.name = morphTargets[i].name;
                if (morphTargets[i].vertices !== undefined) {
                    morphTarget.vertices = [];
                    for (j = 0,
                        jl = morphTargets[i].vertices.length; j < jl; j++) {
                        morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
                    }
                }
                if (morphTargets[i].normals !== undefined) {
                    morphTarget.normals = [];
                    for (j = 0,
                        jl = morphTargets[i].normals.length; j < jl; j++) {
                        morphTarget.normals.push(morphTargets[i].normals[j].clone());
                    }
                }
                this.morphTargets.push(morphTarget);
            }
            var morphNormals = source.morphNormals;
            for (i = 0,
                il = morphNormals.length; i < il; i++) {
                var morphNormal = {};
                if (morphNormals[i].vertexNormals !== undefined) {
                    morphNormal.vertexNormals = [];
                    for (j = 0,
                        jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
                        var srcVertexNormal = morphNormals[i].vertexNormals[j];
                        var destVertexNormal = {};
                        destVertexNormal.a = srcVertexNormal.a.clone();
                        destVertexNormal.b = srcVertexNormal.b.clone();
                        destVertexNormal.c = srcVertexNormal.c.clone();
                        morphNormal.vertexNormals.push(destVertexNormal);
                    }
                }
                if (morphNormals[i].faceNormals !== undefined) {
                    morphNormal.faceNormals = [];
                    for (j = 0,
                        jl = morphNormals[i].faceNormals.length; j < jl; j++) {
                        morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
                    }
                }
                this.morphNormals.push(morphNormal);
            }
            var skinWeights = source.skinWeights;
            for (i = 0,
                il = skinWeights.length; i < il; i++) {
                this.skinWeights.push(skinWeights[i].clone());
            }
            var skinIndices = source.skinIndices;
            for (i = 0,
                il = skinIndices.length; i < il; i++) {
                this.skinIndices.push(skinIndices[i].clone());
            }
            var lineDistances = source.lineDistances;
            for (i = 0,
                il = lineDistances.length; i < il; i++) {
                this.lineDistances.push(lineDistances[i]);
            }
            var boundingBox = source.boundingBox;
            if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
            }
            var boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
            }
            this.elementsNeedUpdate = source.elementsNeedUpdate;
            this.verticesNeedUpdate = source.verticesNeedUpdate;
            this.uvsNeedUpdate = source.uvsNeedUpdate;
            this.normalsNeedUpdate = source.normalsNeedUpdate;
            this.colorsNeedUpdate = source.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = source.groupsNeedUpdate;
            return this;
        },
        dispose: function () {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });
    function BufferAttribute(array, itemSize, normalized) {
        if (Array.isArray(array)) {
            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        }
        this.name = '';
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== undefined ? array.length / itemSize : 0;
        this.normalized = normalized === true;
        this.dynamic = false;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0;
    }
    Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
        set: function (value) {
            if (value === true)
                this.version++;
        }
    });
    Object.assign(BufferAttribute.prototype, {
        isBufferAttribute: true,
        onUploadCallback: function () { },
        setArray: function (array) {
            if (Array.isArray(array)) {
                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }
            this.count = array !== undefined ? array.length / this.itemSize : 0;
            this.array = array;
            return this;
        },
        setDynamic: function (value) {
            this.dynamic = value;
            return this;
        },
        copy: function (source) {
            this.name = source.name;
            this.array = new source.array.constructor(source.array);
            this.itemSize = source.itemSize;
            this.count = source.count;
            this.normalized = source.normalized;
            this.dynamic = source.dynamic;
            return this;
        },
        copyAt: function (index1, attribute, index2) {
            index1 *= this.itemSize;
            index2 *= attribute.itemSize;
            for (var i = 0, l = this.itemSize; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        },
        copyArray: function (array) {
            this.array.set(array);
            return this;
        },
        copyColorsArray: function (colors) {
            var array = this.array
                , offset = 0;
            for (var i = 0, l = colors.length; i < l; i++) {
                var color = colors[i];
                if (color === undefined) {
                    console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                    color = new Color();
                }
                array[offset++] = color.r;
                array[offset++] = color.g;
                array[offset++] = color.b;
            }
            return this;
        },
        copyVector2sArray: function (vectors) {
            var array = this.array
                , offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                    vector = new Vector2();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
            }
            return this;
        },
        copyVector3sArray: function (vectors) {
            var array = this.array
                , offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                    vector = new Vector3();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
            }
            return this;
        },
        copyVector4sArray: function (vectors) {
            var array = this.array
                , offset = 0;
            for (var i = 0, l = vectors.length; i < l; i++) {
                var vector = vectors[i];
                if (vector === undefined) {
                    console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                    vector = new Vector4();
                }
                array[offset++] = vector.x;
                array[offset++] = vector.y;
                array[offset++] = vector.z;
                array[offset++] = vector.w;
            }
            return this;
        },
        set: function (value, offset) {
            if (offset === undefined)
                offset = 0;
            this.array.set(value, offset);
            return this;
        },
        getX: function (index) {
            return this.array[index * this.itemSize];
        },
        setX: function (index, x) {
            this.array[index * this.itemSize] = x;
            return this;
        },
        getY: function (index) {
            return this.array[index * this.itemSize + 1];
        },
        setY: function (index, y) {
            this.array[index * this.itemSize + 1] = y;
            return this;
        },
        getZ: function (index) {
            return this.array[index * this.itemSize + 2];
        },
        setZ: function (index, z) {
            this.array[index * this.itemSize + 2] = z;
            return this;
        },
        getW: function (index) {
            return this.array[index * this.itemSize + 3];
        },
        setW: function (index, w) {
            this.array[index * this.itemSize + 3] = w;
            return this;
        },
        setXY: function (index, x, y) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            return this;
        },
        setXYZ: function (index, x, y, z) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            return this;
        },
        setXYZW: function (index, x, y, z, w) {
            index *= this.itemSize;
            this.array[index + 0] = x;
            this.array[index + 1] = y;
            this.array[index + 2] = z;
            this.array[index + 3] = w;
            return this;
        },
        onUpload: function (callback) {
            this.onUploadCallback = callback;
            return this;
        },
        clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this);
        }
    });
    function Int8BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
    }
    Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
    function Uint8BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
    }
    Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
    function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
    }
    Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
    function Int16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
    }
    Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
    function Uint16BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
    }
    Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
    function Int32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
    }
    Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
    function Uint32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
    }
    Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
    function Float32BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
    }
    Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
    function Float64BufferAttribute(array, itemSize, normalized) {
        BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
    }
    Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
    Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
    function DirectGeometry() {
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {};
        this.skinWeights = [];
        this.skinIndices = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
    Object.assign(DirectGeometry.prototype, {
        computeGroups: function (geometry) {
            var group;
            var groups = [];
            var materialIndex = undefined;
            var faces = geometry.faces;
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                if (face.materialIndex !== materialIndex) {
                    materialIndex = face.materialIndex;
                    if (group !== undefined) {
                        group.count = (i * 3) - group.start;
                        groups.push(group);
                    }
                    group = {
                        start: i * 3,
                        materialIndex: materialIndex
                    };
                }
            }
            if (group !== undefined) {
                group.count = (i * 3) - group.start;
                groups.push(group);
            }
            this.groups = groups;
        },
        fromGeometry: function (geometry) {
            var faces = geometry.faces;
            var vertices = geometry.vertices;
            var faceVertexUvs = geometry.faceVertexUvs;
            var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
            var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
            var morphTargets = geometry.morphTargets;
            var morphTargetsLength = morphTargets.length;
            var morphTargetsPosition;
            if (morphTargetsLength > 0) {
                morphTargetsPosition = [];
                for (var i = 0; i < morphTargetsLength; i++) {
                    morphTargetsPosition[i] = [];
                }
                this.morphTargets.position = morphTargetsPosition;
            }
            var morphNormals = geometry.morphNormals;
            var morphNormalsLength = morphNormals.length;
            var morphTargetsNormal;
            if (morphNormalsLength > 0) {
                morphTargetsNormal = [];
                for (var i = 0; i < morphNormalsLength; i++) {
                    morphTargetsNormal[i] = [];
                }
                this.morphTargets.normal = morphTargetsNormal;
            }
            var skinIndices = geometry.skinIndices;
            var skinWeights = geometry.skinWeights;
            var hasSkinIndices = skinIndices.length === vertices.length;
            var hasSkinWeights = skinWeights.length === vertices.length;
            if (faces.length === 0) {
                console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
            }
            for (var i = 0; i < faces.length; i++) {
                var face = faces[i];
                this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
                var vertexNormals = face.vertexNormals;
                if (vertexNormals.length === 3) {
                    this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
                } else {
                    var normal = face.normal;
                    this.normals.push(normal, normal, normal);
                }
                var vertexColors = face.vertexColors;
                if (vertexColors.length === 3) {
                    this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
                } else {
                    var color = face.color;
                    this.colors.push(color, color, color);
                }
                if (hasFaceVertexUv === true) {
                    var vertexUvs = faceVertexUvs[0][i];
                    if (vertexUvs !== undefined) {
                        this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    } else {
                        console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
                        this.uvs.push(new Vector2(), new Vector2(), new Vector2());
                    }
                }
                if (hasFaceVertexUv2 === true) {
                    var vertexUvs = faceVertexUvs[1][i];
                    if (vertexUvs !== undefined) {
                        this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                    } else {
                        console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
                        this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
                    }
                }
                for (var j = 0; j < morphTargetsLength; j++) {
                    var morphTarget = morphTargets[j].vertices;
                    morphTargetsPosition[j].push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
                }
                for (var j = 0; j < morphNormalsLength; j++) {
                    var morphNormal = morphNormals[j].vertexNormals[i];
                    morphTargetsNormal[j].push(morphNormal.a, morphNormal.b, morphNormal.c);
                }
                if (hasSkinIndices) {
                    this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
                }
                if (hasSkinWeights) {
                    this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
                }
            }
            this.computeGroups(geometry);
            this.verticesNeedUpdate = geometry.verticesNeedUpdate;
            this.normalsNeedUpdate = geometry.normalsNeedUpdate;
            this.colorsNeedUpdate = geometry.colorsNeedUpdate;
            this.uvsNeedUpdate = geometry.uvsNeedUpdate;
            this.groupsNeedUpdate = geometry.groupsNeedUpdate;
            return this;
        }
    });
    function arrayMax(array) {
        if (array.length === 0)
            return -Infinity;
        var max = array[0];
        for (var i = 1, l = array.length; i < l; ++i) {
            if (array[i] > max)
                max = array[i];
        }
        return max;
    }
    var bufferGeometryId = 1;
    function BufferGeometry() {
        Object.defineProperty(this, 'id', {
            value: bufferGeometryId += 2
        });
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'BufferGeometry';
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = {
            start: 0,
            count: Infinity
        };
        this.userData = {};
    }
    BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: BufferGeometry,
        isBufferGeometry: true,
        getIndex: function () {
            return this.index;
        },
        setIndex: function (index) {
            if (Array.isArray(index)) {
                this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
            } else {
                this.index = index;
            }
        },
        addAttribute: function (name, attribute) {
            if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
                console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
                return this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
            }
            if (name === 'index') {
                console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
                this.setIndex(attribute);
                return this;
            }
            this.attributes[name] = attribute;
            return this;
        },
        getAttribute: function (name) {
            return this.attributes[name];
        },
        removeAttribute: function (name) {
            delete this.attributes[name];
            return this;
        },
        addGroup: function (start, count, materialIndex) {
            this.groups.push({
                start: start,
                count: count,
                materialIndex: materialIndex !== undefined ? materialIndex : 0
            });
        },
        clearGroups: function () {
            this.groups = [];
        },
        setDrawRange: function (start, count) {
            this.drawRange.start = start;
            this.drawRange.count = count;
        },
        applyMatrix: function (matrix) {
            var position = this.attributes.position;
            if (position !== undefined) {
                matrix.applyToBufferAttribute(position);
                position.needsUpdate = true;
            }
            var normal = this.attributes.normal;
            if (normal !== undefined) {
                var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                normalMatrix.applyToBufferAttribute(normal);
                normal.needsUpdate = true;
            }
            if (this.boundingBox !== null) {
                this.computeBoundingBox();
            }
            if (this.boundingSphere !== null) {
                this.computeBoundingSphere();
            }
            return this;
        },
        rotateX: function () {
            var m1 = new Matrix4();
            return function rotateX(angle) {
                m1.makeRotationX(angle);
                this.applyMatrix(m1);
                return this;
            }
                ;
        }(),
        rotateY: function () {
            var m1 = new Matrix4();
            return function rotateY(angle) {
                m1.makeRotationY(angle);
                this.applyMatrix(m1);
                return this;
            }
                ;
        }(),
        rotateZ: function () {
            var m1 = new Matrix4();
            return function rotateZ(angle) {
                m1.makeRotationZ(angle);
                this.applyMatrix(m1);
                return this;
            }
                ;
        }(),
        translate: function () {
            var m1 = new Matrix4();
            return function translate(x, y, z) {
                m1.makeTranslation(x, y, z);
                this.applyMatrix(m1);
                return this;
            }
                ;
        }(),
        scale: function () {
            var m1 = new Matrix4();
            return function scale(x, y, z) {
                m1.makeScale(x, y, z);
                this.applyMatrix(m1);
                return this;
            }
                ;
        }(),
        lookAt: function () {
            var obj = new Object3D();
            return function lookAt(vector) {
                obj.lookAt(vector);
                obj.updateMatrix();
                this.applyMatrix(obj.matrix);
            }
                ;
        }(),
        center: function () {
            var offset = new Vector3();
            return function center() {
                this.computeBoundingBox();
                this.boundingBox.getCenter(offset).negate();
                this.translate(offset.x, offset.y, offset.z);
                return this;
            }
                ;
        }(),
        setFromObject: function (object) {
            var geometry = object.geometry;
            if (object.isPoints || object.isLine) {
                var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
                var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
                this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
                this.addAttribute('color', colors.copyColorsArray(geometry.colors));
                if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                    var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
                    this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
                }
                if (geometry.boundingSphere !== null) {
                    this.boundingSphere = geometry.boundingSphere.clone();
                }
                if (geometry.boundingBox !== null) {
                    this.boundingBox = geometry.boundingBox.clone();
                }
            } else if (object.isMesh) {
                if (geometry && geometry.isGeometry) {
                    this.fromGeometry(geometry);
                }
            }
            return this;
        },
        setFromPoints: function (points) {
            var position = [];
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                position.push(point.x, point.y, point.z || 0);
            }
            this.addAttribute('position', new Float32BufferAttribute(position, 3));
            return this;
        },
        updateFromObject: function (object) {
            var geometry = object.geometry;
            if (object.isMesh) {
                var direct = geometry.__directGeometry;
                if (geometry.elementsNeedUpdate === true) {
                    direct = undefined;
                    geometry.elementsNeedUpdate = false;
                }
                if (direct === undefined) {
                    return this.fromGeometry(geometry);
                }
                direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
                geometry.verticesNeedUpdate = false;
                geometry.normalsNeedUpdate = false;
                geometry.colorsNeedUpdate = false;
                geometry.uvsNeedUpdate = false;
                geometry.groupsNeedUpdate = false;
                geometry = direct;
            }
            var attribute;
            if (geometry.verticesNeedUpdate === true) {
                attribute = this.attributes.position;
                if (attribute !== undefined) {
                    attribute.copyVector3sArray(geometry.vertices);
                    attribute.needsUpdate = true;
                }
                geometry.verticesNeedUpdate = false;
            }
            if (geometry.normalsNeedUpdate === true) {
                attribute = this.attributes.normal;
                if (attribute !== undefined) {
                    attribute.copyVector3sArray(geometry.normals);
                    attribute.needsUpdate = true;
                }
                geometry.normalsNeedUpdate = false;
            }
            if (geometry.colorsNeedUpdate === true) {
                attribute = this.attributes.color;
                if (attribute !== undefined) {
                    attribute.copyColorsArray(geometry.colors);
                    attribute.needsUpdate = true;
                }
                geometry.colorsNeedUpdate = false;
            }
            if (geometry.uvsNeedUpdate) {
                attribute = this.attributes.uv;
                if (attribute !== undefined) {
                    attribute.copyVector2sArray(geometry.uvs);
                    attribute.needsUpdate = true;
                }
                geometry.uvsNeedUpdate = false;
            }
            if (geometry.lineDistancesNeedUpdate) {
                attribute = this.attributes.lineDistance;
                if (attribute !== undefined) {
                    attribute.copyArray(geometry.lineDistances);
                    attribute.needsUpdate = true;
                }
                geometry.lineDistancesNeedUpdate = false;
            }
            if (geometry.groupsNeedUpdate) {
                geometry.computeGroups(object.geometry);
                this.groups = geometry.groups;
                geometry.groupsNeedUpdate = false;
            }
            return this;
        },
        fromGeometry: function (geometry) {
            geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
            return this.fromDirectGeometry(geometry.__directGeometry);
        },
        fromDirectGeometry: function (geometry) {
            var positions = new Float32Array(geometry.vertices.length * 3);
            this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
            if (geometry.normals.length > 0) {
                var normals = new Float32Array(geometry.normals.length * 3);
                this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
            }
            if (geometry.colors.length > 0) {
                var colors = new Float32Array(geometry.colors.length * 3);
                this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
            }
            if (geometry.uvs.length > 0) {
                var uvs = new Float32Array(geometry.uvs.length * 2);
                this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
            }
            if (geometry.uvs2.length > 0) {
                var uvs2 = new Float32Array(geometry.uvs2.length * 2);
                this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
            }
            this.groups = geometry.groups;
            for (var name in geometry.morphTargets) {
                var array = [];
                var morphTargets = geometry.morphTargets[name];
                for (var i = 0, l = morphTargets.length; i < l; i++) {
                    var morphTarget = morphTargets[i];
                    var attribute = new Float32BufferAttribute(morphTarget.length * 3, 3);
                    array.push(attribute.copyVector3sArray(morphTarget));
                }
                this.morphAttributes[name] = array;
            }
            if (geometry.skinIndices.length > 0) {
                var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
                this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
            }
            if (geometry.skinWeights.length > 0) {
                var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
                this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
            }
            if (geometry.boundingSphere !== null) {
                this.boundingSphere = geometry.boundingSphere.clone();
            }
            if (geometry.boundingBox !== null) {
                this.boundingBox = geometry.boundingBox.clone();
            }
            return this;
        },
        computeBoundingBox: function () {
            if (this.boundingBox === null) {
                this.boundingBox = new Box3();
            }
            var position = this.attributes.position;
            if (position !== undefined) {
                this.boundingBox.setFromBufferAttribute(position);
            } else {
                this.boundingBox.makeEmpty();
            }
            if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
            }
        },
        computeBoundingSphere: function () {
            var box = new Box3();
            var vector = new Vector3();
            return function computeBoundingSphere() {
                if (this.boundingSphere === null) {
                    this.boundingSphere = new Sphere();
                }
                var position = this.attributes.position;
                if (position) {
                    var center = this.boundingSphere.center;
                    box.setFromBufferAttribute(position);
                    box.getCenter(center);
                    var maxRadiusSq = 0;
                    for (var i = 0, il = position.count; i < il; i++) {
                        vector.x = position.getX(i);
                        vector.y = position.getY(i);
                        vector.z = position.getZ(i);
                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
                    }
                    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                    if (isNaN(this.boundingSphere.radius)) {
                        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                    }
                }
            }
                ;
        }(),
        computeFaceNormals: function () { },
        computeVertexNormals: function () {
            var index = this.index;
            var attributes = this.attributes;
            var groups = this.groups;
            if (attributes.position) {
                var positions = attributes.position.array;
                if (attributes.normal === undefined) {
                    this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
                } else {
                    var array = attributes.normal.array;
                    for (var i = 0, il = array.length; i < il; i++) {
                        array[i] = 0;
                    }
                }
                var normals = attributes.normal.array;
                var vA, vB, vC;
                var pA = new Vector3()
                    , pB = new Vector3()
                    , pC = new Vector3();
                var cb = new Vector3()
                    , ab = new Vector3();
                if (index) {
                    var indices = index.array;
                    if (groups.length === 0) {
                        this.addGroup(0, indices.length);
                    }
                    for (var j = 0, jl = groups.length; j < jl; ++j) {
                        var group = groups[j];
                        var start = group.start;
                        var count = group.count;
                        for (var i = start, il = start + count; i < il; i += 3) {
                            vA = indices[i + 0] * 3;
                            vB = indices[i + 1] * 3;
                            vC = indices[i + 2] * 3;
                            pA.fromArray(positions, vA);
                            pB.fromArray(positions, vB);
                            pC.fromArray(positions, vC);
                            cb.subVectors(pC, pB);
                            ab.subVectors(pA, pB);
                            cb.cross(ab);
                            normals[vA] += cb.x;
                            normals[vA + 1] += cb.y;
                            normals[vA + 2] += cb.z;
                            normals[vB] += cb.x;
                            normals[vB + 1] += cb.y;
                            normals[vB + 2] += cb.z;
                            normals[vC] += cb.x;
                            normals[vC + 1] += cb.y;
                            normals[vC + 2] += cb.z;
                        }
                    }
                } else {
                    for (var i = 0, il = positions.length; i < il; i += 9) {
                        pA.fromArray(positions, i);
                        pB.fromArray(positions, i + 3);
                        pC.fromArray(positions, i + 6);
                        cb.subVectors(pC, pB);
                        ab.subVectors(pA, pB);
                        cb.cross(ab);
                        normals[i] = cb.x;
                        normals[i + 1] = cb.y;
                        normals[i + 2] = cb.z;
                        normals[i + 3] = cb.x;
                        normals[i + 4] = cb.y;
                        normals[i + 5] = cb.z;
                        normals[i + 6] = cb.x;
                        normals[i + 7] = cb.y;
                        normals[i + 8] = cb.z;
                    }
                }
                this.normalizeNormals();
                attributes.normal.needsUpdate = true;
            }
        },
        merge: function (geometry, offset) {
            if (!(geometry && geometry.isBufferGeometry)) {
                console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
                return;
            }
            if (offset === undefined) {
                offset = 0;
                console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
            }
            var attributes = this.attributes;
            for (var key in attributes) {
                if (geometry.attributes[key] === undefined)
                    continue;
                var attribute1 = attributes[key];
                var attributeArray1 = attribute1.array;
                var attribute2 = geometry.attributes[key];
                var attributeArray2 = attribute2.array;
                var attributeSize = attribute2.itemSize;
                for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++ ,
                    j++) {
                    attributeArray1[j] = attributeArray2[i];
                }
            }
            return this;
        },
        normalizeNormals: function () {
            var vector = new Vector3();
            return function normalizeNormals() {
                var normals = this.attributes.normal;
                for (var i = 0, il = normals.count; i < il; i++) {
                    vector.x = normals.getX(i);
                    vector.y = normals.getY(i);
                    vector.z = normals.getZ(i);
                    vector.normalize();
                    normals.setXYZ(i, vector.x, vector.y, vector.z);
                }
            }
                ;
        }(),
        toNonIndexed: function () {
            if (this.index === null) {
                console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
                return this;
            }
            var geometry2 = new BufferGeometry();
            var indices = this.index.array;
            var attributes = this.attributes;
            for (var name in attributes) {
                var attribute = attributes[name];
                var array = attribute.array;
                var itemSize = attribute.itemSize;
                var array2 = new array.constructor(indices.length * itemSize);
                var index = 0
                    , index2 = 0;
                for (var i = 0, l = indices.length; i < l; i++) {
                    index = indices[i] * itemSize;
                    for (var j = 0; j < itemSize; j++) {
                        array2[index2++] = array[index++];
                    }
                }
                geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
            }
            var groups = this.groups;
            for (var i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                geometry2.addGroup(group.start, group.count, group.materialIndex);
            }
            return geometry2;
        },
        toJSON: function () {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'BufferGeometry',
                    generator: 'BufferGeometry.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '')
                data.name = this.name;
            if (Object.keys(this.userData).length > 0)
                data.userData = this.userData;
            if (this.parameters !== undefined) {
                var parameters = this.parameters;
                for (var key in parameters) {
                    if (parameters[key] !== undefined)
                        data[key] = parameters[key];
                }
                return data;
            }
            data.data = {
                attributes: {}
            };
            var index = this.index;
            if (index !== null) {
                var array = Array.prototype.slice.call(index.array);
                data.data.index = {
                    type: index.array.constructor.name,
                    array: array
                };
            }
            var attributes = this.attributes;
            for (var key in attributes) {
                var attribute = attributes[key];
                var array = Array.prototype.slice.call(attribute.array);
                data.data.attributes[key] = {
                    itemSize: attribute.itemSize,
                    type: attribute.array.constructor.name,
                    array: array,
                    normalized: attribute.normalized
                };
            }
            var groups = this.groups;
            if (groups.length > 0) {
                data.data.groups = JSON.parse(JSON.stringify(groups));
            }
            var boundingSphere = this.boundingSphere;
            if (boundingSphere !== null) {
                data.data.boundingSphere = {
                    center: boundingSphere.center.toArray(),
                    radius: boundingSphere.radius
                };
            }
            return data;
        },
        clone: function () {
            return new BufferGeometry().copy(this);
        },
        copy: function (source) {
            var name, i, l;
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
            this.name = source.name;
            var index = source.index;
            if (index !== null) {
                this.setIndex(index.clone());
            }
            var attributes = source.attributes;
            for (name in attributes) {
                var attribute = attributes[name];
                this.addAttribute(name, attribute.clone());
            }
            var morphAttributes = source.morphAttributes;
            for (name in morphAttributes) {
                var array = [];
                var morphAttribute = morphAttributes[name];
                for (i = 0,
                    l = morphAttribute.length; i < l; i++) {
                    array.push(morphAttribute[i].clone());
                }
                this.morphAttributes[name] = array;
            }
            var groups = source.groups;
            for (i = 0,
                l = groups.length; i < l; i++) {
                var group = groups[i];
                this.addGroup(group.start, group.count, group.materialIndex);
            }
            var boundingBox = source.boundingBox;
            if (boundingBox !== null) {
                this.boundingBox = boundingBox.clone();
            }
            var boundingSphere = source.boundingSphere;
            if (boundingSphere !== null) {
                this.boundingSphere = boundingSphere.clone();
            }
            this.drawRange.start = source.drawRange.start;
            this.drawRange.count = source.drawRange.count;
            this.userData = source.userData;
            return this;
        },
        dispose: function () {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });
    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        Geometry.call(this);
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
        this.mergeVertices();
    }
    BoxGeometry.prototype = Object.create(Geometry.prototype);
    BoxGeometry.prototype.constructor = BoxGeometry;
    function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
        BufferGeometry.call(this);
        this.type = 'BoxBufferGeometry';
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        var scope = this;
        width = width || 1;
        height = height || 1;
        depth = depth || 1;
        widthSegments = Math.floor(widthSegments) || 1;
        heightSegments = Math.floor(heightSegments) || 1;
        depthSegments = Math.floor(depthSegments) || 1;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var numberOfVertices = 0;
        var groupStart = 0;
        buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
            var segmentWidth = width / gridX;
            var segmentHeight = height / gridY;
            var widthHalf = width / 2;
            var heightHalf = height / 2;
            var depthHalf = depth / 2;
            var gridX1 = gridX + 1;
            var gridY1 = gridY + 1;
            var vertexCounter = 0;
            var groupCount = 0;
            var ix, iy;
            var vector = new Vector3();
            for (iy = 0; iy < gridY1; iy++) {
                var y = iy * segmentHeight - heightHalf;
                for (ix = 0; ix < gridX1; ix++) {
                    var x = ix * segmentWidth - widthHalf;
                    vector[u] = x * udir;
                    vector[v] = y * vdir;
                    vector[w] = depthHalf;
                    vertices.push(vector.x, vector.y, vector.z);
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w] = depth > 0 ? 1 : -1;
                    normals.push(vector.x, vector.y, vector.z);
                    uvs.push(ix / gridX);
                    uvs.push(1 - (iy / gridY));
                    vertexCounter += 1;
                }
            }
            for (iy = 0; iy < gridY; iy++) {
                for (ix = 0; ix < gridX; ix++) {
                    var a = numberOfVertices + ix + gridX1 * iy;
                    var b = numberOfVertices + ix + gridX1 * (iy + 1);
                    var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                    var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                    groupCount += 6;
                }
            }
            scope.addGroup(groupStart, groupCount, materialIndex);
            groupStart += groupCount;
            numberOfVertices += vertexCounter;
        }
    }
    BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
    function PlaneGeometry(width, height, widthSegments, heightSegments) {
        Geometry.call(this);
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
        this.mergeVertices();
    }
    PlaneGeometry.prototype = Object.create(Geometry.prototype);
    PlaneGeometry.prototype.constructor = PlaneGeometry;
    function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
        BufferGeometry.call(this);
        this.type = 'PlaneBufferGeometry';
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
        width = width || 1;
        height = height || 1;
        var width_half = width / 2;
        var height_half = height / 2;
        var gridX = Math.floor(widthSegments) || 1;
        var gridY = Math.floor(heightSegments) || 1;
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var segment_width = width / gridX;
        var segment_height = height / gridY;
        var ix, iy;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        for (iy = 0; iy < gridY1; iy++) {
            var y = iy * segment_height - height_half;
            for (ix = 0; ix < gridX1; ix++) {
                var x = ix * segment_width - width_half;
                vertices.push(x, -y, 0);
                normals.push(0, 0, 1);
                uvs.push(ix / gridX);
                uvs.push(1 - (iy / gridY));
            }
        }
        for (iy = 0; iy < gridY; iy++) {
            for (ix = 0; ix < gridX; ix++) {
                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * (iy + 1);
                var c = (ix + 1) + gridX1 * (iy + 1);
                var d = (ix + 1) + gridX1 * iy;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
    var materialId = 0;
    function Material() {
        Object.defineProperty(this, 'id', {
            value: materialId++
        });
        this.uuid = _Math.generateUUID();
        this.name = '';
        this.type = 'Material';
        this.fog = true;
        this.lights = true;
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.flatShading = false;
        this.vertexColors = NoColors;
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null;
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaTest = 0;
        this.premultipliedAlpha = false;
        this.overdraw = 0;
        this.visible = true;
        this.userData = {};
        this.needsUpdate = true;
    }
    Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: Material,
        isMaterial: true,
        onBeforeCompile: function () { },
        setValues: function (values) {
            if (values === undefined)
                return;
            for (var key in values) {
                var newValue = values[key];
                if (newValue === undefined) {
                    console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                    continue;
                }
                if (key === 'shading') {
                    console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                    this.flatShading = (newValue === FlatShading) ? true : false;
                    continue;
                }
                var currentValue = this[key];
                if (currentValue === undefined) {
                    console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                    continue;
                }
                if (currentValue && currentValue.isColor) {
                    currentValue.set(newValue);
                } else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {
                    currentValue.copy(newValue);
                } else if (key === 'overdraw') {
                    this[key] = Number(newValue);
                } else {
                    this[key] = newValue;
                }
            }
        },
        toJSON: function (meta) {
            var isRoot = (meta === undefined || typeof meta === 'string');
            if (isRoot) {
                meta = {
                    textures: {},
                    images: {}
                };
            }
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '')
                data.name = this.name;
            if (this.color && this.color.isColor)
                data.color = this.color.getHex();
            if (this.roughness !== undefined)
                data.roughness = this.roughness;
            if (this.metalness !== undefined)
                data.metalness = this.metalness;
            if (this.emissive && this.emissive.isColor)
                data.emissive = this.emissive.getHex();
            if (this.emissiveIntensity !== 1)
                data.emissiveIntensity = this.emissiveIntensity;
            if (this.specular && this.specular.isColor)
                data.specular = this.specular.getHex();
            if (this.shininess !== undefined)
                data.shininess = this.shininess;
            if (this.clearCoat !== undefined)
                data.clearCoat = this.clearCoat;
            if (this.clearCoatRoughness !== undefined)
                data.clearCoatRoughness = this.clearCoatRoughness;
            if (this.map && this.map.isTexture)
                data.map = this.map.toJSON(meta).uuid;
            if (this.alphaMap && this.alphaMap.isTexture)
                data.alphaMap = this.alphaMap.toJSON(meta).uuid;
            if (this.lightMap && this.lightMap.isTexture)
                data.lightMap = this.lightMap.toJSON(meta).uuid;
            if (this.aoMap && this.aoMap.isTexture) {
                data.aoMap = this.aoMap.toJSON(meta).uuid;
                data.aoMapIntensity = this.aoMapIntensity;
            }
            if (this.bumpMap && this.bumpMap.isTexture) {
                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
            }
            if (this.normalMap && this.normalMap.isTexture) {
                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalScale = this.normalScale.toArray();
            }
            if (this.displacementMap && this.displacementMap.isTexture) {
                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
            }
            if (this.roughnessMap && this.roughnessMap.isTexture)
                data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
            if (this.metalnessMap && this.metalnessMap.isTexture)
                data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
            if (this.emissiveMap && this.emissiveMap.isTexture)
                data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
            if (this.specularMap && this.specularMap.isTexture)
                data.specularMap = this.specularMap.toJSON(meta).uuid;
            if (this.envMap && this.envMap.isTexture) {
                data.envMap = this.envMap.toJSON(meta).uuid;
                data.reflectivity = this.reflectivity;
            }
            if (this.gradientMap && this.gradientMap.isTexture) {
                data.gradientMap = this.gradientMap.toJSON(meta).uuid;
            }
            if (this.size !== undefined)
                data.size = this.size;
            if (this.sizeAttenuation !== undefined)
                data.sizeAttenuation = this.sizeAttenuation;
            if (this.blending !== NormalBlending)
                data.blending = this.blending;
            if (this.flatShading === true)
                data.flatShading = this.flatShading;
            if (this.side !== FrontSide)
                data.side = this.side;
            if (this.vertexColors !== NoColors)
                data.vertexColors = this.vertexColors;
            if (this.opacity < 1)
                data.opacity = this.opacity;
            if (this.transparent === true)
                data.transparent = this.transparent;
            data.depthFunc = this.depthFunc;
            data.depthTest = this.depthTest;
            data.depthWrite = this.depthWrite;
            if (this.rotation !== 0)
                data.rotation = this.rotation;
            if (this.linewidth !== 1)
                data.linewidth = this.linewidth;
            if (this.dashSize !== undefined)
                data.dashSize = this.dashSize;
            if (this.gapSize !== undefined)
                data.gapSize = this.gapSize;
            if (this.scale !== undefined)
                data.scale = this.scale;
            if (this.dithering === true)
                data.dithering = true;
            if (this.alphaTest > 0)
                data.alphaTest = this.alphaTest;
            if (this.premultipliedAlpha === true)
                data.premultipliedAlpha = this.premultipliedAlpha;
            if (this.wireframe === true)
                data.wireframe = this.wireframe;
            if (this.wireframeLinewidth > 1)
                data.wireframeLinewidth = this.wireframeLinewidth;
            if (this.wireframeLinecap !== 'round')
                data.wireframeLinecap = this.wireframeLinecap;
            if (this.wireframeLinejoin !== 'round')
                data.wireframeLinejoin = this.wireframeLinejoin;
            if (this.morphTargets === true)
                data.morphTargets = true;
            if (this.skinning === true)
                data.skinning = true;
            if (this.visible === false)
                data.visible = false;
            if (JSON.stringify(this.userData) !== '{}')
                data.userData = this.userData;
            function extractFromCache(cache) {
                var values = [];
                for (var key in cache) {
                    var data = cache[key];
                    delete data.metadata;
                    values.push(data);
                }
                return values;
            }
            if (isRoot) {
                var textures = extractFromCache(meta.textures);
                var images = extractFromCache(meta.images);
                if (textures.length > 0)
                    data.textures = textures;
                if (images.length > 0)
                    data.images = images;
            }
            return data;
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (source) {
            this.name = source.name;
            this.fog = source.fog;
            this.lights = source.lights;
            this.blending = source.blending;
            this.side = source.side;
            this.flatShading = source.flatShading;
            this.vertexColors = source.vertexColors;
            this.opacity = source.opacity;
            this.transparent = source.transparent;
            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;
            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;
            this.colorWrite = source.colorWrite;
            this.precision = source.precision;
            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;
            this.dithering = source.dithering;
            this.alphaTest = source.alphaTest;
            this.premultipliedAlpha = source.premultipliedAlpha;
            this.overdraw = source.overdraw;
            this.visible = source.visible;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            this.clipShadows = source.clipShadows;
            this.clipIntersection = source.clipIntersection;
            var srcPlanes = source.clippingPlanes
                , dstPlanes = null;
            if (srcPlanes !== null) {
                var n = srcPlanes.length;
                dstPlanes = new Array(n);
                for (var i = 0; i !== n; ++i)
                    dstPlanes[i] = srcPlanes[i].clone();
            }
            this.clippingPlanes = dstPlanes;
            this.shadowSide = source.shadowSide;
            return this;
        },
        dispose: function () {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });
    function MeshBasicMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshBasicMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.lights = false;
        this.setValues(parameters);
    }
    MeshBasicMaterial.prototype = Object.create(Material.prototype);
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    MeshBasicMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        return this;
    }
        ;
    function ShaderMaterial(parameters) {
        Material.call(this);
        this.type = 'ShaderMaterial';
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
        this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.clipping = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
        };
        this.defaultAttributeValues = {
            'color': [1, 1, 1],
            'uv': [0, 0],
            'uv2': [0, 0]
        };
        this.index0AttributeName = undefined;
        this.uniformsNeedUpdate = false;
        if (parameters !== undefined) {
            if (parameters.attributes !== undefined) {
                console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
            }
            this.setValues(parameters);
        }
    }
    ShaderMaterial.prototype = Object.create(Material.prototype);
    ShaderMaterial.prototype.constructor = ShaderMaterial;
    ShaderMaterial.prototype.isShaderMaterial = true;
    ShaderMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = UniformsUtils.clone(source.uniforms);
        this.defines = Object.assign({}, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.extensions = source.extensions;
        return this;
    }
        ;
    ShaderMaterial.prototype.toJSON = function (meta) {
        var data = Material.prototype.toJSON.call(this, meta);
        data.uniforms = this.uniforms;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        return data;
    }
        ;
    function Ray(origin, direction) {
        this.origin = (origin !== undefined) ? origin : new Vector3();
        this.direction = (direction !== undefined) ? direction : new Vector3();
    }
    Object.assign(Ray.prototype, {
        set: function (origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (ray) {
            this.origin.copy(ray.origin);
            this.direction.copy(ray.direction);
            return this;
        },
        at: function (t, target) {
            if (target === undefined) {
                console.warn('THREE.Ray: .at() target is now required');
                target = new Vector3();
            }
            return target.copy(this.direction).multiplyScalar(t).add(this.origin);
        },
        lookAt: function (v) {
            this.direction.copy(v).sub(this.origin).normalize();
            return this;
        },
        recast: function () {
            var v1 = new Vector3();
            return function recast(t) {
                this.origin.copy(this.at(t, v1));
                return this;
            }
                ;
        }(),
        closestPointToPoint: function (point, target) {
            if (target === undefined) {
                console.warn('THREE.Ray: .closestPointToPoint() target is now required');
                target = new Vector3();
            }
            target.subVectors(point, this.origin);
            var directionDistance = target.dot(this.direction);
            if (directionDistance < 0) {
                return target.copy(this.origin);
            }
            return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        },
        distanceToPoint: function (point) {
            return Math.sqrt(this.distanceSqToPoint(point));
        },
        distanceSqToPoint: function () {
            var v1 = new Vector3();
            return function distanceSqToPoint(point) {
                var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
                if (directionDistance < 0) {
                    return this.origin.distanceToSquared(point);
                }
                v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                return v1.distanceToSquared(point);
            }
                ;
        }(),
        distanceSqToSegment: function () {
            var segCenter = new Vector3();
            var segDir = new Vector3();
            var diff = new Vector3();
            return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                segCenter.copy(v0).add(v1).multiplyScalar(0.5);
                segDir.copy(v1).sub(v0).normalize();
                diff.copy(this.origin).sub(segCenter);
                var segExtent = v0.distanceTo(v1) * 0.5;
                var a01 = -this.direction.dot(segDir);
                var b0 = diff.dot(this.direction);
                var b1 = -diff.dot(segDir);
                var c = diff.lengthSq();
                var det = Math.abs(1 - a01 * a01);
                var s0, s1, sqrDist, extDet;
                if (det > 0) {
                    s0 = a01 * b1 - b0;
                    s1 = a01 * b0 - b1;
                    extDet = segExtent * det;
                    if (s0 >= 0) {
                        if (s1 >= -extDet) {
                            if (s1 <= extDet) {
                                var invDet = 1 / det;
                                s0 *= invDet;
                                s1 *= invDet;
                                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                            } else {
                                s1 = segExtent;
                                s0 = Math.max(0, -(a01 * s1 + b0));
                                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                            }
                        } else {
                            s1 = -segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    } else {
                        if (s1 <= -extDet) {
                            s0 = Math.max(0, -(-a01 * segExtent + b0));
                            s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        } else if (s1 <= extDet) {
                            s0 = 0;
                            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = s1 * (s1 + 2 * b1) + c;
                        } else {
                            s0 = Math.max(0, -(a01 * segExtent + b0));
                            s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    }
                } else {
                    s1 = (a01 > 0) ? -segExtent : segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
                if (optionalPointOnRay) {
                    optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
                }
                if (optionalPointOnSegment) {
                    optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
                }
                return sqrDist;
            }
                ;
        }(),
        intersectSphere: function () {
            var v1 = new Vector3();
            return function intersectSphere(sphere, target) {
                v1.subVectors(sphere.center, this.origin);
                var tca = v1.dot(this.direction);
                var d2 = v1.dot(v1) - tca * tca;
                var radius2 = sphere.radius * sphere.radius;
                if (d2 > radius2)
                    return null;
                var thc = Math.sqrt(radius2 - d2);
                var t0 = tca - thc;
                var t1 = tca + thc;
                if (t0 < 0 && t1 < 0)
                    return null;
                if (t0 < 0)
                    return this.at(t1, target);
                return this.at(t0, target);
            }
                ;
        }(),
        intersectsSphere: function (sphere) {
            return this.distanceToPoint(sphere.center) <= sphere.radius;
        },
        distanceToPlane: function (plane) {
            var denominator = plane.normal.dot(this.direction);
            if (denominator === 0) {
                if (plane.distanceToPoint(this.origin) === 0) {
                    return 0;
                }
                return null;
            }
            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
            return t >= 0 ? t : null;
        },
        intersectPlane: function (plane, target) {
            var t = this.distanceToPlane(plane);
            if (t === null) {
                return null;
            }
            return this.at(t, target);
        },
        intersectsPlane: function (plane) {
            var distToPoint = plane.distanceToPoint(this.origin);
            if (distToPoint === 0) {
                return true;
            }
            var denominator = plane.normal.dot(this.direction);
            if (denominator * distToPoint < 0) {
                return true;
            }
            return false;
        },
        intersectBox: function (box, target) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var invdirx = 1 / this.direction.x
                , invdiry = 1 / this.direction.y
                , invdirz = 1 / this.direction.z;
            var origin = this.origin;
            if (invdirx >= 0) {
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
            } else {
                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
            }
            if (invdiry >= 0) {
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
            } else {
                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
            }
            if ((tmin > tymax) || (tymin > tmax))
                return null;
            if (tymin > tmin || tmin !== tmin)
                tmin = tymin;
            if (tymax < tmax || tmax !== tmax)
                tmax = tymax;
            if (invdirz >= 0) {
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
            } else {
                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
            }
            if ((tmin > tzmax) || (tzmin > tmax))
                return null;
            if (tzmin > tmin || tmin !== tmin)
                tmin = tzmin;
            if (tzmax < tmax || tmax !== tmax)
                tmax = tzmax;
            if (tmax < 0)
                return null;
            return this.at(tmin >= 0 ? tmin : tmax, target);
        },
        intersectsBox: (function () {
            var v = new Vector3();
            return function intersectsBox(box) {
                return this.intersectBox(box, v) !== null;
            }
                ;
        }
        )(),
        intersectTriangle: function () {
            var diff = new Vector3();
            var edge1 = new Vector3();
            var edge2 = new Vector3();
            var normal = new Vector3();
            return function intersectTriangle(a, b, c, backfaceCulling, target) {
                edge1.subVectors(b, a);
                edge2.subVectors(c, a);
                normal.crossVectors(edge1, edge2);
                var DdN = this.direction.dot(normal);
                var sign;
                if (DdN > 0) {
                    if (backfaceCulling)
                        return null;
                    sign = 1;
                } else if (DdN < 0) {
                    sign = -1;
                    DdN = -DdN;
                } else {
                    return null;
                }
                diff.subVectors(this.origin, a);
                var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
                if (DdQxE2 < 0) {
                    return null;
                }
                var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
                if (DdE1xQ < 0) {
                    return null;
                }
                if (DdQxE2 + DdE1xQ > DdN) {
                    return null;
                }
                var QdN = -sign * diff.dot(normal);
                if (QdN < 0) {
                    return null;
                }
                return this.at(QdN / DdN, target);
            }
                ;
        }(),
        applyMatrix4: function (matrix4) {
            this.origin.applyMatrix4(matrix4);
            this.direction.transformDirection(matrix4);
            return this;
        },
        equals: function (ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        }
    });
    function Line3(start, end) {
        this.start = (start !== undefined) ? start : new Vector3();
        this.end = (end !== undefined) ? end : new Vector3();
    }
    Object.assign(Line3.prototype, {
        set: function (start, end) {
            this.start.copy(start);
            this.end.copy(end);
            return this;
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (line) {
            this.start.copy(line.start);
            this.end.copy(line.end);
            return this;
        },
        getCenter: function (target) {
            if (target === undefined) {
                console.warn('THREE.Line3: .getCenter() target is now required');
                target = new Vector3();
            }
            return target.addVectors(this.start, this.end).multiplyScalar(0.5);
        },
        delta: function (target) {
            if (target === undefined) {
                console.warn('THREE.Line3: .delta() target is now required');
                target = new Vector3();
            }
            return target.subVectors(this.end, this.start);
        },
        distanceSq: function () {
            return this.start.distanceToSquared(this.end);
        },
        distance: function () {
            return this.start.distanceTo(this.end);
        },
        at: function (t, target) {
            if (target === undefined) {
                console.warn('THREE.Line3: .at() target is now required');
                target = new Vector3();
            }
            return this.delta(target).multiplyScalar(t).add(this.start);
        },
        closestPointToPointParameter: function () {
            var startP = new Vector3();
            var startEnd = new Vector3();
            return function closestPointToPointParameter(point, clampToLine) {
                startP.subVectors(point, this.start);
                startEnd.subVectors(this.end, this.start);
                var startEnd2 = startEnd.dot(startEnd);
                var startEnd_startP = startEnd.dot(startP);
                var t = startEnd_startP / startEnd2;
                if (clampToLine) {
                    t = _Math.clamp(t, 0, 1);
                }
                return t;
            }
                ;
        }(),
        closestPointToPoint: function (point, clampToLine, target) {
            var t = this.closestPointToPointParameter(point, clampToLine);
            if (target === undefined) {
                console.warn('THREE.Line3: .closestPointToPoint() target is now required');
                target = new Vector3();
            }
            return this.delta(target).multiplyScalar(t).add(this.start);
        },
        applyMatrix4: function (matrix) {
            this.start.applyMatrix4(matrix);
            this.end.applyMatrix4(matrix);
            return this;
        },
        equals: function (line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        }
    });
    function Triangle(a, b, c) {
        this.a = (a !== undefined) ? a : new Vector3();
        this.b = (b !== undefined) ? b : new Vector3();
        this.c = (c !== undefined) ? c : new Vector3();
    }
    Object.assign(Triangle, {
        getNormal: function () {
            var v0 = new Vector3();
            return function getNormal(a, b, c, target) {
                if (target === undefined) {
                    console.warn('THREE.Triangle: .getNormal() target is now required');
                    target = new Vector3();
                }
                target.subVectors(c, b);
                v0.subVectors(a, b);
                target.cross(v0);
                var targetLengthSq = target.lengthSq();
                if (targetLengthSq > 0) {
                    return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
                }
                return target.set(0, 0, 0);
            }
                ;
        }(),
        getBarycoord: function () {
            var v0 = new Vector3();
            var v1 = new Vector3();
            var v2 = new Vector3();
            return function getBarycoord(point, a, b, c, target) {
                v0.subVectors(c, a);
                v1.subVectors(b, a);
                v2.subVectors(point, a);
                var dot00 = v0.dot(v0);
                var dot01 = v0.dot(v1);
                var dot02 = v0.dot(v2);
                var dot11 = v1.dot(v1);
                var dot12 = v1.dot(v2);
                var denom = (dot00 * dot11 - dot01 * dot01);
                if (target === undefined) {
                    console.warn('THREE.Triangle: .getBarycoord() target is now required');
                    target = new Vector3();
                }
                if (denom === 0) {
                    return target.set(-2, -1, -1);
                }
                var invDenom = 1 / denom;
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                return target.set(1 - u - v, v, u);
            }
                ;
        }(),
        containsPoint: function () {
            var v1 = new Vector3();
            return function containsPoint(point, a, b, c) {
                Triangle.getBarycoord(point, a, b, c, v1);
                return (v1.x >= 0) && (v1.y >= 0) && ((v1.x + v1.y) <= 1);
            }
                ;
        }()
    });
    Object.assign(Triangle.prototype, {
        set: function (a, b, c) {
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        },
        setFromPointsAndIndices: function (points, i0, i1, i2) {
            this.a.copy(points[i0]);
            this.b.copy(points[i1]);
            this.c.copy(points[i2]);
            return this;
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (triangle) {
            this.a.copy(triangle.a);
            this.b.copy(triangle.b);
            this.c.copy(triangle.c);
            return this;
        },
        getArea: function () {
            var v0 = new Vector3();
            var v1 = new Vector3();
            return function getArea() {
                v0.subVectors(this.c, this.b);
                v1.subVectors(this.a, this.b);
                return v0.cross(v1).length() * 0.5;
            }
                ;
        }(),
        getMidpoint: function (target) {
            if (target === undefined) {
                console.warn('THREE.Triangle: .getMidpoint() target is now required');
                target = new Vector3();
            }
            return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        },
        getNormal: function (target) {
            return Triangle.getNormal(this.a, this.b, this.c, target);
        },
        getPlane: function (target) {
            if (target === undefined) {
                console.warn('THREE.Triangle: .getPlane() target is now required');
                target = new Vector3();
            }
            return target.setFromCoplanarPoints(this.a, this.b, this.c);
        },
        getBarycoord: function (point, target) {
            return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
        },
        containsPoint: function (point) {
            return Triangle.containsPoint(point, this.a, this.b, this.c);
        },
        intersectsBox: function (box) {
            return box.intersectsTriangle(this);
        },
        closestPointToPoint: function () {
            var plane = new Plane();
            var edgeList = [new Line3(), new Line3(), new Line3()];
            var projectedPoint = new Vector3();
            var closestPoint = new Vector3();
            return function closestPointToPoint(point, target) {
                if (target === undefined) {
                    console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
                    target = new Vector3();
                }
                var minDistance = Infinity;
                plane.setFromCoplanarPoints(this.a, this.b, this.c);
                plane.projectPoint(point, projectedPoint);
                if (this.containsPoint(projectedPoint) === true) {
                    target.copy(projectedPoint);
                } else {
                    edgeList[0].set(this.a, this.b);
                    edgeList[1].set(this.b, this.c);
                    edgeList[2].set(this.c, this.a);
                    for (var i = 0; i < edgeList.length; i++) {
                        edgeList[i].closestPointToPoint(projectedPoint, true, closestPoint);
                        var distance = projectedPoint.distanceToSquared(closestPoint);
                        if (distance < minDistance) {
                            minDistance = distance;
                            target.copy(closestPoint);
                        }
                    }
                }
                return target;
            }
                ;
        }(),
        equals: function (triangle) {
            return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
        }
    });
    function Mesh(geometry, material) {
        Object3D.call(this);
        this.type = 'Mesh';
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new MeshBasicMaterial({
            color: Math.random() * 0xffffff
        });
        this.drawMode = TrianglesDrawMode;
        this.updateMorphTargets();
    }
    Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Mesh,
        isMesh: true,
        setDrawMode: function (value) {
            this.drawMode = value;
        },
        copy: function (source) {
            Object3D.prototype.copy.call(this, source);
            this.drawMode = source.drawMode;
            if (source.morphTargetInfluences !== undefined) {
                this.morphTargetInfluences = source.morphTargetInfluences.slice();
            }
            if (source.morphTargetDictionary !== undefined) {
                this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
            }
            return this;
        },
        updateMorphTargets: function () {
            var geometry = this.geometry;
            var m, ml, name;
            if (geometry.isBufferGeometry) {
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys(morphAttributes);
                if (keys.length > 0) {
                    var morphAttribute = morphAttributes[keys[0]];
                    if (morphAttribute !== undefined) {
                        this.morphTargetInfluences = [];
                        this.morphTargetDictionary = {};
                        for (m = 0,
                            ml = morphAttribute.length; m < ml; m++) {
                            name = morphAttribute[m].name || String(m);
                            this.morphTargetInfluences.push(0);
                            this.morphTargetDictionary[name] = m;
                        }
                    }
                }
            } else {
                var morphTargets = geometry.morphTargets;
                if (morphTargets !== undefined && morphTargets.length > 0) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {};
                    for (m = 0,
                        ml = morphTargets.length; m < ml; m++) {
                        name = morphTargets[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        },
        raycast: (function () {
            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();
            var vA = new Vector3();
            var vB = new Vector3();
            var vC = new Vector3();
            var tempA = new Vector3();
            var tempB = new Vector3();
            var tempC = new Vector3();
            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();
            var barycoord = new Vector3();
            var intersectionPoint = new Vector3();
            var intersectionPointWorld = new Vector3();
            function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
                Triangle.getBarycoord(point, p1, p2, p3, barycoord);
                uv1.multiplyScalar(barycoord.x);
                uv2.multiplyScalar(barycoord.y);
                uv3.multiplyScalar(barycoord.z);
                uv1.add(uv2).add(uv3);
                return uv1.clone();
            }
            function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
                var intersect;
                if (material.side === BackSide) {
                    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
                } else {
                    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
                }
                if (intersect === null)
                    return null;
                intersectionPointWorld.copy(point);
                intersectionPointWorld.applyMatrix4(object.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
                if (distance < raycaster.near || distance > raycaster.far)
                    return null;
                return {
                    distance: distance,
                    point: intersectionPointWorld.clone(),
                    object: object
                };
            }
            function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
                vA.fromBufferAttribute(position, a);
                vB.fromBufferAttribute(position, b);
                vC.fromBufferAttribute(position, c);
                var intersection = checkIntersection(object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint);
                if (intersection) {
                    if (uv) {
                        uvA.fromBufferAttribute(uv, a);
                        uvB.fromBufferAttribute(uv, b);
                        uvC.fromBufferAttribute(uv, c);
                        intersection.uv = uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
                    }
                    var face = new Face3(a, b, c);
                    Triangle.getNormal(vA, vB, vC, face.normal);
                    intersection.face = face;
                }
                return intersection;
            }
            return function raycast(raycaster, intersects) {
                var geometry = this.geometry;
                var material = this.material;
                var matrixWorld = this.matrixWorld;
                if (material === undefined)
                    return;
                if (geometry.boundingSphere === null)
                    geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                if (raycaster.ray.intersectsSphere(sphere) === false)
                    return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                if (geometry.boundingBox !== null) {
                    if (ray.intersectsBox(geometry.boundingBox) === false)
                        return;
                }
                var intersection;
                if (geometry.isBufferGeometry) {
                    var a, b, c;
                    var index = geometry.index;
                    var position = geometry.attributes.position;
                    var uv = geometry.attributes.uv;
                    var i, l;
                    if (index !== null) {
                        for (i = 0,
                            l = index.count; i < l; i += 3) {
                            a = index.getX(i);
                            b = index.getX(i + 1);
                            c = index.getX(i + 2);
                            intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(i / 3);
                                intersects.push(intersection);
                            }
                        }
                    } else if (position !== undefined) {
                        for (i = 0,
                            l = position.count; i < l; i += 3) {
                            a = i;
                            b = i + 1;
                            c = i + 2;
                            intersection = checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);
                            if (intersection) {
                                intersection.faceIndex = Math.floor(i / 3);
                                intersects.push(intersection);
                            }
                        }
                    }
                } else if (geometry.isGeometry) {
                    var fvA, fvB, fvC;
                    var isMultiMaterial = Array.isArray(material);
                    var vertices = geometry.vertices;
                    var faces = geometry.faces;
                    var uvs;
                    var faceVertexUvs = geometry.faceVertexUvs[0];
                    if (faceVertexUvs.length > 0)
                        uvs = faceVertexUvs;
                    for (var f = 0, fl = faces.length; f < fl; f++) {
                        var face = faces[f];
                        var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                        if (faceMaterial === undefined)
                            continue;
                        fvA = vertices[face.a];
                        fvB = vertices[face.b];
                        fvC = vertices[face.c];
                        if (faceMaterial.morphTargets === true) {
                            var morphTargets = geometry.morphTargets;
                            var morphInfluences = this.morphTargetInfluences;
                            vA.set(0, 0, 0);
                            vB.set(0, 0, 0);
                            vC.set(0, 0, 0);
                            for (var t = 0, tl = morphTargets.length; t < tl; t++) {
                                var influence = morphInfluences[t];
                                if (influence === 0)
                                    continue;
                                var targets = morphTargets[t].vertices;
                                vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
                                vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
                                vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
                            }
                            vA.add(fvA);
                            vB.add(fvB);
                            vC.add(fvC);
                            fvA = vA;
                            fvB = vB;
                            fvC = vC;
                        }
                        intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
                        if (intersection) {
                            if (uvs && uvs[f]) {
                                var uvs_f = uvs[f];
                                uvA.copy(uvs_f[0]);
                                uvB.copy(uvs_f[1]);
                                uvC.copy(uvs_f[2]);
                                intersection.uv = uvIntersection(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC);
                            }
                            intersection.face = face;
                            intersection.faceIndex = f;
                            intersects.push(intersection);
                        }
                    }
                }
            }
                ;
        }()),
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });
    function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
        var clearColor = new Color(0x000000);
        var clearAlpha = 0;
        var planeCamera, planeMesh;
        var boxMesh;
        function render(renderList, scene, camera, forceClear) {
            var background = scene.background;
            if (background === null) {
                setClear(clearColor, clearAlpha);
            } else if (background && background.isColor) {
                setClear(background, 1);
                forceClear = true;
            }
            if (renderer.autoClear || forceClear) {
                renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
            }
            if (background && background.isCubeTexture) {
                if (boxMesh === undefined) {
                    boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
                        uniforms: ShaderLib.cube.uniforms,
                        vertexShader: ShaderLib.cube.vertexShader,
                        fragmentShader: ShaderLib.cube.fragmentShader,
                        side: BackSide,
                        depthTest: true,
                        depthWrite: false,
                        fog: false
                    }));
                    boxMesh.geometry.removeAttribute('normal');
                    boxMesh.geometry.removeAttribute('uv');
                    boxMesh.onBeforeRender = function (renderer, scene, camera) {
                        this.matrixWorld.copyPosition(camera.matrixWorld);
                    }
                        ;
                    objects.update(boxMesh);
                }
                boxMesh.material.uniforms.tCube.value = background;
                renderList.push(boxMesh, boxMesh.geometry, boxMesh.material, 0, null);
            } else if (background && background.isTexture) {
                if (planeCamera === undefined) {
                    planeCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
                    planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new MeshBasicMaterial({
                        depthTest: false,
                        depthWrite: false,
                        fog: false
                    }));
                    objects.update(planeMesh);
                }
                planeMesh.material.map = background;
                renderer.renderBufferDirect(planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null);
            }
        }
        function setClear(color, alpha) {
            state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
        }
        return {
            getClearColor: function () {
                return clearColor;
            },
            setClearColor: function (color, alpha) {
                clearColor.set(color);
                clearAlpha = alpha !== undefined ? alpha : 1;
                setClear(clearColor, clearAlpha);
            },
            getClearAlpha: function () {
                return clearAlpha;
            },
            setClearAlpha: function (alpha) {
                clearAlpha = alpha;
                setClear(clearColor, clearAlpha);
            },
            render: render
        };
    }
    function WebGLBufferRenderer(gl, extensions, info) {
        var mode;
        function setMode(value) {
            mode = value;
        }
        function render(start, count) {
            gl.drawArrays(mode, start, count);
            info.update(count, mode);
        }
        function renderInstances(geometry, start, count) {
            var extension = extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
            extension.drawArraysInstancedANGLE(mode, start, count, geometry.maxInstancedCount);
            info.update(count, mode, geometry.maxInstancedCount);
        }
        this.setMode = setMode;
        this.render = render;
        this.renderInstances = renderInstances;
    }
    function WebGLCapabilities(gl, extensions, parameters) {
        var maxAnisotropy;
        function getMaxAnisotropy() {
            if (maxAnisotropy !== undefined)
                return maxAnisotropy;
            var extension = extensions.get('EXT_texture_filter_anisotropic');
            if (extension !== null) {
                maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else {
                maxAnisotropy = 0;
            }
            return maxAnisotropy;
        }
        function getMaxPrecision(precision) {
            if (precision === 'highp') {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                    return 'highp';
                }
                precision = 'mediump';
            }
            if (precision === 'mediump') {
                if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                    return 'mediump';
                }
            }
            return 'lowp';
        }
        var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
        var maxPrecision = getMaxPrecision(precision);
        if (maxPrecision !== precision) {
            console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
            precision = maxPrecision;
        }
        var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        var maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        var maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        var maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        var maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
        var maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        var vertexTextures = maxVertexTextures > 0;
        var floatFragmentTextures = !!extensions.get('OES_texture_float');
        var floatVertexTextures = vertexTextures && floatFragmentTextures;
        return {
            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: floatVertexTextures
        };
    }
    function WebGLClipping() {
        var scope = this
            , globalState = null
            , numGlobalPlanes = 0
            , localClippingEnabled = false
            , renderingShadows = false
            , plane = new Plane()
            , viewNormalMatrix = new Matrix3()
            , uniform = {
                value: null,
                needsUpdate: false
            };
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function (planes, enableLocalClipping, camera) {
            var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
            localClippingEnabled = enableLocalClipping;
            globalState = projectPlanes(planes, camera, 0);
            numGlobalPlanes = planes.length;
            return enabled;
        }
            ;
        this.beginShadows = function () {
            renderingShadows = true;
            projectPlanes(null);
        }
            ;
        this.endShadows = function () {
            renderingShadows = false;
            resetGlobalState();
        }
            ;
        this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
            if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                if (renderingShadows) {
                    projectPlanes(null);
                } else {
                    resetGlobalState();
                }
            } else {
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes
                    , lGlobal = nGlobal * 4
                    , dstArray = cache.clippingState || null;
                uniform.value = dstArray;
                dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
                for (var i = 0; i !== lGlobal; ++i) {
                    dstArray[i] = globalState[i];
                }
                cache.clippingState = dstArray;
                this.numIntersection = clipIntersection ? this.numPlanes : 0;
                this.numPlanes += nGlobal;
            }
        }
            ;
        function resetGlobalState() {
            if (uniform.value !== globalState) {
                uniform.value = globalState;
                uniform.needsUpdate = numGlobalPlanes > 0;
            }
            scope.numPlanes = numGlobalPlanes;
            scope.numIntersection = 0;
        }
        function projectPlanes(planes, camera, dstOffset, skipTransform) {
            var nPlanes = planes !== null ? planes.length : 0
                , dstArray = null;
            if (nPlanes !== 0) {
                dstArray = uniform.value;
                if (skipTransform !== true || dstArray === null) {
                    var flatSize = dstOffset + nPlanes * 4
                        , viewMatrix = camera.matrixWorldInverse;
                    viewNormalMatrix.getNormalMatrix(viewMatrix);
                    if (dstArray === null || dstArray.length < flatSize) {
                        dstArray = new Float32Array(flatSize);
                    }
                    for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i,
                        i4 += 4) {
                        plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                        plane.normal.toArray(dstArray, i4);
                        dstArray[i4 + 3] = plane.constant;
                    }
                }
                uniform.value = dstArray;
                uniform.needsUpdate = true;
            }
            scope.numPlanes = nPlanes;
            return dstArray;
        }
    }
    function WebGLExtensions(gl) {
        var extensions = {};
        return {
            get: function (name) {
                if (extensions[name] !== undefined) {
                    return extensions[name];
                }
                var extension;
                switch (name) {
                    case 'WEBGL_depth_texture':
                        extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                        break;
                    case 'EXT_texture_filter_anisotropic':
                        extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                        break;
                    case 'WEBGL_compressed_texture_s3tc':
                        extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                        break;
                    case 'WEBGL_compressed_texture_pvrtc':
                        extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                        break;
                    default:
                        extension = gl.getExtension(name);
                }
                if (extension === null) {
                    console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
                }
                extensions[name] = extension;
                return extension;
            }
        };
    }
    function WebGLGeometries(gl, attributes, info) {
        var geometries = {};
        var wireframeAttributes = {};
        function onGeometryDispose(event) {
            var geometry = event.target;
            var buffergeometry = geometries[geometry.id];
            if (buffergeometry.index !== null) {
                attributes.remove(buffergeometry.index);
            }
            for (var name in buffergeometry.attributes) {
                attributes.remove(buffergeometry.attributes[name]);
            }
            geometry.removeEventListener('dispose', onGeometryDispose);
            delete geometries[geometry.id];
            var attribute = wireframeAttributes[geometry.id];
            if (attribute) {
                attributes.remove(attribute);
                delete wireframeAttributes[geometry.id];
            }
            attribute = wireframeAttributes[buffergeometry.id];
            if (attribute) {
                attributes.remove(attribute);
                delete wireframeAttributes[buffergeometry.id];
            }
            info.memory.geometries--;
        }
        function get(object, geometry) {
            var buffergeometry = geometries[geometry.id];
            if (buffergeometry)
                return buffergeometry;
            geometry.addEventListener('dispose', onGeometryDispose);
            if (geometry.isBufferGeometry) {
                buffergeometry = geometry;
            } else if (geometry.isGeometry) {
                if (geometry._bufferGeometry === undefined) {
                    geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
                }
                buffergeometry = geometry._bufferGeometry;
            }
            geometries[geometry.id] = buffergeometry;
            info.memory.geometries++;
            return buffergeometry;
        }
        function update(geometry) {
            var index = geometry.index;
            var geometryAttributes = geometry.attributes;
            if (index !== null) {
                attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
            }
            for (var name in geometryAttributes) {
                attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
            }
            var morphAttributes = geometry.morphAttributes;
            for (var name in morphAttributes) {
                var array = morphAttributes[name];
                for (var i = 0, l = array.length; i < l; i++) {
                    attributes.update(array[i], gl.ARRAY_BUFFER);
                }
            }
        }
        function getWireframeAttribute(geometry) {
            var attribute = wireframeAttributes[geometry.id];
            if (attribute)
                return attribute;
            var indices = [];
            var geometryIndex = geometry.index;
            var geometryAttributes = geometry.attributes;
            if (geometryIndex !== null) {
                var array = geometryIndex.array;
                for (var i = 0, l = array.length; i < l; i += 3) {
                    var a = array[i + 0];
                    var b = array[i + 1];
                    var c = array[i + 2];
                    indices.push(a, b, b, c, c, a);
                }
            } else {
                var array = geometryAttributes.position.array;
                for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {
                    var a = i + 0;
                    var b = i + 1;
                    var c = i + 2;
                    indices.push(a, b, b, c, c, a);
                }
            }
            attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
            attributes.update(attribute, gl.ELEMENT_ARRAY_BUFFER);
            wireframeAttributes[geometry.id] = attribute;
            return attribute;
        }
        return {
            get: get,
            update: update,
            getWireframeAttribute: getWireframeAttribute
        };
    }
    function WebGLIndexedBufferRenderer(gl, extensions, info) {
        var mode;
        function setMode(value) {
            mode = value;
        }
        var type, bytesPerElement;
        function setIndex(value) {
            type = value.type;
            bytesPerElement = value.bytesPerElement;
        }
        function render(start, count) {
            gl.drawElements(mode, count, type, start * bytesPerElement);
            info.update(count, mode);
        }
        function renderInstances(geometry, start, count) {
            var extension = extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
            extension.drawElementsInstancedANGLE(mode, count, type, start * bytesPerElement, geometry.maxInstancedCount);
            info.update(count, mode, geometry.maxInstancedCount);
        }
        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render;
        this.renderInstances = renderInstances;
    }
    function WebGLInfo(gl) {
        var memory = {
            geometries: 0,
            textures: 0
        };
        var render = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        function update(count, mode, instanceCount) {
            instanceCount = instanceCount || 1;
            render.calls++;
            switch (mode) {
                case gl.TRIANGLES:
                    render.triangles += instanceCount * (count / 3);
                    break;
                case gl.TRIANGLE_STRIP:
                case gl.TRIANGLE_FAN:
                    render.triangles += instanceCount * (count - 2);
                    break;
                case gl.LINES:
                    render.lines += instanceCount * (count / 2);
                    break;
                case gl.LINE_STRIP:
                    render.lines += instanceCount * (count - 1);
                    break;
                case gl.LINE_LOOP:
                    render.lines += instanceCount * count;
                    break;
                case gl.POINTS:
                    render.points += instanceCount * count;
                    break;
                default:
                    console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                    break;
            }
        }
        function reset() {
            render.frame++;
            render.calls = 0;
            render.triangles = 0;
            render.points = 0;
            render.lines = 0;
        }
        return {
            memory: memory,
            render: render,
            programs: null,
            autoReset: true,
            reset: reset,
            update: update
        };
    }
    function absNumericalSort(a, b) {
        return Math.abs(b[1]) - Math.abs(a[1]);
    }
    function WebGLMorphtargets(gl) {
        var influencesList = {};
        var morphInfluences = new Float32Array(8);
        function update(object, geometry, material, program) {
            var objectInfluences = object.morphTargetInfluences;
            var length = objectInfluences.length;
            var influences = influencesList[geometry.id];
            if (influences === undefined) {
                influences = [];
                for (var i = 0; i < length; i++) {
                    influences[i] = [i, 0];
                }
                influencesList[geometry.id] = influences;
            }
            var morphTargets = material.morphTargets && geometry.morphAttributes.position;
            var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
            for (var i = 0; i < length; i++) {
                var influence = influences[i];
                if (influence[1] !== 0) {
                    if (morphTargets)
                        geometry.removeAttribute('morphTarget' + i);
                    if (morphNormals)
                        geometry.removeAttribute('morphNormal' + i);
                }
            }
            for (var i = 0; i < length; i++) {
                var influence = influences[i];
                influence[0] = i;
                influence[1] = objectInfluences[i];
            }
            influences.sort(absNumericalSort);
            for (var i = 0; i < 8; i++) {
                var influence = influences[i];
                if (influence) {
                    var index = influence[0];
                    var value = influence[1];
                    if (value) {
                        if (morphTargets)
                            geometry.addAttribute('morphTarget' + i, morphTargets[index]);
                        if (morphNormals)
                            geometry.addAttribute('morphNormal' + i, morphNormals[index]);
                        morphInfluences[i] = value;
                        continue;
                    }
                }
                morphInfluences[i] = 0;
            }
            program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
        }
        return {
            update: update
        };
    }
    function WebGLObjects(geometries, info) {
        var updateList = {};
        function update(object) {
            var frame = info.render.frame;
            var geometry = object.geometry;
            var buffergeometry = geometries.get(object, geometry);
            if (updateList[buffergeometry.id] !== frame) {
                if (geometry.isGeometry) {
                    buffergeometry.updateFromObject(object);
                }
                geometries.update(buffergeometry);
                updateList[buffergeometry.id] = frame;
            }
            return buffergeometry;
        }
        function dispose() {
            updateList = {};
        }
        return {
            update: update,
            dispose: dispose
        };
    }
    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        images = images !== undefined ? images : [];
        mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
        Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.flipY = false;
    }
    CubeTexture.prototype = Object.create(Texture.prototype);
    CubeTexture.prototype.constructor = CubeTexture;
    CubeTexture.prototype.isCubeTexture = true;
    Object.defineProperty(CubeTexture.prototype, 'images', {
        get: function () {
            return this.image;
        },
        set: function (value) {
            this.image = value;
        }
    });
    var emptyTexture = new Texture();
    var emptyCubeTexture = new CubeTexture();
    function UniformContainer() {
        this.seq = [];
        this.map = {};
    }
    var arrayCacheF32 = [];
    var arrayCacheI32 = [];
    var mat4array = new Float32Array(16);
    var mat3array = new Float32Array(9);
    var mat2array = new Float32Array(4);
    function flatten(array, nBlocks, blockSize) {
        var firstElem = array[0];
        if (firstElem <= 0 || firstElem > 0)
            return array;
        var n = nBlocks * blockSize
            , r = arrayCacheF32[n];
        if (r === undefined) {
            r = new Float32Array(n);
            arrayCacheF32[n] = r;
        }
        if (nBlocks !== 0) {
            firstElem.toArray(r, 0);
            for (var i = 1, offset = 0; i !== nBlocks; ++i) {
                offset += blockSize;
                array[i].toArray(r, offset);
            }
        }
        return r;
    }
    function arraysEqual(a, b) {
        if (a.length !== b.length)
            return false;
        for (var i = 0, l = a.length; i < l; i++) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    }
    function copyArray(a, b) {
        for (var i = 0, l = b.length; i < l; i++) {
            a[i] = b[i];
        }
    }
    function allocTexUnits(renderer, n) {
        var r = arrayCacheI32[n];
        if (r === undefined) {
            r = new Int32Array(n);
            arrayCacheI32[n] = r;
        }
        for (var i = 0; i !== n; ++i)
            r[i] = renderer.allocTextureUnit();
        return r;
    }
    function setValue1f(gl, v) {
        var cache = this.cache;
        if (cache[0] === v)
            return;
        gl.uniform1f(this.addr, v);
        cache[0] = v;
    }
    function setValue1i(gl, v) {
        var cache = this.cache;
        if (cache[0] === v)
            return;
        gl.uniform1i(this.addr, v);
        cache[0] = v;
    }
    function setValue2fv(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y) {
                gl.uniform2f(this.addr, v.x, v.y);
                cache[0] = v.x;
                cache[1] = v.y;
            }
        } else {
            if (arraysEqual(cache, v))
                return;
            gl.uniform2fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    function setValue3fv(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
                gl.uniform3f(this.addr, v.x, v.y, v.z);
                cache[0] = v.x;
                cache[1] = v.y;
                cache[2] = v.z;
            }
        } else if (v.r !== undefined) {
            if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
                gl.uniform3f(this.addr, v.r, v.g, v.b);
                cache[0] = v.r;
                cache[1] = v.g;
                cache[2] = v.b;
            }
        } else {
            if (arraysEqual(cache, v))
                return;
            gl.uniform3fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    function setValue4fv(gl, v) {
        var cache = this.cache;
        if (v.x !== undefined) {
            if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
                gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
                cache[0] = v.x;
                cache[1] = v.y;
                cache[2] = v.z;
                cache[3] = v.w;
            }
        } else {
            if (arraysEqual(cache, v))
                return;
            gl.uniform4fv(this.addr, v);
            copyArray(cache, v);
        }
    }
    function setValue2fm(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v))
                return;
            gl.uniformMatrix2fv(this.addr, false, v);
            copyArray(cache, v);
        } else {
            if (arraysEqual(cache, elements))
                return;
            mat2array.set(elements);
            gl.uniformMatrix2fv(this.addr, false, mat2array);
            copyArray(cache, elements);
        }
    }
    function setValue3fm(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v))
                return;
            gl.uniformMatrix3fv(this.addr, false, v);
            copyArray(cache, v);
        } else {
            if (arraysEqual(cache, elements))
                return;
            mat3array.set(elements);
            gl.uniformMatrix3fv(this.addr, false, mat3array);
            copyArray(cache, elements);
        }
    }
    function setValue4fm(gl, v) {
        var cache = this.cache;
        var elements = v.elements;
        if (elements === undefined) {
            if (arraysEqual(cache, v))
                return;
            gl.uniformMatrix4fv(this.addr, false, v);
            copyArray(cache, v);
        } else {
            if (arraysEqual(cache, elements))
                return;
            mat4array.set(elements);
            gl.uniformMatrix4fv(this.addr, false, mat4array);
            copyArray(cache, elements);
        }
    }
    function setValueT1(gl, v, renderer) {
        var cache = this.cache;
        var unit = renderer.allocTextureUnit();
        if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
        }
        renderer.setTexture2D(v || emptyTexture, unit);
    }
    function setValueT6(gl, v, renderer) {
        var cache = this.cache;
        var unit = renderer.allocTextureUnit();
        if (cache[0] !== unit) {
            gl.uniform1i(this.addr, unit);
            cache[0] = unit;
        }
        renderer.setTextureCube(v || emptyCubeTexture, unit);
    }
    function setValue2iv(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v))
            return;
        gl.uniform2iv(this.addr, v);
        copyArray(cache, v);
    }
    function setValue3iv(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v))
            return;
        gl.uniform3iv(this.addr, v);
        copyArray(cache, v);
    }
    function setValue4iv(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v))
            return;
        gl.uniform4iv(this.addr, v);
        copyArray(cache, v);
    }
    function getSingularSetter(type) {
        switch (type) {
            case 0x1406:
                return setValue1f;
            case 0x8b50:
                return setValue2fv;
            case 0x8b51:
                return setValue3fv;
            case 0x8b52:
                return setValue4fv;
            case 0x8b5a:
                return setValue2fm;
            case 0x8b5b:
                return setValue3fm;
            case 0x8b5c:
                return setValue4fm;
            case 0x8b5e:
            case 0x8d66:
                return setValueT1;
            case 0x8b60:
                return setValueT6;
            case 0x1404:
            case 0x8b56:
                return setValue1i;
            case 0x8b53:
            case 0x8b57:
                return setValue2iv;
            case 0x8b54:
            case 0x8b58:
                return setValue3iv;
            case 0x8b55:
            case 0x8b59:
                return setValue4iv;
        }
    }
    function setValue1fv(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v))
            return;
        gl.uniform1fv(this.addr, v);
        copyArray(cache, v);
    }
    function setValue1iv(gl, v) {
        var cache = this.cache;
        if (arraysEqual(cache, v))
            return;
        gl.uniform1iv(this.addr, v);
        copyArray(cache, v);
    }
    function setValueV2a(gl, v) {
        var cache = this.cache;
        var data = flatten(v, this.size, 2);
        if (arraysEqual(cache, data))
            return;
        gl.uniform2fv(this.addr, data);
        this.updateCache(data);
    }
    function setValueV3a(gl, v) {
        var cache = this.cache;
        var data = flatten(v, this.size, 3);
        if (arraysEqual(cache, data))
            return;
        gl.uniform3fv(this.addr, data);
        this.updateCache(data);
    }
    function setValueV4a(gl, v) {
        var cache = this.cache;
        var data = flatten(v, this.size, 4);
        if (arraysEqual(cache, data))
            return;
        gl.uniform4fv(this.addr, data);
        this.updateCache(data);
    }
    function setValueM2a(gl, v) {
        var cache = this.cache;
        var data = flatten(v, this.size, 4);
        if (arraysEqual(cache, data))
            return;
        gl.uniformMatrix2fv(this.addr, false, data);
        this.updateCache(data);
    }
    function setValueM3a(gl, v) {
        var cache = this.cache;
        var data = flatten(v, this.size, 9);
        if (arraysEqual(cache, data))
            return;
        gl.uniformMatrix3fv(this.addr, false, data);
        this.updateCache(data);
    }
    function setValueM4a(gl, v) {
        var cache = this.cache;
        var data = flatten(v, this.size, 16);
        if (arraysEqual(cache, data))
            return;
        gl.uniformMatrix4fv(this.addr, false, data);
        this.updateCache(data);
    }
    function setValueT1a(gl, v, renderer) {
        var cache = this.cache;
        var n = v.length;
        var units = allocTexUnits(renderer, n);
        if (arraysEqual(cache, units) === false) {
            gl.uniform1iv(this.addr, units);
            copyArray(cache, units);
        }
        for (var i = 0; i !== n; ++i) {
            renderer.setTexture2D(v[i] || emptyTexture, units[i]);
        }
    }
    function setValueT6a(gl, v, renderer) {
        var cache = this.cache;
        var n = v.length;
        var units = allocTexUnits(renderer, n);
        if (arraysEqual(cache, units) === false) {
            gl.uniform1iv(this.addr, units);
            copyArray(cache, units);
        }
        for (var i = 0; i !== n; ++i) {
            renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
        }
    }
    function getPureArraySetter(type) {
        switch (type) {
            case 0x1406:
                return setValue1fv;
            case 0x8b50:
                return setValueV2a;
            case 0x8b51:
                return setValueV3a;
            case 0x8b52:
                return setValueV4a;
            case 0x8b5a:
                return setValueM2a;
            case 0x8b5b:
                return setValueM3a;
            case 0x8b5c:
                return setValueM4a;
            case 0x8b5e:
                return setValueT1a;
            case 0x8b60:
                return setValueT6a;
            case 0x1404:
            case 0x8b56:
                return setValue1iv;
            case 0x8b53:
            case 0x8b57:
                return setValue2iv;
            case 0x8b54:
            case 0x8b58:
                return setValue3iv;
            case 0x8b55:
            case 0x8b59:
                return setValue4iv;
        }
    }
    function SingleUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.setValue = getSingularSetter(activeInfo.type);
    }
    function PureArrayUniform(id, activeInfo, addr) {
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter(activeInfo.type);
    }
    PureArrayUniform.prototype.updateCache = function (data) {
        var cache = this.cache;
        if (data instanceof Float32Array && cache.length !== data.length) {
            this.cache = new Float32Array(data.length);
        }
        copyArray(cache, data);
    }
        ;
    function StructuredUniform(id) {
        this.id = id;
        UniformContainer.call(this);
    }
    StructuredUniform.prototype.setValue = function (gl, value) {
        var seq = this.seq;
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            u.setValue(gl, value[u.id]);
        }
    }
        ;
    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
    function addUniform(container, uniformObject) {
        container.seq.push(uniformObject);
        container.map[uniformObject.id] = uniformObject;
    }
    function parseUniform(activeInfo, addr, container) {
        var path = activeInfo.name
            , pathLength = path.length;
        RePathPart.lastIndex = 0;
        while (true) {
            var match = RePathPart.exec(path)
                , matchEnd = RePathPart.lastIndex
                , id = match[1]
                , idIsIndex = match[2] === ']'
                , subscript = match[3];
            if (idIsIndex)
                id = id | 0;
            if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
                addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                break;
            } else {
                var map = container.map
                    , next = map[id];
                if (next === undefined) {
                    next = new StructuredUniform(id);
                    addUniform(container, next);
                }
                container = next;
            }
        }
    }
    function WebGLUniforms(gl, program, renderer) {
        UniformContainer.call(this);
        this.renderer = renderer;
        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < n; ++i) {
            var info = gl.getActiveUniform(program, i)
                , addr = gl.getUniformLocation(program, info.name);
            parseUniform(info, addr, this);
        }
    }
    WebGLUniforms.prototype.setValue = function (gl, name, value) {
        var u = this.map[name];
        if (u !== undefined)
            u.setValue(gl, value, this.renderer);
    }
        ;
    WebGLUniforms.prototype.setOptional = function (gl, object, name) {
        var v = object[name];
        if (v !== undefined)
            this.setValue(gl, name, v);
    }
        ;
    WebGLUniforms.upload = function (gl, seq, values, renderer) {
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i]
                , v = values[u.id];
            if (v.needsUpdate !== false) {
                u.setValue(gl, v.value, renderer);
            }
        }
    }
        ;
    WebGLUniforms.seqWithValue = function (seq, values) {
        var r = [];
        for (var i = 0, n = seq.length; i !== n; ++i) {
            var u = seq[i];
            if (u.id in values)
                r.push(u);
        }
        return r;
    }
        ;
    function addLineNumbers(string) {
        var lines = string.split('\n');
        for (var i = 0; i < lines.length; i++) {
            lines[i] = (i + 1) + ': ' + lines[i];
        }
        return lines.join('\n');
    }
    function WebGLShader(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
            console.error('THREE.WebGLShader: Shader couldn\'t compile.');
        }
        if (gl.getShaderInfoLog(shader) !== '') {
            console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
        }
        return shader;
    }
    var programIdCount = 0;
    function getEncodingComponents(encoding) {
        switch (encoding) {
            case LinearEncoding:
                return ['Linear', '( value )'];
            case sRGBEncoding:
                return ['sRGB', '( value )'];
            case RGBEEncoding:
                return ['RGBE', '( value )'];
            case RGBM7Encoding:
                return ['RGBM', '( value, 7.0 )'];
            case RGBM16Encoding:
                return ['RGBM', '( value, 16.0 )'];
            case RGBDEncoding:
                return ['RGBD', '( value, 256.0 )'];
            case GammaEncoding:
                return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
            default:
                throw new Error('unsupported encoding: ' + encoding);
        }
    }
    function getTexelDecodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
    }
    function getTexelEncodingFunction(functionName, encoding) {
        var components = getEncodingComponents(encoding);
        return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
    }
    function getToneMappingFunction(functionName, toneMapping) {
        var toneMappingName;
        switch (toneMapping) {
            case LinearToneMapping:
                toneMappingName = 'Linear';
                break;
            case ReinhardToneMapping:
                toneMappingName = 'Reinhard';
                break;
            case Uncharted2ToneMapping:
                toneMappingName = 'Uncharted2';
                break;
            case CineonToneMapping:
                toneMappingName = 'OptimizedCineon';
                break;
            default:
                throw new Error('unsupported toneMapping: ' + toneMapping);
        }
        return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
    }
    function generateExtensions(extensions, parameters, rendererExtensions) {
        extensions = extensions || {};
        var chunks = [(extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '', (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '', (extensions.drawBuffers) && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '', (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
        return chunks.filter(filterEmptyLine).join('\n');
    }
    function generateDefines(defines) {
        var chunks = [];
        for (var name in defines) {
            var value = defines[name];
            if (value === false)
                continue;
            chunks.push('#define ' + name + ' ' + value);
        }
        return chunks.join('\n');
    }
    function fetchAttributeLocations(gl, program) {
        var attributes = {};
        var n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < n; i++) {
            var info = gl.getActiveAttrib(program, i);
            var name = info.name;
            attributes[name] = gl.getAttribLocation(program, name);
        }
        return attributes;
    }
    function filterEmptyLine(string) {
        return string !== '';
    }
    function replaceLightNums(string, parameters) {
        return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
    }
    function replaceClippingPlaneNums(string, parameters) {
        return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, (parameters.numClippingPlanes - parameters.numClipIntersection));
    }
    function parseIncludes(string) {
        var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;
        function replace(match, include) {
            var replace = ShaderChunk[include];
            if (replace === undefined) {
                throw new Error('Can not resolve #include <' + include + '>');
            }
            return parseIncludes(replace);
        }
        return string.replace(pattern, replace);
    }
    function unrollLoops(string) {
        var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
        function replace(match, start, end, snippet) {
            var unroll = '';
            for (var i = parseInt(start); i < parseInt(end); i++) {
                unroll += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]');
            }
            return unroll;
        }
        return string.replace(pattern, replace);
    }
    function WebGLProgram(renderer, extensions, code, material, shader, parameters) {
        var gl = renderer.context;
        var defines = material.defines;
        var vertexShader = shader.vertexShader;
        var fragmentShader = shader.fragmentShader;
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
        if (parameters.shadowMapType === PCFShadowMap) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        } else if (parameters.shadowMapType === PCFSoftShadowMap) {
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        }
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        if (parameters.envMap) {
            switch (material.envMap.mapping) {
                case CubeReflectionMapping:
                case CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;
                case CubeUVReflectionMapping:
                case CubeUVRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                    break;
                case EquirectangularReflectionMapping:
                case EquirectangularRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;
                case SphericalReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;
            }
            switch (material.envMap.mapping) {
                case CubeRefractionMapping:
                case EquirectangularRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;
            }
            switch (material.combine) {
                case MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;
                case MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;
                case AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;
            }
        }
        var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
        var customExtensions = generateExtensions(material.extensions, parameters, extensions);
        var customDefines = generateDefines(defines);
        var program = gl.createProgram();
        var prefixVertex, prefixFragment;
        if (material.isRawShaderMaterial) {
            prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');
            if (prefixVertex.length > 0) {
                prefixVertex += '\n';
            }
            prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');
            if (prefixFragment.length > 0) {
                prefixFragment += '\n';
            }
        } else {
            prefixVertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + shader.name, customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '', (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_COLOR', ' attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', ' attribute vec3 morphTarget0;', ' attribute vec3 morphTarget1;', ' attribute vec3 morphTarget2;', ' attribute vec3 morphTarget3;', ' #ifdef USE_MORPHNORMALS', '  attribute vec3 morphNormal0;', '  attribute vec3 morphNormal1;', '  attribute vec3 morphNormal2;', '  attribute vec3 morphNormal3;', ' #else', '  attribute vec3 morphTarget4;', '  attribute vec3 morphTarget5;', '  attribute vec3 morphTarget6;', '  attribute vec3 morphTarget7;', ' #endif', '#endif', '#ifdef USE_SKINNING', ' attribute vec4 skinIndex;', ' attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
            prefixFragment = [customExtensions, 'precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', '#define SHADER_NAME ' + shader.name, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '', (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '', parameters.envMap && extensions.get('EXT_shader_texture_lod') ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', (parameters.toneMapping !== NoToneMapping) ? '#define TONE_MAPPING' : '', (parameters.toneMapping !== NoToneMapping) ? ShaderChunk['tonemapping_pars_fragment'] : '', (parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', (parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding) ? ShaderChunk['encodings_pars_fragment'] : '', parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '', parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
        }
        vertexShader = parseIncludes(vertexShader);
        vertexShader = replaceLightNums(vertexShader, parameters);
        vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
        fragmentShader = parseIncludes(fragmentShader);
        fragmentShader = replaceLightNums(fragmentShader, parameters);
        fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
        vertexShader = unrollLoops(vertexShader);
        fragmentShader = unrollLoops(fragmentShader);
        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;
        var glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
        var glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
        gl.attachShader(program, glVertexShader);
        gl.attachShader(program, glFragmentShader);
        if (material.index0AttributeName !== undefined) {
            gl.bindAttribLocation(program, 0, material.index0AttributeName);
        } else if (parameters.morphTargets === true) {
            gl.bindAttribLocation(program, 0, 'position');
        }
        gl.linkProgram(program);
        var programLog = gl.getProgramInfoLog(program).trim();
        var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        var runnable = true;
        var haveDiagnostics = true;
        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
            runnable = false;
            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
        } else if (programLog !== '') {
            console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        } else if (vertexLog === '' || fragmentLog === '') {
            haveDiagnostics = false;
        }
        if (haveDiagnostics) {
            this.diagnostics = {
                runnable: runnable,
                material: material,
                programLog: programLog,
                vertexShader: {
                    log: vertexLog,
                    prefix: prefixVertex
                },
                fragmentShader: {
                    log: fragmentLog,
                    prefix: prefixFragment
                }
            };
        }
        gl.deleteShader(glVertexShader);
        gl.deleteShader(glFragmentShader);
        var cachedUniforms;
        this.getUniforms = function () {
            if (cachedUniforms === undefined) {
                cachedUniforms = new WebGLUniforms(gl, program, renderer);
            }
            return cachedUniforms;
        }
            ;
        var cachedAttributes;
        this.getAttributes = function () {
            if (cachedAttributes === undefined) {
                cachedAttributes = fetchAttributeLocations(gl, program);
            }
            return cachedAttributes;
        }
            ;
        this.destroy = function () {
            gl.deleteProgram(program);
            this.program = undefined;
        }
            ;
        Object.defineProperties(this, {
            uniforms: {
                get: function () {
                    console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
                    return this.getUniforms();
                }
            },
            attributes: {
                get: function () {
                    console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
                    return this.getAttributes();
                }
            }
        });
        this.name = shader.name;
        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
    }
    function WebGLPrograms(renderer, extensions, capabilities) {
        var programs = [];
        var shaderIDs = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'phong',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow'
        };
        var parameterNames = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
        function allocateBones(object) {
            var skeleton = object.skeleton;
            var bones = skeleton.bones;
            if (capabilities.floatVertexTextures) {
                return 1024;
            } else {
                var nVertexUniforms = capabilities.maxVertexUniforms;
                var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                var maxBones = Math.min(nVertexMatrices, bones.length);
                if (maxBones < bones.length) {
                    console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                    return 0;
                }
                return maxBones;
            }
        }
        function getTextureEncodingFromMap(map, gammaOverrideLinear) {
            var encoding;
            if (!map) {
                encoding = LinearEncoding;
            } else if (map.isTexture) {
                encoding = map.encoding;
            } else if (map.isWebGLRenderTarget) {
                console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
                encoding = map.texture.encoding;
            }
            if (encoding === LinearEncoding && gammaOverrideLinear) {
                encoding = GammaEncoding;
            }
            return encoding;
        }
        this.getParameters = function (material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
            var shaderID = shaderIDs[material.type];
            var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
            var precision = capabilities.precision;
            if (material.precision !== null) {
                precision = capabilities.getMaxPrecision(material.precision);
                if (precision !== material.precision) {
                    console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
                }
            }
            var currentRenderTarget = renderer.getRenderTarget();
            var parameters = {
                shaderID: shaderID,
                precision: precision,
                supportsVertexTextures: capabilities.vertexTextures,
                outputEncoding: getTextureEncodingFromMap((!currentRenderTarget) ? null : currentRenderTarget.texture, renderer.gammaOutput),
                map: !!material.map,
                mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
                envMap: !!material.envMap,
                envMapMode: material.envMap && material.envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
                envMapCubeUV: (!!material.envMap) && ((material.envMap.mapping === CubeUVReflectionMapping) || (material.envMap.mapping === CubeUVRefractionMapping)),
                lightMap: !!material.lightMap,
                aoMap: !!material.aoMap,
                emissiveMap: !!material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
                bumpMap: !!material.bumpMap,
                normalMap: !!material.normalMap,
                displacementMap: !!material.displacementMap,
                roughnessMap: !!material.roughnessMap,
                metalnessMap: !!material.metalnessMap,
                specularMap: !!material.specularMap,
                alphaMap: !!material.alphaMap,
                gradientMap: !!material.gradientMap,
                combine: material.combine,
                vertexColors: material.vertexColors,
                fog: !!fog,
                useFog: material.fog,
                fogExp: (fog && fog.isFogExp2),
                flatShading: material.flatShading,
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
                skinning: material.skinning && maxBones > 0,
                maxBones: maxBones,
                useVertexTexture: capabilities.floatVertexTextures,
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,
                dithering: material.dithering,
                shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
                toneMapping: renderer.toneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
                premultipliedAlpha: material.premultipliedAlpha,
                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
                depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false
            };
            return parameters;
        }
            ;
        this.getProgramCode = function (material, parameters) {
            var array = [];
            if (parameters.shaderID) {
                array.push(parameters.shaderID);
            } else {
                array.push(material.fragmentShader);
                array.push(material.vertexShader);
            }
            if (material.defines !== undefined) {
                for (var name in material.defines) {
                    array.push(name);
                    array.push(material.defines[name]);
                }
            }
            for (var i = 0; i < parameterNames.length; i++) {
                array.push(parameters[parameterNames[i]]);
            }
            array.push(material.onBeforeCompile.toString());
            array.push(renderer.gammaOutput);
            return array.join();
        }
            ;
        this.acquireProgram = function (material, shader, parameters, code) {
            var program;
            for (var p = 0, pl = programs.length; p < pl; p++) {
                var programInfo = programs[p];
                if (programInfo.code === code) {
                    program = programInfo;
                    ++program.usedTimes;
                    break;
                }
            }
            if (program === undefined) {
                program = new WebGLProgram(renderer, extensions, code, material, shader, parameters);
                programs.push(program);
            }
            return program;
        }
            ;
        this.releaseProgram = function (program) {
            if (--program.usedTimes === 0) {
                var i = programs.indexOf(program);
                programs[i] = programs[programs.length - 1];
                programs.pop();
                program.destroy();
            }
        }
            ;
        this.programs = programs;
    }
    function WebGLProperties() {
        var properties = new WeakMap();
        function get(object) {
            var map = properties.get(object);
            if (map === undefined) {
                map = {};
                properties.set(object, map);
            }
            return map;
        }
        function remove(object) {
            properties.delete(object);
        }
        function update(object, key, value) {
            properties.get(object)[key] = value;
        }
        function dispose() {
            properties = new WeakMap();
        }
        return {
            get: get,
            remove: remove,
            update: update,
            dispose: dispose
        };
    }
    function painterSortStable(a, b) {
        if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        } else if (a.program && b.program && a.program !== b.program) {
            return a.program.id - b.program.id;
        } else if (a.material.id !== b.material.id) {
            return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
            return a.z - b.z;
        } else {
            return a.id - b.id;
        }
    }
    function reversePainterSortStable(a, b) {
        if (a.renderOrder !== b.renderOrder) {
            return a.renderOrder - b.renderOrder;
        }
        if (a.z !== b.z) {
            return b.z - a.z;
        } else {
            return a.id - b.id;
        }
    }
    function WebGLRenderList() {
        var renderItems = [];
        var renderItemsIndex = 0;
        var opaque = [];
        var transparent = [];
        function init() {
            renderItemsIndex = 0;
            opaque.length = 0;
            transparent.length = 0;
        }
        function push(object, geometry, material, z, group) {
            var renderItem = renderItems[renderItemsIndex];
            if (renderItem === undefined) {
                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    program: material.program,
                    renderOrder: object.renderOrder,
                    z: z,
                    group: group
                };
                renderItems[renderItemsIndex] = renderItem;
            } else {
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.program = material.program;
                renderItem.renderOrder = object.renderOrder;
                renderItem.z = z;
                renderItem.group = group;
            }
            (material.transparent === true ? transparent : opaque).push(renderItem);
            renderItemsIndex++;
        }
        function sort() {
            if (opaque.length > 1)
                opaque.sort(painterSortStable);
            if (transparent.length > 1)
                transparent.sort(reversePainterSortStable);
        }
        return {
            opaque: opaque,
            transparent: transparent,
            init: init,
            push: push,
            sort: sort
        };
    }
    function WebGLRenderLists() {
        var lists = {};
        function get(scene, camera) {
            var hash = scene.id + ',' + camera.id;
            var list = lists[hash];
            if (list === undefined) {
                list = new WebGLRenderList();
                lists[hash] = list;
            }
            return list;
        }
        function dispose() {
            lists = {};
        }
        return {
            get: get,
            dispose: dispose
        };
    }
    function UniformsCache() {
        var lights = {};
        return {
            get: function (light) {
                if (lights[light.id] !== undefined) {
                    return lights[light.id];
                }
                var uniforms;
                switch (light.type) {
                    case 'DirectionalLight':
                        uniforms = {
                            direction: new Vector3(),
                            color: new Color(),
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;
                    case 'SpotLight':
                        uniforms = {
                            position: new Vector3(),
                            direction: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;
                    case 'PointLight':
                        uniforms = {
                            position: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            decay: 0,
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2(),
                            shadowCameraNear: 1,
                            shadowCameraFar: 1000
                        };
                        break;
                    case 'HemisphereLight':
                        uniforms = {
                            direction: new Vector3(),
                            skyColor: new Color(),
                            groundColor: new Color()
                        };
                        break;
                    case 'RectAreaLight':
                        uniforms = {
                            color: new Color(),
                            position: new Vector3(),
                            halfWidth: new Vector3(),
                            halfHeight: new Vector3()
                        };
                        break;
                }
                lights[light.id] = uniforms;
                return uniforms;
            }
        };
    }
    var count = 0;
    function WebGLLights() {
        var cache = new UniformsCache();
        var state = {
            id: count++,
            hash: '',
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        };
        var vector3 = new Vector3();
        var matrix4 = new Matrix4();
        var matrix42 = new Matrix4();
        function setup(lights, shadows, camera) {
            var r = 0
                , g = 0
                , b = 0;
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
            var viewMatrix = camera.matrixWorldInverse;
            for (var i = 0, l = lights.length; i < l; i++) {
                var light = lights[i];
                var color = light.color;
                var intensity = light.intensity;
                var distance = light.distance;
                var shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;
                if (light.isAmbientLight) {
                    r += color.r * intensity;
                    g += color.g * intensity;
                    b += color.b * intensity;
                } else if (light.isDirectionalLight) {
                    var uniforms = cache.get(light);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    state.directional[directionalLength] = uniforms;
                    directionalLength++;
                } else if (light.isSpotLight) {
                    var uniforms = cache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.distance = distance;
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    vector3.setFromMatrixPosition(light.target.matrixWorld);
                    uniforms.direction.sub(vector3);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.coneCos = Math.cos(light.angle);
                    uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                    uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                    }
                    state.spotShadowMap[spotLength] = shadowMap;
                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    state.spot[spotLength] = uniforms;
                    spotLength++;
                } else if (light.isRectAreaLight) {
                    var uniforms = cache.get(light);
                    uniforms.color.copy(color).multiplyScalar(intensity);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    matrix42.identity();
                    matrix4.copy(light.matrixWorld);
                    matrix4.premultiply(viewMatrix);
                    matrix42.extractRotation(matrix4);
                    uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                    uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                    uniforms.halfWidth.applyMatrix4(matrix42);
                    uniforms.halfHeight.applyMatrix4(matrix42);
                    state.rectArea[rectAreaLength] = uniforms;
                    rectAreaLength++;
                } else if (light.isPointLight) {
                    var uniforms = cache.get(light);
                    uniforms.position.setFromMatrixPosition(light.matrixWorld);
                    uniforms.position.applyMatrix4(viewMatrix);
                    uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                    uniforms.distance = light.distance;
                    uniforms.decay = (light.distance === 0) ? 0.0 : light.decay;
                    uniforms.shadow = light.castShadow;
                    if (light.castShadow) {
                        var shadow = light.shadow;
                        uniforms.shadowBias = shadow.bias;
                        uniforms.shadowRadius = shadow.radius;
                        uniforms.shadowMapSize = shadow.mapSize;
                        uniforms.shadowCameraNear = shadow.camera.near;
                        uniforms.shadowCameraFar = shadow.camera.far;
                    }
                    state.pointShadowMap[pointLength] = shadowMap;
                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    state.point[pointLength] = uniforms;
                    pointLength++;
                } else if (light.isHemisphereLight) {
                    var uniforms = cache.get(light);
                    uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                    uniforms.direction.transformDirection(viewMatrix);
                    uniforms.direction.normalize();
                    uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                    uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                    state.hemi[hemiLength] = uniforms;
                    hemiLength++;
                }
            }
            state.ambient[0] = r;
            state.ambient[1] = g;
            state.ambient[2] = b;
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.hash = state.id + ',' + directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;
        }
        return {
            setup: setup,
            state: state
        };
    }
    function WebGLRenderState() {
        var lights = new WebGLLights();
        var lightsArray = [];
        var shadowsArray = [];
        var spritesArray = [];
        function init() {
            lightsArray.length = 0;
            shadowsArray.length = 0;
            spritesArray.length = 0;
        }
        function pushLight(light) {
            lightsArray.push(light);
        }
        function pushShadow(shadowLight) {
            shadowsArray.push(shadowLight);
        }
        function pushSprite(shadowLight) {
            spritesArray.push(shadowLight);
        }
        function setupLights(camera) {
            lights.setup(lightsArray, shadowsArray, camera);
        }
        var state = {
            lightsArray: lightsArray,
            shadowsArray: shadowsArray,
            spritesArray: spritesArray,
            lights: lights
        };
        return {
            init: init,
            state: state,
            setupLights: setupLights,
            pushLight: pushLight,
            pushShadow: pushShadow,
            pushSprite: pushSprite
        };
    }
    function WebGLRenderStates() {
        var renderStates = {};
        function get(scene, camera) {
            var hash = scene.id + ',' + camera.id;
            var renderState = renderStates[hash];
            if (renderState === undefined) {
                renderState = new WebGLRenderState();
                renderStates[hash] = renderState;
            }
            return renderState;
        }
        function dispose() {
            renderStates = {};
        }
        return {
            get: get,
            dispose: dispose
        };
    }
    function MeshDepthMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshDepthMaterial';
        this.depthPacking = BasicDepthPacking;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.setValues(parameters);
    }
    MeshDepthMaterial.prototype = Object.create(Material.prototype);
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    MeshDepthMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.depthPacking = source.depthPacking;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    }
        ;
    function MeshDistanceMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshDistanceMaterial';
        this.referencePosition = new Vector3();
        this.nearDistance = 1;
        this.farDistance = 1000;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.fog = false;
        this.lights = false;
        this.setValues(parameters);
    }
    MeshDistanceMaterial.prototype = Object.create(Material.prototype);
    MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
    MeshDistanceMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
    }
        ;
    function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
        var _frustum = new Frustum()
            , _projScreenMatrix = new Matrix4()
            , _shadowMapSize = new Vector2()
            , _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize)
            , _lookTarget = new Vector3()
            , _lightPositionWorld = new Vector3()
            , _MorphingFlag = 1
            , _SkinningFlag = 2
            , _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1
            , _depthMaterials = new Array(_NumberOfMaterialVariants)
            , _distanceMaterials = new Array(_NumberOfMaterialVariants)
            , _materialCache = {};
        var shadowSide = {
            0: BackSide,
            1: FrontSide,
            2: DoubleSide
        };
        var cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
        var cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
        var cube2DViewPorts = [new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4(), new Vector4()];
        for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
            var useMorphing = (i & _MorphingFlag) !== 0;
            var useSkinning = (i & _SkinningFlag) !== 0;
            var depthMaterial = new MeshDepthMaterial({
                depthPacking: RGBADepthPacking,
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _depthMaterials[i] = depthMaterial;
            var distanceMaterial = new MeshDistanceMaterial({
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _distanceMaterials[i] = distanceMaterial;
        }
        var scope = this;
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = PCFShadowMap;
        this.render = function (lights, scene, camera) {
            if (scope.enabled === false)
                return;
            if (scope.autoUpdate === false && scope.needsUpdate === false)
                return;
            if (lights.length === 0)
                return;
            var _gl = _renderer.context;
            var _state = _renderer.state;
            _state.disable(_gl.BLEND);
            _state.buffers.color.setClear(1, 1, 1, 1);
            _state.buffers.depth.setTest(true);
            _state.setScissorTest(false);
            var faceCount;
            for (var i = 0, il = lights.length; i < il; i++) {
                var light = lights[i];
                var shadow = light.shadow;
                var isPointLight = light && light.isPointLight;
                if (shadow === undefined) {
                    console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                    continue;
                }
                var shadowCamera = shadow.camera;
                _shadowMapSize.copy(shadow.mapSize);
                _shadowMapSize.min(_maxShadowMapSize);
                if (isPointLight) {
                    var vpWidth = _shadowMapSize.x;
                    var vpHeight = _shadowMapSize.y;
                    cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
                    cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
                    cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
                    _shadowMapSize.x *= 4.0;
                    _shadowMapSize.y *= 2.0;
                }
                if (shadow.map === null) {
                    var pars = {
                        minFilter: NearestFilter,
                        magFilter: NearestFilter,
                        format: RGBAFormat
                    };
                    shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                    shadow.map.texture.name = light.name + ".shadowMap";
                    shadowCamera.updateProjectionMatrix();
                }
                if (shadow.isSpotLightShadow) {
                    shadow.update(light);
                }
                var shadowMap = shadow.map;
                var shadowMatrix = shadow.matrix;
                _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                shadowCamera.position.copy(_lightPositionWorld);
                if (isPointLight) {
                    faceCount = 6;
                    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
                } else {
                    faceCount = 1;
                    _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
                    shadowCamera.lookAt(_lookTarget);
                    shadowCamera.updateMatrixWorld();
                    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                    shadowMatrix.multiply(shadowCamera.projectionMatrix);
                    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                }
                _renderer.setRenderTarget(shadowMap);
                _renderer.clear();
                for (var face = 0; face < faceCount; face++) {
                    if (isPointLight) {
                        _lookTarget.copy(shadowCamera.position);
                        _lookTarget.add(cubeDirections[face]);
                        shadowCamera.up.copy(cubeUps[face]);
                        shadowCamera.lookAt(_lookTarget);
                        shadowCamera.updateMatrixWorld();
                        var vpDimensions = cube2DViewPorts[face];
                        _state.viewport(vpDimensions);
                    }
                    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                    _frustum.setFromMatrix(_projScreenMatrix);
                    renderObject(scene, camera, shadowCamera, isPointLight);
                }
            }
            scope.needsUpdate = false;
        }
            ;
        function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
            var geometry = object.geometry;
            var result = null;
            var materialVariants = _depthMaterials;
            var customMaterial = object.customDepthMaterial;
            if (isPointLight) {
                materialVariants = _distanceMaterials;
                customMaterial = object.customDistanceMaterial;
            }
            if (!customMaterial) {
                var useMorphing = false;
                if (material.morphTargets) {
                    if (geometry && geometry.isBufferGeometry) {
                        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
                    } else if (geometry && geometry.isGeometry) {
                        useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
                    }
                }
                if (object.isSkinnedMesh && material.skinning === false) {
                    console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
                }
                var useSkinning = object.isSkinnedMesh && material.skinning;
                var variantIndex = 0;
                if (useMorphing)
                    variantIndex |= _MorphingFlag;
                if (useSkinning)
                    variantIndex |= _SkinningFlag;
                result = materialVariants[variantIndex];
            } else {
                result = customMaterial;
            }
            if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
                var keyA = result.uuid
                    , keyB = material.uuid;
                var materialsForVariant = _materialCache[keyA];
                if (materialsForVariant === undefined) {
                    materialsForVariant = {};
                    _materialCache[keyA] = materialsForVariant;
                }
                var cachedMaterial = materialsForVariant[keyB];
                if (cachedMaterial === undefined) {
                    cachedMaterial = result.clone();
                    materialsForVariant[keyB] = cachedMaterial;
                }
                result = cachedMaterial;
            }
            result.visible = material.visible;
            result.wireframe = material.wireframe;
            result.side = (material.shadowSide != null) ? material.shadowSide : shadowSide[material.side];
            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;
            result.clipIntersection = material.clipIntersection;
            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;
            if (isPointLight && result.isMeshDistanceMaterial) {
                result.referencePosition.copy(lightPositionWorld);
                result.nearDistance = shadowCameraNear;
                result.farDistance = shadowCameraFar;
            }
            return result;
        }
        function renderObject(object, camera, shadowCamera, isPointLight) {
            if (object.visible === false)
                return;
            var visible = object.layers.test(camera.layers);
            if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                    object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                    var geometry = _objects.update(object);
                    var material = object.material;
                    if (Array.isArray(material)) {
                        var groups = geometry.groups;
                        for (var k = 0, kl = groups.length; k < kl; k++) {
                            var group = groups[k];
                            var groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) {
                                var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                            }
                        }
                    } else if (material.visible) {
                        var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                        _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                renderObject(children[i], camera, shadowCamera, isPointLight);
            }
        }
    }
    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
    }
    CanvasTexture.prototype = Object.create(Texture.prototype);
    CanvasTexture.prototype.constructor = CanvasTexture;
    CanvasTexture.prototype.isCanvasTexture = true;
    function WebGLSpriteRenderer(renderer, gl, state, textures, capabilities) {
        var vertexBuffer, elementBuffer;
        var program, attributes, uniforms;
        var texture;
        var spritePosition = new Vector3();
        var spriteRotation = new Quaternion();
        var spriteScale = new Vector3();
        function init() {
            var vertices = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]);
            var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
            vertexBuffer = gl.createBuffer();
            elementBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
            program = createProgram();
            attributes = {
                position: gl.getAttribLocation(program, 'position'),
                uv: gl.getAttribLocation(program, 'uv')
            };
            uniforms = {
                uvOffset: gl.getUniformLocation(program, 'uvOffset'),
                uvScale: gl.getUniformLocation(program, 'uvScale'),
                rotation: gl.getUniformLocation(program, 'rotation'),
                center: gl.getUniformLocation(program, 'center'),
                scale: gl.getUniformLocation(program, 'scale'),
                color: gl.getUniformLocation(program, 'color'),
                map: gl.getUniformLocation(program, 'map'),
                opacity: gl.getUniformLocation(program, 'opacity'),
                modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
                projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
                fogType: gl.getUniformLocation(program, 'fogType'),
                fogDensity: gl.getUniformLocation(program, 'fogDensity'),
                fogNear: gl.getUniformLocation(program, 'fogNear'),
                fogFar: gl.getUniformLocation(program, 'fogFar'),
                fogColor: gl.getUniformLocation(program, 'fogColor'),
                fogDepth: gl.getUniformLocation(program, 'fogDepth'),
                alphaTest: gl.getUniformLocation(program, 'alphaTest')
            };
            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            canvas.width = 8;
            canvas.height = 8;
            var context = canvas.getContext('2d');
            context.fillStyle = 'white';
            context.fillRect(0, 0, 8, 8);
            texture = new CanvasTexture(canvas);
        }
        this.render = function (sprites, scene, camera) {
            if (sprites.length === 0)
                return;
            if (program === undefined) {
                init();
            }
            state.useProgram(program);
            state.initAttributes();
            state.enableAttribute(attributes.position);
            state.enableAttribute(attributes.uv);
            state.disableUnusedAttributes();
            state.disable(gl.CULL_FACE);
            state.enable(gl.BLEND);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
            gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
            gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
            state.activeTexture(gl.TEXTURE0);
            gl.uniform1i(uniforms.map, 0);
            var oldFogType = 0;
            var sceneFogType = 0;
            var fog = scene.fog;
            if (fog) {
                gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
                if (fog.isFog) {
                    gl.uniform1f(uniforms.fogNear, fog.near);
                    gl.uniform1f(uniforms.fogFar, fog.far);
                    gl.uniform1i(uniforms.fogType, 1);
                    oldFogType = 1;
                    sceneFogType = 1;
                } else if (fog.isFogExp2) {
                    gl.uniform1f(uniforms.fogDensity, fog.density);
                    gl.uniform1i(uniforms.fogType, 2);
                    oldFogType = 2;
                    sceneFogType = 2;
                }
            } else {
                gl.uniform1i(uniforms.fogType, 0);
                oldFogType = 0;
                sceneFogType = 0;
            }
            for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
                sprite.z = -sprite.modelViewMatrix.elements[14];
            }
            sprites.sort(painterSortStable);
            var scale = [];
            var center = [];
            for (var i = 0, l = sprites.length; i < l; i++) {
                var sprite = sprites[i];
                var material = sprite.material;
                if (material.visible === false)
                    continue;
                sprite.onBeforeRender(renderer, scene, camera, undefined, material, undefined);
                gl.uniform1f(uniforms.alphaTest, material.alphaTest);
                gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements);
                sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
                scale[0] = spriteScale.x;
                scale[1] = spriteScale.y;
                center[0] = sprite.center.x - 0.5;
                center[1] = sprite.center.y - 0.5;
                var fogType = 0;
                if (scene.fog && material.fog) {
                    fogType = sceneFogType;
                }
                if (oldFogType !== fogType) {
                    gl.uniform1i(uniforms.fogType, fogType);
                    oldFogType = fogType;
                }
                if (material.map !== null) {
                    gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
                    gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
                } else {
                    gl.uniform2f(uniforms.uvOffset, 0, 0);
                    gl.uniform2f(uniforms.uvScale, 1, 1);
                }
                gl.uniform1f(uniforms.opacity, material.opacity);
                gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
                gl.uniform1f(uniforms.rotation, material.rotation);
                gl.uniform2fv(uniforms.center, center);
                gl.uniform2fv(uniforms.scale, scale);
                state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
                state.buffers.depth.setTest(material.depthTest);
                state.buffers.depth.setMask(material.depthWrite);
                state.buffers.color.setMask(material.colorWrite);
                textures.setTexture2D(material.map || texture, 0);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                sprite.onAfterRender(renderer, scene, camera, undefined, material, undefined);
            }
            state.enable(gl.CULL_FACE);
            state.reset();
        }
            ;
        function createProgram() {
            var program = gl.createProgram();
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(vertexShader, ['precision ' + capabilities.precision + ' float;', '#define SHADER_NAME ' + 'SpriteMaterial', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform float rotation;', 'uniform vec2 center;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'varying float fogDepth;', 'void main() {', ' vUV = uvOffset + uv * uvScale;', ' vec2 alignedPosition = ( position - center ) * scale;', ' vec2 rotatedPosition;', ' rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;', ' rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;', ' vec4 mvPosition;', ' mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );', ' mvPosition.xy += rotatedPosition;', ' gl_Position = projectionMatrix * mvPosition;', ' fogDepth = - mvPosition.z;', '}'].join('\n'));
            gl.shaderSource(fragmentShader, ['precision ' + capabilities.precision + ' float;', '#define SHADER_NAME ' + 'SpriteMaterial', 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', 'varying vec2 vUV;', 'varying float fogDepth;', 'void main() {', ' vec4 texture = texture2D( map, vUV );', ' gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', ' if ( gl_FragColor.a < alphaTest ) discard;', ' if ( fogType > 0 ) {', '  float fogFactor = 0.0;', '  if ( fogType == 1 ) {', '   fogFactor = smoothstep( fogNear, fogFar, fogDepth );', '  } else {', '   const float LOG2 = 1.442695;', '   fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );', '   fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '  }', '  gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );', ' }', '}'].join('\n'));
            gl.compileShader(vertexShader);
            gl.compileShader(fragmentShader);
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }
        function painterSortStable(a, b) {
            if (a.renderOrder !== b.renderOrder) {
                return a.renderOrder - b.renderOrder;
            } else if (a.z !== b.z) {
                return b.z - a.z;
            } else {
                return b.id - a.id;
            }
        }
    }
    function WebGLState(gl, extensions, utils) {
        function ColorBuffer() {
            var locked = false;
            var color = new Vector4();
            var currentColorMask = null;
            var currentColorClear = new Vector4(0, 0, 0, 0);
            return {
                setMask: function (colorMask) {
                    if (currentColorMask !== colorMask && !locked) {
                        gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                        currentColorMask = colorMask;
                    }
                },
                setLocked: function (lock) {
                    locked = lock;
                },
                setClear: function (r, g, b, a, premultipliedAlpha) {
                    if (premultipliedAlpha === true) {
                        r *= a;
                        g *= a;
                        b *= a;
                    }
                    color.set(r, g, b, a);
                    if (currentColorClear.equals(color) === false) {
                        gl.clearColor(r, g, b, a);
                        currentColorClear.copy(color);
                    }
                },
                reset: function () {
                    locked = false;
                    currentColorMask = null;
                    currentColorClear.set(-1, 0, 0, 0);
                }
            };
        }
        function DepthBuffer() {
            var locked = false;
            var currentDepthMask = null;
            var currentDepthFunc = null;
            var currentDepthClear = null;
            return {
                setTest: function (depthTest) {
                    if (depthTest) {
                        enable(gl.DEPTH_TEST);
                    } else {
                        disable(gl.DEPTH_TEST);
                    }
                },
                setMask: function (depthMask) {
                    if (currentDepthMask !== depthMask && !locked) {
                        gl.depthMask(depthMask);
                        currentDepthMask = depthMask;
                    }
                },
                setFunc: function (depthFunc) {
                    if (currentDepthFunc !== depthFunc) {
                        if (depthFunc) {
                            switch (depthFunc) {
                                case NeverDepth:
                                    gl.depthFunc(gl.NEVER);
                                    break;
                                case AlwaysDepth:
                                    gl.depthFunc(gl.ALWAYS);
                                    break;
                                case LessDepth:
                                    gl.depthFunc(gl.LESS);
                                    break;
                                case LessEqualDepth:
                                    gl.depthFunc(gl.LEQUAL);
                                    break;
                                case EqualDepth:
                                    gl.depthFunc(gl.EQUAL);
                                    break;
                                case GreaterEqualDepth:
                                    gl.depthFunc(gl.GEQUAL);
                                    break;
                                case GreaterDepth:
                                    gl.depthFunc(gl.GREATER);
                                    break;
                                case NotEqualDepth:
                                    gl.depthFunc(gl.NOTEQUAL);
                                    break;
                                default:
                                    gl.depthFunc(gl.LEQUAL);
                            }
                        } else {
                            gl.depthFunc(gl.LEQUAL);
                        }
                        currentDepthFunc = depthFunc;
                    }
                },
                setLocked: function (lock) {
                    locked = lock;
                },
                setClear: function (depth) {
                    if (currentDepthClear !== depth) {
                        gl.clearDepth(depth);
                        currentDepthClear = depth;
                    }
                },
                reset: function () {
                    locked = false;
                    currentDepthMask = null;
                    currentDepthFunc = null;
                    currentDepthClear = null;
                }
            };
        }
        function StencilBuffer() {
            var locked = false;
            var currentStencilMask = null;
            var currentStencilFunc = null;
            var currentStencilRef = null;
            var currentStencilFuncMask = null;
            var currentStencilFail = null;
            var currentStencilZFail = null;
            var currentStencilZPass = null;
            var currentStencilClear = null;
            return {
                setTest: function (stencilTest) {
                    if (stencilTest) {
                        enable(gl.STENCIL_TEST);
                    } else {
                        disable(gl.STENCIL_TEST);
                    }
                },
                setMask: function (stencilMask) {
                    if (currentStencilMask !== stencilMask && !locked) {
                        gl.stencilMask(stencilMask);
                        currentStencilMask = stencilMask;
                    }
                },
                setFunc: function (stencilFunc, stencilRef, stencilMask) {
                    if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                        gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                        currentStencilFunc = stencilFunc;
                        currentStencilRef = stencilRef;
                        currentStencilFuncMask = stencilMask;
                    }
                },
                setOp: function (stencilFail, stencilZFail, stencilZPass) {
                    if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                        gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                        currentStencilFail = stencilFail;
                        currentStencilZFail = stencilZFail;
                        currentStencilZPass = stencilZPass;
                    }
                },
                setLocked: function (lock) {
                    locked = lock;
                },
                setClear: function (stencil) {
                    if (currentStencilClear !== stencil) {
                        gl.clearStencil(stencil);
                        currentStencilClear = stencil;
                    }
                },
                reset: function () {
                    locked = false;
                    currentStencilMask = null;
                    currentStencilFunc = null;
                    currentStencilRef = null;
                    currentStencilFuncMask = null;
                    currentStencilFail = null;
                    currentStencilZFail = null;
                    currentStencilZPass = null;
                    currentStencilClear = null;
                }
            };
        }
        var colorBuffer = new ColorBuffer();
        var depthBuffer = new DepthBuffer();
        var stencilBuffer = new StencilBuffer();
        var maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        var newAttributes = new Uint8Array(maxVertexAttributes);
        var enabledAttributes = new Uint8Array(maxVertexAttributes);
        var attributeDivisors = new Uint8Array(maxVertexAttributes);
        var capabilities = {};
        var compressedTextureFormats = null;
        var currentProgram = null;
        var currentBlending = null;
        var currentBlendEquation = null;
        var currentBlendSrc = null;
        var currentBlendDst = null;
        var currentBlendEquationAlpha = null;
        var currentBlendSrcAlpha = null;
        var currentBlendDstAlpha = null;
        var currentPremultipledAlpha = false;
        var currentFlipSided = null;
        var currentCullFace = null;
        var currentLineWidth = null;
        var currentPolygonOffsetFactor = null;
        var currentPolygonOffsetUnits = null;
        var maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        var lineWidthAvailable = false;
        var version = 0;
        var glVersion = gl.getParameter(gl.VERSION);
        if (glVersion.indexOf('WebGL') !== -1) {
            version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
            lineWidthAvailable = (version >= 1.0);
        } else if (glVersion.indexOf('OpenGL ES') !== -1) {
            version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
            lineWidthAvailable = (version >= 2.0);
        }
        var currentTextureSlot = null;
        var currentBoundTextures = {};
        var currentScissor = new Vector4();
        var currentViewport = new Vector4();
        function createTexture(type, target, count) {
            var data = new Uint8Array(4);
            var texture = gl.createTexture();
            gl.bindTexture(type, texture);
            gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            for (var i = 0; i < count; i++) {
                gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
            }
            return texture;
        }
        var emptyTextures = {};
        emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
        emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
        colorBuffer.setClear(0, 0, 0, 1);
        depthBuffer.setClear(1);
        stencilBuffer.setClear(0);
        enable(gl.DEPTH_TEST);
        depthBuffer.setFunc(LessEqualDepth);
        setFlipSided(false);
        setCullFace(CullFaceBack);
        enable(gl.CULL_FACE);
        enable(gl.BLEND);
        setBlending(NormalBlending);
        function initAttributes() {
            for (var i = 0, l = newAttributes.length; i < l; i++) {
                newAttributes[i] = 0;
            }
        }
        function enableAttribute(attribute) {
            enableAttributeAndDivisor(attribute, 0);
        }
        function enableAttributeAndDivisor(attribute, meshPerAttribute) {
            newAttributes[attribute] = 1;
            if (enabledAttributes[attribute] === 0) {
                gl.enableVertexAttribArray(attribute);
                enabledAttributes[attribute] = 1;
            }
            if (attributeDivisors[attribute] !== meshPerAttribute) {
                var extension = extensions.get('ANGLE_instanced_arrays');
                extension.vertexAttribDivisorANGLE(attribute, meshPerAttribute);
                attributeDivisors[attribute] = meshPerAttribute;
            }
        }
        function disableUnusedAttributes() {
            for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
                if (enabledAttributes[i] !== newAttributes[i]) {
                    gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
        }
        function enable(id) {
            if (capabilities[id] !== true) {
                gl.enable(id);
                capabilities[id] = true;
            }
        }
        function disable(id) {
            if (capabilities[id] !== false) {
                gl.disable(id);
                capabilities[id] = false;
            }
        }
        function getCompressedTextureFormats() {
            if (compressedTextureFormats === null) {
                compressedTextureFormats = [];
                if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc') || extensions.get('WEBGL_compressed_texture_etc1') || extensions.get('WEBGL_compressed_texture_astc')) {
                    var formats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
                    for (var i = 0; i < formats.length; i++) {
                        compressedTextureFormats.push(formats[i]);
                    }
                }
            }
            return compressedTextureFormats;
        }
        function useProgram(program) {
            if (currentProgram !== program) {
                gl.useProgram(program);
                currentProgram = program;
                return true;
            }
            return false;
        }
        function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
            if (blending !== NoBlending) {
                enable(gl.BLEND);
            } else {
                disable(gl.BLEND);
            }
            if (blending !== CustomBlending) {
                if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                    switch (blending) {
                        case AdditiveBlending:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
                            } else {
                                gl.blendEquation(gl.FUNC_ADD);
                                gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                            }
                            break;
                        case SubtractiveBlending:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                            } else {
                                gl.blendEquation(gl.FUNC_ADD);
                                gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                            }
                            break;
                        case MultiplyBlending:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                            } else {
                                gl.blendEquation(gl.FUNC_ADD);
                                gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                            }
                            break;
                        default:
                            if (premultipliedAlpha) {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                            } else {
                                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                            }
                    }
                }
                currentBlendEquation = null;
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendEquationAlpha = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
            } else {
                blendEquationAlpha = blendEquationAlpha || blendEquation;
                blendSrcAlpha = blendSrcAlpha || blendSrc;
                blendDstAlpha = blendDstAlpha || blendDst;
                if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                    gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));
                    currentBlendEquation = blendEquation;
                    currentBlendEquationAlpha = blendEquationAlpha;
                }
                if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                    gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));
                    currentBlendSrc = blendSrc;
                    currentBlendDst = blendDst;
                    currentBlendSrcAlpha = blendSrcAlpha;
                    currentBlendDstAlpha = blendDstAlpha;
                }
            }
            currentBlending = blending;
            currentPremultipledAlpha = premultipliedAlpha;
        }
        function setMaterial(material, frontFaceCW) {
            material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
            var flipSided = (material.side === BackSide);
            if (frontFaceCW)
                flipSided = !flipSided;
            setFlipSided(flipSided);
            material.transparent === true ? setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha) : setBlending(NoBlending);
            depthBuffer.setFunc(material.depthFunc);
            depthBuffer.setTest(material.depthTest);
            depthBuffer.setMask(material.depthWrite);
            colorBuffer.setMask(material.colorWrite);
            setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        }
        function setFlipSided(flipSided) {
            if (currentFlipSided !== flipSided) {
                if (flipSided) {
                    gl.frontFace(gl.CW);
                } else {
                    gl.frontFace(gl.CCW);
                }
                currentFlipSided = flipSided;
            }
        }
        function setCullFace(cullFace) {
            if (cullFace !== CullFaceNone) {
                enable(gl.CULL_FACE);
                if (cullFace !== currentCullFace) {
                    if (cullFace === CullFaceBack) {
                        gl.cullFace(gl.BACK);
                    } else if (cullFace === CullFaceFront) {
                        gl.cullFace(gl.FRONT);
                    } else {
                        gl.cullFace(gl.FRONT_AND_BACK);
                    }
                }
            } else {
                disable(gl.CULL_FACE);
            }
            currentCullFace = cullFace;
        }
        function setLineWidth(width) {
            if (width !== currentLineWidth) {
                if (lineWidthAvailable)
                    gl.lineWidth(width);
                currentLineWidth = width;
            }
        }
        function setPolygonOffset(polygonOffset, factor, units) {
            if (polygonOffset) {
                enable(gl.POLYGON_OFFSET_FILL);
                if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                    gl.polygonOffset(factor, units);
                    currentPolygonOffsetFactor = factor;
                    currentPolygonOffsetUnits = units;
                }
            } else {
                disable(gl.POLYGON_OFFSET_FILL);
            }
        }
        function setScissorTest(scissorTest) {
            if (scissorTest) {
                enable(gl.SCISSOR_TEST);
            } else {
                disable(gl.SCISSOR_TEST);
            }
        }
        function activeTexture(webglSlot) {
            if (webglSlot === undefined)
                webglSlot = gl.TEXTURE0 + maxTextures - 1;
            if (currentTextureSlot !== webglSlot) {
                gl.activeTexture(webglSlot);
                currentTextureSlot = webglSlot;
            }
        }
        function bindTexture(webglType, webglTexture) {
            if (currentTextureSlot === null) {
                activeTexture();
            }
            var boundTexture = currentBoundTextures[currentTextureSlot];
            if (boundTexture === undefined) {
                boundTexture = {
                    type: undefined,
                    texture: undefined
                };
                currentBoundTextures[currentTextureSlot] = boundTexture;
            }
            if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
            }
        }
        function compressedTexImage2D() {
            try {
                gl.compressedTexImage2D.apply(gl, arguments);
            } catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }
        function texImage2D() {
            try {
                gl.texImage2D.apply(gl, arguments);
            } catch (error) {
                console.error('THREE.WebGLState:', error);
            }
        }
        function scissor(scissor) {
            if (currentScissor.equals(scissor) === false) {
                gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                currentScissor.copy(scissor);
            }
        }
        function viewport(viewport) {
            if (currentViewport.equals(viewport) === false) {
                gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                currentViewport.copy(viewport);
            }
        }
        function reset() {
            for (var i = 0; i < enabledAttributes.length; i++) {
                if (enabledAttributes[i] === 1) {
                    gl.disableVertexAttribArray(i);
                    enabledAttributes[i] = 0;
                }
            }
            capabilities = {};
            compressedTextureFormats = null;
            currentTextureSlot = null;
            currentBoundTextures = {};
            currentProgram = null;
            currentBlending = null;
            currentFlipSided = null;
            currentCullFace = null;
            colorBuffer.reset();
            depthBuffer.reset();
            stencilBuffer.reset();
        }
        return {
            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            enableAttributeAndDivisor: enableAttributeAndDivisor,
            disableUnusedAttributes: disableUnusedAttributes,
            enable: enable,
            disable: disable,
            getCompressedTextureFormats: getCompressedTextureFormats,
            useProgram: useProgram,
            setBlending: setBlending,
            setMaterial: setMaterial,
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
            setScissorTest: setScissorTest,
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,
            scissor: scissor,
            viewport: viewport,
            reset: reset
        };
    }
    function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
        var _isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext);
        var _videoTextures = {};
        var _canvas;
        function clampToMaxSize(image, maxSize) {
            if (image.width > maxSize || image.height > maxSize) {
                if ('data' in image) {
                    console.warn('THREE.WebGLRenderer: image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                    return;
                }
                var scale = maxSize / Math.max(image.width, image.height);
                var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                canvas.width = Math.floor(image.width * scale);
                canvas.height = Math.floor(image.height * scale);
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                console.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
                return canvas;
            }
            return image;
        }
        function isPowerOfTwo(image) {
            return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
        }
        function makePowerOfTwo(image) {
            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap) {
                if (_canvas === undefined)
                    _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
                _canvas.width = _Math.floorPowerOfTwo(image.width);
                _canvas.height = _Math.floorPowerOfTwo(image.height);
                var context = _canvas.getContext('2d');
                context.drawImage(image, 0, 0, _canvas.width, _canvas.height);
                console.warn('THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + _canvas.width + 'x' + _canvas.height, image);
                return _canvas;
            }
            return image;
        }
        function textureNeedsPowerOfTwo(texture) {
            return (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) || (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter);
        }
        function textureNeedsGenerateMipmaps(texture, isPowerOfTwo) {
            return texture.generateMipmaps && isPowerOfTwo && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
        }
        function generateMipmap(target, texture, width, height) {
            _gl.generateMipmap(target);
            var textureProperties = properties.get(texture);
            textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
        }
        function filterFallback(f) {
            if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
                return _gl.NEAREST;
            }
            return _gl.LINEAR;
        }
        function onTextureDispose(event) {
            var texture = event.target;
            texture.removeEventListener('dispose', onTextureDispose);
            deallocateTexture(texture);
            if (texture.isVideoTexture) {
                delete _videoTextures[texture.id];
            }
            info.memory.textures--;
        }
        function onRenderTargetDispose(event) {
            var renderTarget = event.target;
            renderTarget.removeEventListener('dispose', onRenderTargetDispose);
            deallocateRenderTarget(renderTarget);
            info.memory.textures--;
        }
        function deallocateTexture(texture) {
            var textureProperties = properties.get(texture);
            if (texture.image && textureProperties.__image__webglTextureCube) {
                _gl.deleteTexture(textureProperties.__image__webglTextureCube);
            } else {
                if (textureProperties.__webglInit === undefined)
                    return;
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            properties.remove(texture);
        }
        function deallocateRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            if (!renderTarget)
                return;
            if (textureProperties.__webglTexture !== undefined) {
                _gl.deleteTexture(textureProperties.__webglTexture);
            }
            if (renderTarget.depthTexture) {
                renderTarget.depthTexture.dispose();
            }
            if (renderTarget.isWebGLRenderTargetCube) {
                for (var i = 0; i < 6; i++) {
                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                    if (renderTargetProperties.__webglDepthbuffer)
                        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                }
            } else {
                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                if (renderTargetProperties.__webglDepthbuffer)
                    _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            }
            properties.remove(renderTarget.texture);
            properties.remove(renderTarget);
        }
        function setTexture2D(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.isVideoTexture)
                updateVideoTexture(texture);
            if (texture.version > 0 && textureProperties.__version !== texture.version) {
                var image = texture.image;
                if (image === undefined) {
                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined', texture);
                } else if (image.complete === false) {
                    console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture);
                } else {
                    uploadTexture(textureProperties, texture, slot);
                    return;
                }
            }
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
        }
        function setTextureCube(texture, slot) {
            var textureProperties = properties.get(texture);
            if (texture.image.length === 6) {
                if (texture.version > 0 && textureProperties.__version !== texture.version) {
                    if (!textureProperties.__image__webglTextureCube) {
                        texture.addEventListener('dispose', onTextureDispose);
                        textureProperties.__image__webglTextureCube = _gl.createTexture();
                        info.memory.textures++;
                    }
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                    var isCompressed = (texture && texture.isCompressedTexture);
                    var isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);
                    var cubeImage = [];
                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed && !isDataTexture) {
                            cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
                        } else {
                            cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                        }
                    }
                    var image = cubeImage[0]
                        , isPowerOfTwoImage = isPowerOfTwo(image)
                        , glFormat = utils.convert(texture.format)
                        , glType = utils.convert(texture.type);
                    setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage);
                    for (var i = 0; i < 6; i++) {
                        if (!isCompressed) {
                            if (isDataTexture) {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                            } else {
                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                            }
                        } else {
                            var mipmap, mipmaps = cubeImage[i].mipmaps;
                            for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                                mipmap = mipmaps[j];
                                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                                    if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                                        state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                    } else {
                                        console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                                    }
                                } else {
                                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                }
                            }
                        }
                    }
                    if (!isCompressed) {
                        textureProperties.__maxMipLevel = 0;
                    } else {
                        textureProperties.__maxMipLevel = mipmaps.length - 1;
                    }
                    if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
                        generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
                    }
                    textureProperties.__version = texture.version;
                    if (texture.onUpdate)
                        texture.onUpdate(texture);
                } else {
                    state.activeTexture(_gl.TEXTURE0 + slot);
                    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube);
                }
            }
        }
        function setTextureCubeDynamic(texture, slot) {
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
        }
        function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
            var extension;
            if (isPowerOfTwoImage) {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, utils.convert(texture.wrapS));
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, utils.convert(texture.wrapT));
                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, utils.convert(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, utils.convert(texture.minFilter));
            } else {
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
                _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
                if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture);
                }
                _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
                _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
                if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                    console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture);
                }
            }
            extension = extensions.get('EXT_texture_filter_anisotropic');
            if (extension) {
                if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null)
                    return;
                if (texture.type === HalfFloatType && extensions.get('OES_texture_half_float_linear') === null)
                    return;
                if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                    _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                    properties.get(texture).__currentAnisotropy = texture.anisotropy;
                }
            }
        }
        function uploadTexture(textureProperties, texture, slot) {
            if (textureProperties.__webglInit === undefined) {
                textureProperties.__webglInit = true;
                texture.addEventListener('dispose', onTextureDispose);
                textureProperties.__webglTexture = _gl.createTexture();
                info.memory.textures++;
            }
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
            var image = clampToMaxSize(texture.image, capabilities.maxTextureSize);
            if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
                image = makePowerOfTwo(image);
            }
            var isPowerOfTwoImage = isPowerOfTwo(image)
                , glFormat = utils.convert(texture.format)
                , glType = utils.convert(texture.type);
            setTextureParameters(_gl.TEXTURE_2D, texture, isPowerOfTwoImage);
            var mipmap, mipmaps = texture.mipmaps;
            if (texture.isDepthTexture) {
                var internalFormat = _gl.DEPTH_COMPONENT;
                if (texture.type === FloatType) {
                    if (!_isWebGL2)
                        throw new Error('Float Depth Texture only supported in WebGL2.0');
                    internalFormat = _gl.DEPTH_COMPONENT32F;
                } else if (_isWebGL2) {
                    internalFormat = _gl.DEPTH_COMPONENT16;
                }
                if (texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT) {
                    if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                        console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                        texture.type = UnsignedShortType;
                        glType = utils.convert(texture.type);
                    }
                }
                if (texture.format === DepthStencilFormat) {
                    internalFormat = _gl.DEPTH_STENCIL;
                    if (texture.type !== UnsignedInt248Type) {
                        console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                        texture.type = UnsignedInt248Type;
                        glType = utils.convert(texture.type);
                    }
                }
                state.texImage2D(_gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null);
            } else if (texture.isDataTexture) {
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                    texture.generateMipmaps = false;
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
                } else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
                    textureProperties.__maxMipLevel = 0;
                }
            } else if (texture.isCompressedTexture) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                        if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                            state.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        } else {
                            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                        }
                    } else {
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                if (mipmaps.length > 0 && isPowerOfTwoImage) {
                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                        mipmap = mipmaps[i];
                        state.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                    }
                    texture.generateMipmaps = false;
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
                } else {
                    state.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image);
                    textureProperties.__maxMipLevel = 0;
                }
            }
            if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
                generateMipmap(_gl.TEXTURE_2D, texture, image.width, image.height);
            }
            textureProperties.__version = texture.version;
            if (texture.onUpdate)
                texture.onUpdate(texture);
        }
        function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
            var glFormat = utils.convert(renderTarget.texture.format);
            var glType = utils.convert(renderTarget.texture.type);
            state.texImage2D(textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderBufferStorage(renderbuffer, renderTarget) {
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
            } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
            } else {
                _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
            }
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        }
        function setupDepthTexture(framebuffer, renderTarget) {
            var isCube = (renderTarget && renderTarget.isWebGLRenderTargetCube);
            if (isCube)
                throw new Error('Depth Texture with cube render targets is not supported');
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
                throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
            }
            if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
            }
            setTexture2D(renderTarget.depthTexture, 0);
            var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
            if (renderTarget.depthTexture.format === DepthFormat) {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
            } else {
                throw new Error('Unknown depthTexture format');
            }
        }
        function setupDepthRenderbuffer(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var isCube = (renderTarget.isWebGLRenderTargetCube === true);
            if (renderTarget.depthTexture) {
                if (isCube)
                    throw new Error('target.depthTexture not supported in Cube render targets');
                setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
            } else {
                if (isCube) {
                    renderTargetProperties.__webglDepthbuffer = [];
                    for (var i = 0; i < 6; i++) {
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                        renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
                    }
                } else {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                    renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
                }
            }
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        function setupRenderTarget(renderTarget) {
            var renderTargetProperties = properties.get(renderTarget);
            var textureProperties = properties.get(renderTarget.texture);
            renderTarget.addEventListener('dispose', onRenderTargetDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
            var isCube = (renderTarget.isWebGLRenderTargetCube === true);
            var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
            if (isCube) {
                renderTargetProperties.__webglFramebuffer = [];
                for (var i = 0; i < 6; i++) {
                    renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
                }
            } else {
                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            }
            if (isCube) {
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo);
                for (var i = 0; i < 6; i++) {
                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                }
                if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
                    generateMipmap(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height);
                }
                state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
            } else {
                state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
                setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
                if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
                    generateMipmap(_gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height);
                }
                state.bindTexture(_gl.TEXTURE_2D, null);
            }
            if (renderTarget.depthBuffer) {
                setupDepthRenderbuffer(renderTarget);
            }
        }
        function updateRenderTargetMipmap(renderTarget) {
            var texture = renderTarget.texture;
            var isTargetPowerOfTwo = isPowerOfTwo(renderTarget);
            if (textureNeedsGenerateMipmaps(texture, isTargetPowerOfTwo)) {
                var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                var webglTexture = properties.get(texture).__webglTexture;
                state.bindTexture(target, webglTexture);
                generateMipmap(target, texture, renderTarget.width, renderTarget.height);
                state.bindTexture(target, null);
            }
        }
        function updateVideoTexture(texture) {
            var id = texture.id;
            var frame = info.render.frame;
            if (_videoTextures[id] !== frame) {
                _videoTextures[id] = frame;
                texture.update();
            }
        }
        this.setTexture2D = setTexture2D;
        this.setTextureCube = setTextureCube;
        this.setTextureCubeDynamic = setTextureCubeDynamic;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    }
    function WebGLUtils(gl, extensions) {
        function convert(p) {
            var extension;
            if (p === RepeatWrapping)
                return gl.REPEAT;
            if (p === ClampToEdgeWrapping)
                return gl.CLAMP_TO_EDGE;
            if (p === MirroredRepeatWrapping)
                return gl.MIRRORED_REPEAT;
            if (p === NearestFilter)
                return gl.NEAREST;
            if (p === NearestMipMapNearestFilter)
                return gl.NEAREST_MIPMAP_NEAREST;
            if (p === NearestMipMapLinearFilter)
                return gl.NEAREST_MIPMAP_LINEAR;
            if (p === LinearFilter)
                return gl.LINEAR;
            if (p === LinearMipMapNearestFilter)
                return gl.LINEAR_MIPMAP_NEAREST;
            if (p === LinearMipMapLinearFilter)
                return gl.LINEAR_MIPMAP_LINEAR;
            if (p === UnsignedByteType)
                return gl.UNSIGNED_BYTE;
            if (p === UnsignedShort4444Type)
                return gl.UNSIGNED_SHORT_4_4_4_4;
            if (p === UnsignedShort5551Type)
                return gl.UNSIGNED_SHORT_5_5_5_1;
            if (p === UnsignedShort565Type)
                return gl.UNSIGNED_SHORT_5_6_5;
            if (p === ByteType)
                return gl.BYTE;
            if (p === ShortType)
                return gl.SHORT;
            if (p === UnsignedShortType)
                return gl.UNSIGNED_SHORT;
            if (p === IntType)
                return gl.INT;
            if (p === UnsignedIntType)
                return gl.UNSIGNED_INT;
            if (p === FloatType)
                return gl.FLOAT;
            if (p === HalfFloatType) {
                extension = extensions.get('OES_texture_half_float');
                if (extension !== null)
                    return extension.HALF_FLOAT_OES;
            }
            if (p === AlphaFormat)
                return gl.ALPHA;
            if (p === RGBFormat)
                return gl.RGB;
            if (p === RGBAFormat)
                return gl.RGBA;
            if (p === LuminanceFormat)
                return gl.LUMINANCE;
            if (p === LuminanceAlphaFormat)
                return gl.LUMINANCE_ALPHA;
            if (p === DepthFormat)
                return gl.DEPTH_COMPONENT;
            if (p === DepthStencilFormat)
                return gl.DEPTH_STENCIL;
            if (p === AddEquation)
                return gl.FUNC_ADD;
            if (p === SubtractEquation)
                return gl.FUNC_SUBTRACT;
            if (p === ReverseSubtractEquation)
                return gl.FUNC_REVERSE_SUBTRACT;
            if (p === ZeroFactor)
                return gl.ZERO;
            if (p === OneFactor)
                return gl.ONE;
            if (p === SrcColorFactor)
                return gl.SRC_COLOR;
            if (p === OneMinusSrcColorFactor)
                return gl.ONE_MINUS_SRC_COLOR;
            if (p === SrcAlphaFactor)
                return gl.SRC_ALPHA;
            if (p === OneMinusSrcAlphaFactor)
                return gl.ONE_MINUS_SRC_ALPHA;
            if (p === DstAlphaFactor)
                return gl.DST_ALPHA;
            if (p === OneMinusDstAlphaFactor)
                return gl.ONE_MINUS_DST_ALPHA;
            if (p === DstColorFactor)
                return gl.DST_COLOR;
            if (p === OneMinusDstColorFactor)
                return gl.ONE_MINUS_DST_COLOR;
            if (p === SrcAlphaSaturateFactor)
                return gl.SRC_ALPHA_SATURATE;
            if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                extension = extensions.get('WEBGL_compressed_texture_s3tc');
                if (extension !== null) {
                    if (p === RGB_S3TC_DXT1_Format)
                        return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT1_Format)
                        return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (p === RGBA_S3TC_DXT3_Format)
                        return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (p === RGBA_S3TC_DXT5_Format)
                        return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
            }
            if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                extension = extensions.get('WEBGL_compressed_texture_pvrtc');
                if (extension !== null) {
                    if (p === RGB_PVRTC_4BPPV1_Format)
                        return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (p === RGB_PVRTC_2BPPV1_Format)
                        return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (p === RGBA_PVRTC_4BPPV1_Format)
                        return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (p === RGBA_PVRTC_2BPPV1_Format)
                        return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                }
            }
            if (p === RGB_ETC1_Format) {
                extension = extensions.get('WEBGL_compressed_texture_etc1');
                if (extension !== null)
                    return extension.COMPRESSED_RGB_ETC1_WEBGL;
            }
            if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
                extension = extensions.get('WEBGL_compressed_texture_astc');
                if (extension !== null) {
                    return p;
                }
            }
            if (p === MinEquation || p === MaxEquation) {
                extension = extensions.get('EXT_blend_minmax');
                if (extension !== null) {
                    if (p === MinEquation)
                        return extension.MIN_EXT;
                    if (p === MaxEquation)
                        return extension.MAX_EXT;
                }
            }
            if (p === UnsignedInt248Type) {
                extension = extensions.get('WEBGL_depth_texture');
                if (extension !== null)
                    return extension.UNSIGNED_INT_24_8_WEBGL;
            }
            return 0;
        }
        return {
            convert: convert
        };
    }
    function PerspectiveCamera(fov, aspect, near, far) {
        Camera.call(this);
        this.type = 'PerspectiveCamera';
        this.fov = fov !== undefined ? fov : 50;
        this.zoom = 1;
        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;
        this.focus = 10;
        this.aspect = aspect !== undefined ? aspect : 1;
        this.view = null;
        this.filmGauge = 35;
        this.filmOffset = 0;
        this.updateProjectionMatrix();
    }
    PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
        constructor: PerspectiveCamera,
        isPerspectiveCamera: true,
        copy: function (source, recursive) {
            Camera.prototype.copy.call(this, source, recursive);
            this.fov = source.fov;
            this.zoom = source.zoom;
            this.near = source.near;
            this.far = source.far;
            this.focus = source.focus;
            this.aspect = source.aspect;
            this.view = source.view === null ? null : Object.assign({}, source.view);
            this.filmGauge = source.filmGauge;
            this.filmOffset = source.filmOffset;
            return this;
        },
        setFocalLength: function (focalLength) {
            var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
            this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
            this.updateProjectionMatrix();
        },
        getFocalLength: function () {
            var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
            return 0.5 * this.getFilmHeight() / vExtentSlope;
        },
        getEffectiveFOV: function () {
            return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
        },
        getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1);
        },
        getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1);
        },
        setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
            this.aspect = fullWidth / fullHeight;
            if (this.view === null) {
                this.view = {
                    enabled: true,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                };
            }
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
            this.updateProjectionMatrix();
        },
        clearViewOffset: function () {
            if (this.view !== null) {
                this.view.enabled = false;
            }
            this.updateProjectionMatrix();
        },
        updateProjectionMatrix: function () {
            var near = this.near
                , top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom
                , height = 2 * top
                , width = this.aspect * height
                , left = -0.5 * width
                , view = this.view;
            if (this.view !== null && this.view.enabled) {
                var fullWidth = view.fullWidth
                    , fullHeight = view.fullHeight;
                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
            }
            var skew = this.filmOffset;
            if (skew !== 0)
                left += near * skew / this.getFilmWidth();
            this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        },
        toJSON: function (meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.fov = this.fov;
            data.object.zoom = this.zoom;
            data.object.near = this.near;
            data.object.far = this.far;
            data.object.focus = this.focus;
            data.object.aspect = this.aspect;
            if (this.view !== null)
                data.object.view = Object.assign({}, this.view);
            data.object.filmGauge = this.filmGauge;
            data.object.filmOffset = this.filmOffset;
            return data;
        }
    });
    function ArrayCamera(array) {
        PerspectiveCamera.call(this);
        this.cameras = array || [];
    }
    ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
        constructor: ArrayCamera,
        isArrayCamera: true
    });
    function WebVRManager(renderer) {
        var scope = this;
        var device = null;
        var frameData = null;
        var poseTarget = null;
        var standingMatrix = new Matrix4();
        var standingMatrixInverse = new Matrix4();
        if (typeof window !== 'undefined' && 'VRFrameData' in window) {
            frameData = new window.VRFrameData();
            window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);
        }
        var matrixWorldInverse = new Matrix4();
        var tempQuaternion = new Quaternion();
        var tempPosition = new Vector3();
        var cameraL = new PerspectiveCamera();
        cameraL.bounds = new Vector4(0.0, 0.0, 0.5, 1.0);
        cameraL.layers.enable(1);
        var cameraR = new PerspectiveCamera();
        cameraR.bounds = new Vector4(0.5, 0.0, 0.5, 1.0);
        cameraR.layers.enable(2);
        var cameraVR = new ArrayCamera([cameraL, cameraR]);
        cameraVR.layers.enable(1);
        cameraVR.layers.enable(2);
        function isPresenting() {
            return device !== null && device.isPresenting === true;
        }
        var currentSize, currentPixelRatio;
        function onVRDisplayPresentChange() {
            if (isPresenting()) {
                var eyeParameters = device.getEyeParameters('left');
                var renderWidth = eyeParameters.renderWidth;
                var renderHeight = eyeParameters.renderHeight;
                currentPixelRatio = renderer.getPixelRatio();
                currentSize = renderer.getSize();
                renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);
                animation.start();
            } else if (scope.enabled) {
                renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
                animation.stop();
            }
        }
        this.enabled = false;
        this.userHeight = 1.6;
        this.getDevice = function () {
            return device;
        }
            ;
        this.setDevice = function (value) {
            if (value !== undefined)
                device = value;
            animation.setContext(value);
        }
            ;
        this.setPoseTarget = function (object) {
            if (object !== undefined)
                poseTarget = object;
        }
            ;
        this.getCamera = function (camera) {
            if (device === null)
                return camera;
            device.depthNear = camera.near;
            device.depthFar = camera.far;
            device.getFrameData(frameData);
            var stageParameters = device.stageParameters;
            if (stageParameters) {
                standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
            } else {
                standingMatrix.makeTranslation(0, scope.userHeight, 0);
            }
            var pose = frameData.pose;
            var poseObject = poseTarget !== null ? poseTarget : camera;
            poseObject.matrix.copy(standingMatrix);
            poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);
            if (pose.orientation !== null) {
                tempQuaternion.fromArray(pose.orientation);
                poseObject.quaternion.multiply(tempQuaternion);
            }
            if (pose.position !== null) {
                tempQuaternion.setFromRotationMatrix(standingMatrix);
                tempPosition.fromArray(pose.position);
                tempPosition.applyQuaternion(tempQuaternion);
                poseObject.position.add(tempPosition);
            }
            poseObject.updateMatrixWorld();
            if (device.isPresenting === false)
                return camera;
            cameraL.near = camera.near;
            cameraR.near = camera.near;
            cameraL.far = camera.far;
            cameraR.far = camera.far;
            cameraVR.matrixWorld.copy(camera.matrixWorld);
            cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse);
            cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
            cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);
            standingMatrixInverse.getInverse(standingMatrix);
            cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
            cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
            var parent = poseObject.parent;
            if (parent !== null) {
                matrixWorldInverse.getInverse(parent.matrixWorld);
                cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
                cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
            }
            cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
            cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
            cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
            cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);
            cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
            var layers = device.getLayers();
            if (layers.length) {
                var layer = layers[0];
                if (layer.leftBounds !== null && layer.leftBounds.length === 4) {
                    cameraL.bounds.fromArray(layer.leftBounds);
                }
                if (layer.rightBounds !== null && layer.rightBounds.length === 4) {
                    cameraR.bounds.fromArray(layer.rightBounds);
                }
            }
            return cameraVR;
        }
            ;
        this.getStandingMatrix = function () {
            return standingMatrix;
        }
            ;
        this.isPresenting = isPresenting;
        var animation = new WebGLAnimation();
        this.setAnimationLoop = function (callback) {
            animation.setAnimationLoop(callback);
        }
            ;
        this.submitFrame = function () {
            if (isPresenting())
                device.submitFrame();
        }
            ;
        this.dispose = function () {
            if (typeof window !== 'undefined') {
                window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);
            }
        }
            ;
    }
    function WebXRManager(renderer) {
        var gl = renderer.context;
        var device = null;
        var session = null;
        var frameOfRef = null;
        var pose = null;
        function isPresenting() {
            return session !== null && frameOfRef !== null;
        }
        var cameraL = new PerspectiveCamera();
        cameraL.layers.enable(1);
        cameraL.viewport = new Vector4();
        var cameraR = new PerspectiveCamera();
        cameraR.layers.enable(2);
        cameraR.viewport = new Vector4();
        var cameraVR = new ArrayCamera([cameraL, cameraR]);
        cameraVR.layers.enable(1);
        cameraVR.layers.enable(2);
        this.enabled = false;
        this.getDevice = function () {
            return device;
        }
            ;
        this.setDevice = function (value) {
            if (value !== undefined)
                device = value;
            gl.setCompatibleXRDevice(value);
        }
            ;
        this.setSession = function (value, options) {
            session = value;
            if (session !== null) {
                session.addEventListener('end', function () {
                    renderer.setFramebuffer(null);
                    animation.stop();
                });
                session.baseLayer = new XRWebGLLayer(session, gl);
                session.requestFrameOfReference(options.frameOfReferenceType).then(function (value) {
                    frameOfRef = value;
                    renderer.setFramebuffer(session.baseLayer.framebuffer);
                    animation.setContext(session);
                    animation.start();
                });
            }
        }
            ;
        function updateCamera(camera, parent) {
            if (parent === null) {
                camera.matrixWorld.copy(camera.matrix);
            } else {
                camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            }
            camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        }
        this.getCamera = function (camera) {
            if (isPresenting()) {
                var parent = camera.parent;
                var cameras = cameraVR.cameras;
                updateCamera(cameraVR, parent);
                for (var i = 0; i < cameras.length; i++) {
                    updateCamera(cameras[i], parent);
                }
                camera.matrixWorld.copy(cameraVR.matrixWorld);
                var children = camera.children;
                for (var i = 0, l = children.length; i < l; i++) {
                    children[i].updateMatrixWorld(true);
                }
                return cameraVR;
            }
            return camera;
        }
            ;
        this.isPresenting = isPresenting;
        var onAnimationFrameCallback = null;
        function onAnimationFrame(time, frame) {
            pose = frame.getDevicePose(frameOfRef);
            var layer = session.baseLayer;
            var views = frame.views;
            for (var i = 0; i < views.length; i++) {
                var view = views[i];
                var viewport = layer.getViewport(view);
                var viewMatrix = pose.getViewMatrix(view);
                var camera = cameraVR.cameras[i];
                camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i === 0) {
                    cameraVR.matrix.copy(camera.matrix);
                    cameraVR.projectionMatrix.copy(camera.projectionMatrix);
                }
            }
            if (onAnimationFrameCallback)
                onAnimationFrameCallback();
        }
        var animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        this.setAnimationLoop = function (callback) {
            onAnimationFrameCallback = callback;
        }
            ;
        this.getStandingMatrix = function () {
            console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.');
            return new THREE.Matrix4();
        }
            ;
        this.submitFrame = function () { }
            ;
    }
    function WebGLRenderer(parameters) {
        console.log('THREE.WebGLRenderer', REVISION);
        parameters = parameters || {};
        var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas')
            , _context = parameters.context !== undefined ? parameters.context : null
            , _alpha = parameters.alpha !== undefined ? parameters.alpha : false
            , _depth = parameters.depth !== undefined ? parameters.depth : true
            , _stencil = parameters.stencil !== undefined ? parameters.stencil : true
            , _antialias = parameters.antialias !== undefined ? parameters.antialias : false
            , _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true
            , _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false
            , _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';
        var currentRenderList = null;
        var currentRenderState = null;
        this.domElement = _canvas;
        this.context = null;
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        this.sortObjects = true;
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        this.gammaFactor = 2.0;
        this.gammaInput = false;
        this.gammaOutput = false;
        this.physicallyCorrectLights = false;
        this.toneMapping = LinearToneMapping;
        this.toneMappingExposure = 1.0;
        this.toneMappingWhitePoint = 1.0;
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;
        var _this = this
            , _isContextLost = false
            , _framebuffer = null
            , _currentRenderTarget = null
            , _currentFramebuffer = null
            , _currentMaterialId = -1
            , _currentGeometryProgram = ''
            , _currentCamera = null
            , _currentArrayCamera = null
            , _currentViewport = new Vector4()
            , _currentScissor = new Vector4()
            , _currentScissorTest = null
            , _usedTextureUnits = 0
            , _width = _canvas.width
            , _height = _canvas.height
            , _pixelRatio = 1
            , _viewport = new Vector4(0, 0, _width, _height)
            , _scissor = new Vector4(0, 0, _width, _height)
            , _scissorTest = false
            , _frustum = new Frustum()
            , _clipping = new WebGLClipping()
            , _clippingEnabled = false
            , _localClippingEnabled = false
            , _projScreenMatrix = new Matrix4()
            , _vector3 = new Vector3();
        function getTargetPixelRatio() {
            return _currentRenderTarget === null ? _pixelRatio : 1;
        }
        var _gl;
        try {
            var contextAttributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer,
                powerPreference: _powerPreference
            };
            _canvas.addEventListener('webglcontextlost', onContextLost, false);
            _canvas.addEventListener('webglcontextrestored', onContextRestore, false);
            _gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);
            if (_gl === null) {
                if (_canvas.getContext('webgl') !== null) {
                    throw new Error('Error creating WebGL context with your selected attributes.');
                } else {
                    throw new Error('Error creating WebGL context.');
                }
            }
            if (_gl.getShaderPrecisionFormat === undefined) {
                _gl.getShaderPrecisionFormat = function () {
                    return {
                        'rangeMin': 1,
                        'rangeMax': 1,
                        'precision': 1
                    };
                }
                    ;
            }
        } catch (error) {
            console.error('THREE.WebGLRenderer: ' + error.message);
        }
        var extensions, capabilities, state, info;
        var properties, textures, attributes, geometries, objects;
        var programCache, renderLists, renderStates;
        var background, morphtargets, bufferRenderer, indexedBufferRenderer;
        var spriteRenderer;
        var utils;
        function initGLContext() {
            extensions = new WebGLExtensions(_gl);
            extensions.get('WEBGL_depth_texture');
            extensions.get('OES_texture_float');
            extensions.get('OES_texture_float_linear');
            extensions.get('OES_texture_half_float');
            extensions.get('OES_texture_half_float_linear');
            extensions.get('OES_standard_derivatives');
            extensions.get('OES_element_index_uint');
            extensions.get('ANGLE_instanced_arrays');
            utils = new WebGLUtils(_gl, extensions);
            capabilities = new WebGLCapabilities(_gl, extensions, parameters);
            state = new WebGLState(_gl, extensions, utils);
            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
            info = new WebGLInfo(_gl);
            properties = new WebGLProperties();
            textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
            attributes = new WebGLAttributes(_gl);
            geometries = new WebGLGeometries(_gl, attributes, info);
            objects = new WebGLObjects(geometries, info);
            morphtargets = new WebGLMorphtargets(_gl);
            programCache = new WebGLPrograms(_this, extensions, capabilities);
            renderLists = new WebGLRenderLists();
            renderStates = new WebGLRenderStates();
            background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
            bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
            indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
            spriteRenderer = new WebGLSpriteRenderer(_this, _gl, state, textures, capabilities);
            info.programs = programCache.programs;
            _this.context = _gl;
            _this.capabilities = capabilities;
            _this.extensions = extensions;
            _this.properties = properties;
            _this.renderLists = renderLists;
            _this.state = state;
            _this.info = info;
        }
        initGLContext();
        var vr = ('xr' in navigator) ? new WebXRManager(_this) : new WebVRManager(_this);
        this.vr = vr;
        var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
        this.shadowMap = shadowMap;
        this.getContext = function () {
            return _gl;
        }
            ;
        this.getContextAttributes = function () {
            return _gl.getContextAttributes();
        }
            ;
        this.forceContextLoss = function () {
            var extension = extensions.get('WEBGL_lose_context');
            if (extension)
                extension.loseContext();
        }
            ;
        this.forceContextRestore = function () {
            var extension = extensions.get('WEBGL_lose_context');
            if (extension)
                extension.restoreContext();
        }
            ;
        this.getPixelRatio = function () {
            return _pixelRatio;
        }
            ;
        this.setPixelRatio = function (value) {
            if (value === undefined)
                return;
            _pixelRatio = value;
            this.setSize(_width, _height, false);
        }
            ;
        this.getSize = function () {
            return {
                width: _width,
                height: _height
            };
        }
            ;
        this.setSize = function (width, height, updateStyle) {
            if (vr.isPresenting()) {
                console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
                return;
            }
            _width = width;
            _height = height;
            _canvas.width = width * _pixelRatio;
            _canvas.height = height * _pixelRatio;
            if (updateStyle !== false) {
                _canvas.style.width = width + 'px';
                _canvas.style.height = height + 'px';
            }
            this.setViewport(0, 0, width, height);
        }
            ;
        this.getDrawingBufferSize = function () {
            return {
                width: _width * _pixelRatio,
                height: _height * _pixelRatio
            };
        }
            ;
        this.setDrawingBufferSize = function (width, height, pixelRatio) {
            _width = width;
            _height = height;
            _pixelRatio = pixelRatio;
            _canvas.width = width * pixelRatio;
            _canvas.height = height * pixelRatio;
            this.setViewport(0, 0, width, height);
        }
            ;
        this.getCurrentViewport = function () {
            return _currentViewport;
        }
            ;
        this.setViewport = function (x, y, width, height) {
            _viewport.set(x, _height - y - height, width, height);
            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
        }
            ;
        this.setScissor = function (x, y, width, height) {
            _scissor.set(x, _height - y - height, width, height);
            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
        }
            ;
        this.setScissorTest = function (boolean) {
            state.setScissorTest(_scissorTest = boolean);
        }
            ;
        this.getClearColor = function () {
            return background.getClearColor();
        }
            ;
        this.setClearColor = function () {
            background.setClearColor.apply(background, arguments);
        }
            ;
        this.getClearAlpha = function () {
            return background.getClearAlpha();
        }
            ;
        this.setClearAlpha = function () {
            background.setClearAlpha.apply(background, arguments);
        }
            ;
        this.clear = function (color, depth, stencil) {
            var bits = 0;
            if (color === undefined || color)
                bits |= _gl.COLOR_BUFFER_BIT;
            if (depth === undefined || depth)
                bits |= _gl.DEPTH_BUFFER_BIT;
            if (stencil === undefined || stencil)
                bits |= _gl.STENCIL_BUFFER_BIT;
            _gl.clear(bits);
        }
            ;
        this.clearColor = function () {
            this.clear(true, false, false);
        }
            ;
        this.clearDepth = function () {
            this.clear(false, true, false);
        }
            ;
        this.clearStencil = function () {
            this.clear(false, false, true);
        }
            ;
        this.clearTarget = function (renderTarget, color, depth, stencil) {
            this.setRenderTarget(renderTarget);
            this.clear(color, depth, stencil);
        }
            ;
        this.dispose = function () {
            _canvas.removeEventListener('webglcontextlost', onContextLost, false);
            _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
            renderLists.dispose();
            renderStates.dispose();
            properties.dispose();
            objects.dispose();
            vr.dispose();
            animation.stop();
        }
            ;
        function onContextLost(event) {
            event.preventDefault();
            console.log('THREE.WebGLRenderer: Context Lost.');
            _isContextLost = true;
        }
        function onContextRestore() {
            console.log('THREE.WebGLRenderer: Context Restored.');
            _isContextLost = false;
            initGLContext();
        }
        function onMaterialDispose(event) {
            var material = event.target;
            material.removeEventListener('dispose', onMaterialDispose);
            deallocateMaterial(material);
        }
        function deallocateMaterial(material) {
            releaseMaterialProgramReference(material);
            properties.remove(material);
        }
        function releaseMaterialProgramReference(material) {
            var programInfo = properties.get(material).program;
            material.program = undefined;
            if (programInfo !== undefined) {
                programCache.releaseProgram(programInfo);
            }
        }
        function renderObjectImmediate(object, program, material) {
            object.render(function (object) {
                _this.renderBufferImmediate(object, program, material);
            });
        }
        this.renderBufferImmediate = function (object, program, material) {
            state.initAttributes();
            var buffers = properties.get(object);
            if (object.hasPositions && !buffers.position)
                buffers.position = _gl.createBuffer();
            if (object.hasNormals && !buffers.normal)
                buffers.normal = _gl.createBuffer();
            if (object.hasUvs && !buffers.uv)
                buffers.uv = _gl.createBuffer();
            if (object.hasColors && !buffers.color)
                buffers.color = _gl.createBuffer();
            var programAttributes = program.getAttributes();
            if (object.hasPositions) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(programAttributes.position);
                _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasNormals) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
                if (!material.isMeshPhongMaterial && !material.isMeshStandardMaterial && !material.isMeshNormalMaterial && material.flatShading === true) {
                    for (var i = 0, l = object.count * 3; i < l; i += 9) {
                        var array = object.normalArray;
                        var nx = (array[i + 0] + array[i + 3] + array[i + 6]) / 3;
                        var ny = (array[i + 1] + array[i + 4] + array[i + 7]) / 3;
                        var nz = (array[i + 2] + array[i + 5] + array[i + 8]) / 3;
                        array[i + 0] = nx;
                        array[i + 1] = ny;
                        array[i + 2] = nz;
                        array[i + 3] = nx;
                        array[i + 4] = ny;
                        array[i + 5] = nz;
                        array[i + 6] = nx;
                        array[i + 7] = ny;
                        array[i + 8] = nz;
                    }
                }
                _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(programAttributes.normal);
                _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasUvs && material.map) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(programAttributes.uv);
                _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
            }
            if (object.hasColors && material.vertexColors !== NoColors) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
                _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
                state.enableAttribute(programAttributes.color);
                _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
            }
            state.disableUnusedAttributes();
            _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
            object.count = 0;
        }
            ;
        this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
            var frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
            state.setMaterial(material, frontFaceCW);
            var program = setProgram(camera, fog, material, object);
            var geometryProgram = geometry.id + '_' + program.id + '_' + (material.wireframe === true);
            var updateBuffers = false;
            if (geometryProgram !== _currentGeometryProgram) {
                _currentGeometryProgram = geometryProgram;
                updateBuffers = true;
            }
            if (object.morphTargetInfluences) {
                morphtargets.update(object, geometry, material, program);
                updateBuffers = true;
            }
            var index = geometry.index;
            var position = geometry.attributes.position;
            var rangeFactor = 1;
            if (material.wireframe === true) {
                index = geometries.getWireframeAttribute(geometry);
                rangeFactor = 2;
            }
            var attribute;
            var renderer = bufferRenderer;
            if (index !== null) {
                attribute = attributes.get(index);
                renderer = indexedBufferRenderer;
                renderer.setIndex(attribute);
            }
            if (updateBuffers) {
                setupVertexAttributes(material, program, geometry);
                if (index !== null) {
                    _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, attribute.buffer);
                }
            }
            var dataCount = Infinity;
            if (index !== null) {
                dataCount = index.count;
            } else if (position !== undefined) {
                dataCount = position.count;
            }
            var rangeStart = geometry.drawRange.start * rangeFactor;
            var rangeCount = geometry.drawRange.count * rangeFactor;
            var groupStart = group !== null ? group.start * rangeFactor : 0;
            var groupCount = group !== null ? group.count * rangeFactor : Infinity;
            var drawStart = Math.max(rangeStart, groupStart);
            var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
            var drawCount = Math.max(0, drawEnd - drawStart + 1);
            if (drawCount === 0)
                return;
            if (object.isMesh) {
                if (material.wireframe === true) {
                    state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                    renderer.setMode(_gl.LINES);
                } else {
                    switch (object.drawMode) {
                        case TrianglesDrawMode:
                            renderer.setMode(_gl.TRIANGLES);
                            break;
                        case TriangleStripDrawMode:
                            renderer.setMode(_gl.TRIANGLE_STRIP);
                            break;
                        case TriangleFanDrawMode:
                            renderer.setMode(_gl.TRIANGLE_FAN);
                            break;
                    }
                }
            } else if (object.isLine) {
                var lineWidth = material.linewidth;
                if (lineWidth === undefined)
                    lineWidth = 1;
                state.setLineWidth(lineWidth * getTargetPixelRatio());
                if (object.isLineSegments) {
                    renderer.setMode(_gl.LINES);
                } else if (object.isLineLoop) {
                    renderer.setMode(_gl.LINE_LOOP);
                } else {
                    renderer.setMode(_gl.LINE_STRIP);
                }
            } else if (object.isPoints) {
                renderer.setMode(_gl.POINTS);
            }
            if (geometry && geometry.isInstancedBufferGeometry) {
                if (geometry.maxInstancedCount > 0) {
                    renderer.renderInstances(geometry, drawStart, drawCount);
                }
            } else {
                renderer.render(drawStart, drawCount);
            }
        }
            ;
        function setupVertexAttributes(material, program, geometry) {
            if (geometry && geometry.isInstancedBufferGeometry) {
                if (extensions.get('ANGLE_instanced_arrays') === null) {
                    console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                    return;
                }
            }
            state.initAttributes();
            var geometryAttributes = geometry.attributes;
            var programAttributes = program.getAttributes();
            var materialDefaultAttributeValues = material.defaultAttributeValues;
            for (var name in programAttributes) {
                var programAttribute = programAttributes[name];
                if (programAttribute >= 0) {
                    var geometryAttribute = geometryAttributes[name];
                    if (geometryAttribute !== undefined) {
                        var normalized = geometryAttribute.normalized;
                        var size = geometryAttribute.itemSize;
                        var attribute = attributes.get(geometryAttribute);
                        if (attribute === undefined)
                            continue;
                        var buffer = attribute.buffer;
                        var type = attribute.type;
                        var bytesPerElement = attribute.bytesPerElement;
                        if (geometryAttribute.isInterleavedBufferAttribute) {
                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;
                            if (data && data.isInstancedInterleavedBuffer) {
                                state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
                                }
                            } else {
                                state.enableAttribute(programAttribute);
                            }
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                        } else {
                            if (geometryAttribute.isInstancedBufferAttribute) {
                                state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                                if (geometry.maxInstancedCount === undefined) {
                                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                }
                            } else {
                                state.enableAttribute(programAttribute);
                            }
                            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
                            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                        }
                    } else if (materialDefaultAttributeValues !== undefined) {
                        var value = materialDefaultAttributeValues[name];
                        if (value !== undefined) {
                            switch (value.length) {
                                case 2:
                                    _gl.vertexAttrib2fv(programAttribute, value);
                                    break;
                                case 3:
                                    _gl.vertexAttrib3fv(programAttribute, value);
                                    break;
                                case 4:
                                    _gl.vertexAttrib4fv(programAttribute, value);
                                    break;
                                default:
                                    _gl.vertexAttrib1fv(programAttribute, value);
                            }
                        }
                    }
                }
            }
            state.disableUnusedAttributes();
        }
        this.compile = function (scene, camera) {
            currentRenderState = renderStates.get(scene, camera);
            currentRenderState.init();
            scene.traverse(function (object) {
                if (object.isLight) {
                    currentRenderState.pushLight(object);
                    if (object.castShadow) {
                        currentRenderState.pushShadow(object);
                    }
                }
            });
            currentRenderState.setupLights(camera);
            scene.traverse(function (object) {
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        for (var i = 0; i < object.material.length; i++) {
                            initMaterial(object.material[i], scene.fog, object);
                        }
                    } else {
                        initMaterial(object.material, scene.fog, object);
                    }
                }
            });
        }
            ;
        var onAnimationFrameCallback = null;
        function onAnimationFrame() {
            if (vr.isPresenting())
                return;
            if (onAnimationFrameCallback)
                onAnimationFrameCallback();
        }
        var animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        animation.setContext(window);
        this.setAnimationLoop = function (callback) {
            onAnimationFrameCallback = callback;
            vr.setAnimationLoop(callback);
            animation.start();
        }
            ;
        this.render = function (scene, camera, renderTarget, forceClear) {
            if (!(camera && camera.isCamera)) {
                console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                return;
            }
            if (_isContextLost)
                return;
            _currentGeometryProgram = '';
            _currentMaterialId = -1;
            _currentCamera = null;
            if (scene.autoUpdate === true)
                scene.updateMatrixWorld();
            if (camera.parent === null)
                camera.updateMatrixWorld();
            if (vr.enabled) {
                camera = vr.getCamera(camera);
            }
            currentRenderState = renderStates.get(scene, camera);
            currentRenderState.init();
            scene.onBeforeRender(_this, scene, camera, renderTarget);
            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            _frustum.setFromMatrix(_projScreenMatrix);
            _localClippingEnabled = this.localClippingEnabled;
            _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
            currentRenderList = renderLists.get(scene, camera);
            currentRenderList.init();
            projectObject(scene, camera, _this.sortObjects);
            if (_this.sortObjects === true) {
                currentRenderList.sort();
            }
            if (_clippingEnabled)
                _clipping.beginShadows();
            var shadowsArray = currentRenderState.state.shadowsArray;
            shadowMap.render(shadowsArray, scene, camera);
            currentRenderState.setupLights(camera);
            if (_clippingEnabled)
                _clipping.endShadows();
            if (this.info.autoReset)
                this.info.reset();
            if (renderTarget === undefined) {
                renderTarget = null;
            }
            this.setRenderTarget(renderTarget);
            background.render(currentRenderList, scene, camera, forceClear);
            var opaqueObjects = currentRenderList.opaque;
            var transparentObjects = currentRenderList.transparent;
            if (scene.overrideMaterial) {
                var overrideMaterial = scene.overrideMaterial;
                if (opaqueObjects.length)
                    renderObjects(opaqueObjects, scene, camera, overrideMaterial);
                if (transparentObjects.length)
                    renderObjects(transparentObjects, scene, camera, overrideMaterial);
            } else {
                if (opaqueObjects.length)
                    renderObjects(opaqueObjects, scene, camera);
                if (transparentObjects.length)
                    renderObjects(transparentObjects, scene, camera);
            }
            var spritesArray = currentRenderState.state.spritesArray;
            spriteRenderer.render(spritesArray, scene, camera);
            if (renderTarget) {
                textures.updateRenderTargetMipmap(renderTarget);
            }
            state.buffers.depth.setTest(true);
            state.buffers.depth.setMask(true);
            state.buffers.color.setMask(true);
            state.setPolygonOffset(false);
            scene.onAfterRender(_this, scene, camera);
            if (vr.enabled) {
                vr.submitFrame();
            }
            currentRenderList = null;
            currentRenderState = null;
        }
            ;
        function projectObject(object, camera, sortObjects) {
            if (object.visible === false)
                return;
            var visible = object.layers.test(camera.layers);
            if (visible) {
                if (object.isLight) {
                    currentRenderState.pushLight(object);
                    if (object.castShadow) {
                        currentRenderState.pushShadow(object);
                    }
                } else if (object.isSprite) {
                    if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                        currentRenderState.pushSprite(object);
                    }
                } else if (object.isImmediateRenderObject) {
                    if (sortObjects) {
                        _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    }
                    currentRenderList.push(object, null, object.material, _vector3.z, null);
                } else if (object.isMesh || object.isLine || object.isPoints) {
                    if (object.isSkinnedMesh) {
                        object.skeleton.update();
                    }
                    if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                        if (sortObjects) {
                            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                        }
                        var geometry = objects.update(object);
                        var material = object.material;
                        if (Array.isArray(material)) {
                            var groups = geometry.groups;
                            for (var i = 0, l = groups.length; i < l; i++) {
                                var group = groups[i];
                                var groupMaterial = material[group.materialIndex];
                                if (groupMaterial && groupMaterial.visible) {
                                    currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group);
                                }
                            }
                        } else if (material.visible) {
                            currentRenderList.push(object, geometry, material, _vector3.z, null);
                        }
                    }
                }
            }
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                projectObject(children[i], camera, sortObjects);
            }
        }
        function renderObjects(renderList, scene, camera, overrideMaterial) {
            for (var i = 0, l = renderList.length; i < l; i++) {
                var renderItem = renderList[i];
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
                if (camera.isArrayCamera) {
                    _currentArrayCamera = camera;
                    var cameras = camera.cameras;
                    for (var j = 0, jl = cameras.length; j < jl; j++) {
                        var camera2 = cameras[j];
                        if (object.layers.test(camera2.layers)) {
                            if ('viewport' in camera2) {
                                state.viewport(_currentViewport.copy(camera2.viewport));
                            } else {
                                var bounds = camera2.bounds;
                                var x = bounds.x * _width;
                                var y = bounds.y * _height;
                                var width = bounds.z * _width;
                                var height = bounds.w * _height;
                                state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio));
                            }
                            renderObject(object, scene, camera2, geometry, material, group);
                        }
                    }
                } else {
                    _currentArrayCamera = null;
                    renderObject(object, scene, camera, geometry, material, group);
                }
            }
        }
        function renderObject(object, scene, camera, geometry, material, group) {
            object.onBeforeRender(_this, scene, camera, geometry, material, group);
            currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
            if (object.isImmediateRenderObject) {
                var frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
                state.setMaterial(material, frontFaceCW);
                var program = setProgram(camera, scene.fog, material, object);
                _currentGeometryProgram = '';
                renderObjectImmediate(object, program, material);
            } else {
                _this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
            }
            object.onAfterRender(_this, scene, camera, geometry, material, group);
            currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
        }
        function initMaterial(material, fog, object) {
            var materialProperties = properties.get(material);
            var lights = currentRenderState.state.lights;
            var shadowsArray = currentRenderState.state.shadowsArray;
            var parameters = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);
            var code = programCache.getProgramCode(material, parameters);
            var program = materialProperties.program;
            var programChange = true;
            if (program === undefined) {
                material.addEventListener('dispose', onMaterialDispose);
            } else if (program.code !== code) {
                releaseMaterialProgramReference(material);
            } else if (materialProperties.lightsHash !== lights.state.hash) {
                properties.update(material, 'lightsHash', lights.state.hash);
                programChange = false;
            } else if (parameters.shaderID !== undefined) {
                return;
            } else {
                programChange = false;
            }
            if (programChange) {
                if (parameters.shaderID) {
                    var shader = ShaderLib[parameters.shaderID];
                    materialProperties.shader = {
                        name: material.type,
                        uniforms: UniformsUtils.clone(shader.uniforms),
                        vertexShader: shader.vertexShader,
                        fragmentShader: shader.fragmentShader
                    };
                } else {
                    materialProperties.shader = {
                        name: material.type,
                        uniforms: material.uniforms,
                        vertexShader: material.vertexShader,
                        fragmentShader: material.fragmentShader
                    };
                }
                material.onBeforeCompile(materialProperties.shader, _this);
                program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);
                materialProperties.program = program;
                material.program = program;
            }
            var programAttributes = program.getAttributes();
            if (material.morphTargets) {
                material.numSupportedMorphTargets = 0;
                for (var i = 0; i < _this.maxMorphTargets; i++) {
                    if (programAttributes['morphTarget' + i] >= 0) {
                        material.numSupportedMorphTargets++;
                    }
                }
            }
            if (material.morphNormals) {
                material.numSupportedMorphNormals = 0;
                for (var i = 0; i < _this.maxMorphNormals; i++) {
                    if (programAttributes['morphNormal' + i] >= 0) {
                        material.numSupportedMorphNormals++;
                    }
                }
            }
            var uniforms = materialProperties.shader.uniforms;
            if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
                materialProperties.numClippingPlanes = _clipping.numPlanes;
                materialProperties.numIntersection = _clipping.numIntersection;
                uniforms.clippingPlanes = _clipping.uniform;
            }
            materialProperties.fog = fog;
            materialProperties.lightsHash = lights.state.hash;
            if (material.lights) {
                uniforms.ambientLightColor.value = lights.state.ambient;
                uniforms.directionalLights.value = lights.state.directional;
                uniforms.spotLights.value = lights.state.spot;
                uniforms.rectAreaLights.value = lights.state.rectArea;
                uniforms.pointLights.value = lights.state.point;
                uniforms.hemisphereLights.value = lights.state.hemi;
                uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
            }
            var progUniforms = materialProperties.program.getUniforms()
                , uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
            materialProperties.uniformsList = uniformsList;
        }
        function setProgram(camera, fog, material, object) {
            _usedTextureUnits = 0;
            var materialProperties = properties.get(material);
            var lights = currentRenderState.state.lights;
            if (_clippingEnabled) {
                if (_localClippingEnabled || camera !== _currentCamera) {
                    var useCache = camera === _currentCamera && material.id === _currentMaterialId;
                    _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
                }
            }
            if (material.needsUpdate === false) {
                if (materialProperties.program === undefined) {
                    material.needsUpdate = true;
                } else if (material.fog && materialProperties.fog !== fog) {
                    material.needsUpdate = true;
                } else if (material.lights && materialProperties.lightsHash !== lights.state.hash) {
                    material.needsUpdate = true;
                } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
                    material.needsUpdate = true;
                }
            }
            if (material.needsUpdate) {
                initMaterial(material, fog, object);
                material.needsUpdate = false;
            }
            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;
            var program = materialProperties.program
                , p_uniforms = program.getUniforms()
                , m_uniforms = materialProperties.shader.uniforms;
            if (state.useProgram(program.program)) {
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
            }
            if (material.id !== _currentMaterialId) {
                _currentMaterialId = material.id;
                refreshMaterial = true;
            }
            if (refreshProgram || camera !== _currentCamera) {
                p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
                if (capabilities.logarithmicDepthBuffer) {
                    p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
                }
                if (_currentCamera !== (_currentArrayCamera || camera)) {
                    _currentCamera = (_currentArrayCamera || camera);
                    refreshMaterial = true;
                    refreshLights = true;
                }
                if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
                    var uCamPos = p_uniforms.map.cameraPosition;
                    if (uCamPos !== undefined) {
                        uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                    }
                }
                if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
                    p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
                }
            }
            if (material.skinning) {
                p_uniforms.setOptional(_gl, object, 'bindMatrix');
                p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
                var skeleton = object.skeleton;
                if (skeleton) {
                    var bones = skeleton.bones;
                    if (capabilities.floatVertexTextures) {
                        if (skeleton.boneTexture === undefined) {
                            var size = Math.sqrt(bones.length * 4);
                            size = _Math.ceilPowerOfTwo(size);
                            size = Math.max(size, 4);
                            var boneMatrices = new Float32Array(size * size * 4);
                            boneMatrices.set(skeleton.boneMatrices);
                            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                            boneTexture.needsUpdate = true;
                            skeleton.boneMatrices = boneMatrices;
                            skeleton.boneTexture = boneTexture;
                            skeleton.boneTextureSize = size;
                        }
                        p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture);
                        p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                    } else {
                        p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                    }
                }
            }
            if (refreshMaterial) {
                p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);
                if (material.lights) {
                    markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                }
                if (fog && material.fog) {
                    refreshUniformsFog(m_uniforms, fog);
                }
                if (material.isMeshBasicMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                } else if (material.isMeshLambertMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsLambert(m_uniforms, material);
                } else if (material.isMeshPhongMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    if (material.isMeshToonMaterial) {
                        refreshUniformsToon(m_uniforms, material);
                    } else {
                        refreshUniformsPhong(m_uniforms, material);
                    }
                } else if (material.isMeshStandardMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    if (material.isMeshPhysicalMaterial) {
                        refreshUniformsPhysical(m_uniforms, material);
                    } else {
                        refreshUniformsStandard(m_uniforms, material);
                    }
                } else if (material.isMeshDepthMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsDepth(m_uniforms, material);
                } else if (material.isMeshDistanceMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsDistance(m_uniforms, material);
                } else if (material.isMeshNormalMaterial) {
                    refreshUniformsCommon(m_uniforms, material);
                    refreshUniformsNormal(m_uniforms, material);
                } else if (material.isLineBasicMaterial) {
                    refreshUniformsLine(m_uniforms, material);
                    if (material.isLineDashedMaterial) {
                        refreshUniformsDash(m_uniforms, material);
                    }
                } else if (material.isPointsMaterial) {
                    refreshUniformsPoints(m_uniforms, material);
                } else if (material.isShadowMaterial) {
                    m_uniforms.color.value = material.color;
                    m_uniforms.opacity.value = material.opacity;
                }
                if (m_uniforms.ltc_1 !== undefined)
                    m_uniforms.ltc_1.value = UniformsLib.LTC_1;
                if (m_uniforms.ltc_2 !== undefined)
                    m_uniforms.ltc_2.value = UniformsLib.LTC_2;
                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
            }
            if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
                WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
                material.uniformsNeedUpdate = false;
            }
            p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
            p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
            p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
            return program;
        }
        function refreshUniformsCommon(uniforms, material) {
            uniforms.opacity.value = material.opacity;
            if (material.color) {
                uniforms.diffuse.value = material.color;
            }
            if (material.emissive) {
                uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
            }
            if (material.map) {
                uniforms.map.value = material.map;
            }
            if (material.alphaMap) {
                uniforms.alphaMap.value = material.alphaMap;
            }
            if (material.specularMap) {
                uniforms.specularMap.value = material.specularMap;
            }
            if (material.envMap) {
                uniforms.envMap.value = material.envMap;
                uniforms.flipEnvMap.value = (!(material.envMap && material.envMap.isCubeTexture)) ? 1 : -1;
                uniforms.reflectivity.value = material.reflectivity;
                uniforms.refractionRatio.value = material.refractionRatio;
                uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;
            }
            if (material.lightMap) {
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
            }
            if (material.aoMap) {
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
            }
            var uvScaleMap;
            if (material.map) {
                uvScaleMap = material.map;
            } else if (material.specularMap) {
                uvScaleMap = material.specularMap;
            } else if (material.displacementMap) {
                uvScaleMap = material.displacementMap;
            } else if (material.normalMap) {
                uvScaleMap = material.normalMap;
            } else if (material.bumpMap) {
                uvScaleMap = material.bumpMap;
            } else if (material.roughnessMap) {
                uvScaleMap = material.roughnessMap;
            } else if (material.metalnessMap) {
                uvScaleMap = material.metalnessMap;
            } else if (material.alphaMap) {
                uvScaleMap = material.alphaMap;
            } else if (material.emissiveMap) {
                uvScaleMap = material.emissiveMap;
            }
            if (uvScaleMap !== undefined) {
                if (uvScaleMap.isWebGLRenderTarget) {
                    uvScaleMap = uvScaleMap.texture;
                }
                if (uvScaleMap.matrixAutoUpdate === true) {
                    uvScaleMap.updateMatrix();
                }
                uniforms.uvTransform.value.copy(uvScaleMap.matrix);
            }
        }
        function refreshUniformsLine(uniforms, material) {
            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
        }
        function refreshUniformsDash(uniforms, material) {
            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
        }
        function refreshUniformsPoints(uniforms, material) {
            uniforms.diffuse.value = material.color;
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * _pixelRatio;
            uniforms.scale.value = _height * 0.5;
            uniforms.map.value = material.map;
            if (material.map !== null) {
                if (material.map.matrixAutoUpdate === true) {
                    material.map.updateMatrix();
                }
                uniforms.uvTransform.value.copy(material.map.matrix);
            }
        }
        function refreshUniformsFog(uniforms, fog) {
            uniforms.fogColor.value = fog.color;
            if (fog.isFog) {
                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
            } else if (fog.isFogExp2) {
                uniforms.fogDensity.value = fog.density;
            }
        }
        function refreshUniformsLambert(uniforms, material) {
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
        }
        function refreshUniformsPhong(uniforms, material) {
            uniforms.specular.value = material.specular;
            uniforms.shininess.value = Math.max(material.shininess, 1e-4);
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsToon(uniforms, material) {
            refreshUniformsPhong(uniforms, material);
            if (material.gradientMap) {
                uniforms.gradientMap.value = material.gradientMap;
            }
        }
        function refreshUniformsStandard(uniforms, material) {
            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;
            if (material.roughnessMap) {
                uniforms.roughnessMap.value = material.roughnessMap;
            }
            if (material.metalnessMap) {
                uniforms.metalnessMap.value = material.metalnessMap;
            }
            if (material.emissiveMap) {
                uniforms.emissiveMap.value = material.emissiveMap;
            }
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            if (material.envMap) {
                uniforms.envMapIntensity.value = material.envMapIntensity;
            }
        }
        function refreshUniformsPhysical(uniforms, material) {
            uniforms.clearCoat.value = material.clearCoat;
            uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
            refreshUniformsStandard(uniforms, material);
        }
        function refreshUniformsDepth(uniforms, material) {
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function refreshUniformsDistance(uniforms, material) {
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
            uniforms.referencePosition.value.copy(material.referencePosition);
            uniforms.nearDistance.value = material.nearDistance;
            uniforms.farDistance.value = material.farDistance;
        }
        function refreshUniformsNormal(uniforms, material) {
            if (material.bumpMap) {
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if (material.side === BackSide)
                    uniforms.bumpScale.value *= -1;
            }
            if (material.normalMap) {
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy(material.normalScale);
                if (material.side === BackSide)
                    uniforms.normalScale.value.negate();
            }
            if (material.displacementMap) {
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
            }
        }
        function markUniformsLightsNeedsUpdate(uniforms, value) {
            uniforms.ambientLightColor.needsUpdate = value;
            uniforms.directionalLights.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
        }
        function allocTextureUnit() {
            var textureUnit = _usedTextureUnits;
            if (textureUnit >= capabilities.maxTextures) {
                console.warn('THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures);
            }
            _usedTextureUnits += 1;
            return textureUnit;
        }
        this.allocTextureUnit = allocTextureUnit;
        this.setTexture2D = (function () {
            var warned = false;
            return function setTexture2D(texture, slot) {
                if (texture && texture.isWebGLRenderTarget) {
                    if (!warned) {
                        console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
                        warned = true;
                    }
                    texture = texture.texture;
                }
                textures.setTexture2D(texture, slot);
            }
                ;
        }());
        this.setTexture = (function () {
            var warned = false;
            return function setTexture(texture, slot) {
                if (!warned) {
                    console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");
                    warned = true;
                }
                textures.setTexture2D(texture, slot);
            }
                ;
        }());
        this.setTextureCube = (function () {
            var warned = false;
            return function setTextureCube(texture, slot) {
                if (texture && texture.isWebGLRenderTargetCube) {
                    if (!warned) {
                        console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                        warned = true;
                    }
                    texture = texture.texture;
                }
                if ((texture && texture.isCubeTexture) || (Array.isArray(texture.image) && texture.image.length === 6)) {
                    textures.setTextureCube(texture, slot);
                } else {
                    textures.setTextureCubeDynamic(texture, slot);
                }
            }
                ;
        }());
        this.setFramebuffer = function (value) {
            _framebuffer = value;
        }
            ;
        this.getRenderTarget = function () {
            return _currentRenderTarget;
        }
            ;
        this.setRenderTarget = function (renderTarget) {
            _currentRenderTarget = renderTarget;
            if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
                textures.setupRenderTarget(renderTarget);
            }
            var framebuffer = _framebuffer;
            var isCube = false;
            if (renderTarget) {
                var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                if (renderTarget.isWebGLRenderTargetCube) {
                    framebuffer = __webglFramebuffer[renderTarget.activeCubeFace];
                    isCube = true;
                } else {
                    framebuffer = __webglFramebuffer;
                }
                _currentViewport.copy(renderTarget.viewport);
                _currentScissor.copy(renderTarget.scissor);
                _currentScissorTest = renderTarget.scissorTest;
            } else {
                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
                _currentScissorTest = _scissorTest;
            }
            if (_currentFramebuffer !== framebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                _currentFramebuffer = framebuffer;
            }
            state.viewport(_currentViewport);
            state.scissor(_currentScissor);
            state.setScissorTest(_currentScissorTest);
            if (isCube) {
                var textureProperties = properties.get(renderTarget.texture);
                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
            }
        }
            ;
        this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {
            if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                return;
            }
            var framebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (framebuffer) {
                var restore = false;
                if (framebuffer !== _currentFramebuffer) {
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                    restore = true;
                }
                try {
                    var texture = renderTarget.texture;
                    var textureFormat = texture.format;
                    var textureType = texture.type;
                    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                        return;
                    }
                    if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && !(textureType === HalfFloatType && extensions.get('EXT_color_buffer_half_float'))) {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                        return;
                    }
                    if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                        if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
                            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                        }
                    } else {
                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
                    }
                } finally {
                    if (restore) {
                        _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
                    }
                }
            }
        }
            ;
        this.copyFramebufferToTexture = function (position, texture, level) {
            var width = texture.image.width;
            var height = texture.image.height;
            var glFormat = utils.convert(texture.format);
            this.setTexture2D(texture, 0);
            _gl.copyTexImage2D(_gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0);
        }
            ;
        this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
            var width = srcTexture.image.width;
            var height = srcTexture.image.height;
            var glFormat = utils.convert(dstTexture.format);
            var glType = utils.convert(dstTexture.type);
            this.setTexture2D(dstTexture, 0);
            if (srcTexture.isDataTexture) {
                _gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
            } else {
                _gl.texSubImage2D(_gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
            }
        }
            ;
    }
    function FogExp2(color, density) {
        this.name = '';
        this.color = new Color(color);
        this.density = (density !== undefined) ? density : 0.00025;
    }
    FogExp2.prototype.isFogExp2 = true;
    FogExp2.prototype.clone = function () {
        return new FogExp2(this.color, this.density);
    }
        ;
    FogExp2.prototype.toJSON = function () {
        return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density
        };
    }
        ;
    function Fog(color, near, far) {
        this.name = '';
        this.color = new Color(color);
        this.near = (near !== undefined) ? near : 1;
        this.far = (far !== undefined) ? far : 1000;
    }
    Fog.prototype.isFog = true;
    Fog.prototype.clone = function () {
        return new Fog(this.color, this.near, this.far);
    }
        ;
    Fog.prototype.toJSON = function () {
        return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }
        ;
    function Scene() {
        Object3D.call(this);
        this.type = 'Scene';
        this.background = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true;
    }
    Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Scene,
        copy: function (source, recursive) {
            Object3D.prototype.copy.call(this, source, recursive);
            if (source.background !== null)
                this.background = source.background.clone();
            if (source.fog !== null)
                this.fog = source.fog.clone();
            if (source.overrideMaterial !== null)
                this.overrideMaterial = source.overrideMaterial.clone();
            this.autoUpdate = source.autoUpdate;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            return this;
        },
        toJSON: function (meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            if (this.background !== null)
                data.object.background = this.background.toJSON(meta);
            if (this.fog !== null)
                data.object.fog = this.fog.toJSON();
            return data;
        }
    });
    function SpriteMaterial(parameters) {
        Material.call(this);
        this.type = 'SpriteMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.rotation = 0;
        this.fog = false;
        this.lights = false;
        this.setValues(parameters);
    }
    SpriteMaterial.prototype = Object.create(Material.prototype);
    SpriteMaterial.prototype.constructor = SpriteMaterial;
    SpriteMaterial.prototype.isSpriteMaterial = true;
    SpriteMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.rotation = source.rotation;
        return this;
    }
        ;
    function Sprite(material) {
        Object3D.call(this);
        this.type = 'Sprite';
        this.material = (material !== undefined) ? material : new SpriteMaterial();
        this.center = new Vector2(0.5, 0.5);
    }
    Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Sprite,
        isSprite: true,
        raycast: (function () {
            var intersectPoint = new Vector3();
            var worldPosition = new Vector3();
            var worldScale = new Vector3();
            return function raycast(raycaster, intersects) {
                worldPosition.setFromMatrixPosition(this.matrixWorld);
                raycaster.ray.closestPointToPoint(worldPosition, intersectPoint);
                worldScale.setFromMatrixScale(this.matrixWorld);
                var guessSizeSq = worldScale.x * worldScale.y / 4;
                if (worldPosition.distanceToSquared(intersectPoint) > guessSizeSq)
                    return;
                var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                if (distance < raycaster.near || distance > raycaster.far)
                    return;
                intersects.push({
                    distance: distance,
                    point: intersectPoint.clone(),
                    face: null,
                    object: this
                });
            }
                ;
        }()),
        clone: function () {
            return new this.constructor(this.material).copy(this);
        },
        copy: function (source) {
            Object3D.prototype.copy.call(this, source);
            if (source.center !== undefined)
                this.center.copy(source.center);
            return this;
        }
    });
    function LOD() {
        Object3D.call(this);
        this.type = 'LOD';
        Object.defineProperties(this, {
            levels: {
                enumerable: true,
                value: []
            }
        });
    }
    LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: LOD,
        copy: function (source) {
            Object3D.prototype.copy.call(this, source, false);
            var levels = source.levels;
            for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                this.addLevel(level.object.clone(), level.distance);
            }
            return this;
        },
        addLevel: function (object, distance) {
            if (distance === undefined)
                distance = 0;
            distance = Math.abs(distance);
            var levels = this.levels;
            for (var l = 0; l < levels.length; l++) {
                if (distance < levels[l].distance) {
                    break;
                }
            }
            levels.splice(l, 0, {
                distance: distance,
                object: object
            });
            this.add(object);
        },
        getObjectForDistance: function (distance) {
            var levels = this.levels;
            for (var i = 1, l = levels.length; i < l; i++) {
                if (distance < levels[i].distance) {
                    break;
                }
            }
            return levels[i - 1].object;
        },
        raycast: (function () {
            var matrixPosition = new Vector3();
            return function raycast(raycaster, intersects) {
                matrixPosition.setFromMatrixPosition(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(matrixPosition);
                this.getObjectForDistance(distance).raycast(raycaster, intersects);
            }
                ;
        }()),
        update: function () {
            var v1 = new Vector3();
            var v2 = new Vector3();
            return function update(camera) {
                var levels = this.levels;
                if (levels.length > 1) {
                    v1.setFromMatrixPosition(camera.matrixWorld);
                    v2.setFromMatrixPosition(this.matrixWorld);
                    var distance = v1.distanceTo(v2);
                    levels[0].object.visible = true;
                    for (var i = 1, l = levels.length; i < l; i++) {
                        if (distance >= levels[i].distance) {
                            levels[i - 1].object.visible = false;
                            levels[i].object.visible = true;
                        } else {
                            break;
                        }
                    }
                    for (; i < l; i++) {
                        levels[i].object.visible = false;
                    }
                }
            }
                ;
        }(),
        toJSON: function (meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.levels = [];
            var levels = this.levels;
            for (var i = 0, l = levels.length; i < l; i++) {
                var level = levels[i];
                data.object.levels.push({
                    object: level.object.uuid,
                    distance: level.distance
                });
            }
            return data;
        }
    });
    function Skeleton(bones, boneInverses) {
        bones = bones || [];
        this.bones = bones.slice(0);
        this.boneMatrices = new Float32Array(this.bones.length * 16);
        if (boneInverses === undefined) {
            this.calculateInverses();
        } else {
            if (this.bones.length === boneInverses.length) {
                this.boneInverses = boneInverses.slice(0);
            } else {
                console.warn('THREE.Skeleton boneInverses is the wrong length.');
                this.boneInverses = [];
                for (var i = 0, il = this.bones.length; i < il; i++) {
                    this.boneInverses.push(new Matrix4());
                }
            }
        }
    }
    Object.assign(Skeleton.prototype, {
        calculateInverses: function () {
            this.boneInverses = [];
            for (var i = 0, il = this.bones.length; i < il; i++) {
                var inverse = new Matrix4();
                if (this.bones[i]) {
                    inverse.getInverse(this.bones[i].matrixWorld);
                }
                this.boneInverses.push(inverse);
            }
        },
        pose: function () {
            var bone, i, il;
            for (i = 0,
                il = this.bones.length; i < il; i++) {
                bone = this.bones[i];
                if (bone) {
                    bone.matrixWorld.getInverse(this.boneInverses[i]);
                }
            }
            for (i = 0,
                il = this.bones.length; i < il; i++) {
                bone = this.bones[i];
                if (bone) {
                    if (bone.parent && bone.parent.isBone) {
                        bone.matrix.getInverse(bone.parent.matrixWorld);
                        bone.matrix.multiply(bone.matrixWorld);
                    } else {
                        bone.matrix.copy(bone.matrixWorld);
                    }
                    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                }
            }
        },
        update: (function () {
            var offsetMatrix = new Matrix4();
            var identityMatrix = new Matrix4();
            return function update() {
                var bones = this.bones;
                var boneInverses = this.boneInverses;
                var boneMatrices = this.boneMatrices;
                var boneTexture = this.boneTexture;
                for (var i = 0, il = bones.length; i < il; i++) {
                    var matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;
                    offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                    offsetMatrix.toArray(boneMatrices, i * 16);
                }
                if (boneTexture !== undefined) {
                    boneTexture.needsUpdate = true;
                }
            }
                ;
        }
        )(),
        clone: function () {
            return new Skeleton(this.bones, this.boneInverses);
        },
        getBoneByName: function (name) {
            for (var i = 0, il = this.bones.length; i < il; i++) {
                var bone = this.bones[i];
                if (bone.name === name) {
                    return bone;
                }
            }
            return undefined;
        }
    });
    function Bone() {
        Object3D.call(this);
        this.type = 'Bone';
    }
    Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Bone,
        isBone: true
    });
    function SkinnedMesh(geometry, material) {
        Mesh.call(this, geometry, material);
        this.type = 'SkinnedMesh';
        this.bindMode = 'attached';
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
        var bones = this.initBones();
        var skeleton = new Skeleton(bones);
        this.bind(skeleton, this.matrixWorld);
        this.normalizeSkinWeights();
    }
    SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
        constructor: SkinnedMesh,
        isSkinnedMesh: true,
        initBones: function () {
            var bones = [], bone, gbone;
            var i, il;
            if (this.geometry && this.geometry.bones !== undefined) {
                for (i = 0,
                    il = this.geometry.bones.length; i < il; i++) {
                    gbone = this.geometry.bones[i];
                    bone = new Bone();
                    bones.push(bone);
                    bone.name = gbone.name;
                    bone.position.fromArray(gbone.pos);
                    bone.quaternion.fromArray(gbone.rotq);
                    if (gbone.scl !== undefined)
                        bone.scale.fromArray(gbone.scl);
                }
                for (i = 0,
                    il = this.geometry.bones.length; i < il; i++) {
                    gbone = this.geometry.bones[i];
                    if ((gbone.parent !== -1) && (gbone.parent !== null) && (bones[gbone.parent] !== undefined)) {
                        bones[gbone.parent].add(bones[i]);
                    } else {
                        this.add(bones[i]);
                    }
                }
            }
            this.updateMatrixWorld(true);
            return bones;
        },
        bind: function (skeleton, bindMatrix) {
            this.skeleton = skeleton;
            if (bindMatrix === undefined) {
                this.updateMatrixWorld(true);
                this.skeleton.calculateInverses();
                bindMatrix = this.matrixWorld;
            }
            this.bindMatrix.copy(bindMatrix);
            this.bindMatrixInverse.getInverse(bindMatrix);
        },
        pose: function () {
            this.skeleton.pose();
        },
        normalizeSkinWeights: function () {
            var scale, i;
            if (this.geometry && this.geometry.isGeometry) {
                for (i = 0; i < this.geometry.skinWeights.length; i++) {
                    var sw = this.geometry.skinWeights[i];
                    scale = 1.0 / sw.manhattanLength();
                    if (scale !== Infinity) {
                        sw.multiplyScalar(scale);
                    } else {
                        sw.set(1, 0, 0, 0);
                    }
                }
            } else if (this.geometry && this.geometry.isBufferGeometry) {
                var vec = new Vector4();
                var skinWeight = this.geometry.attributes.skinWeight;
                for (i = 0; i < skinWeight.count; i++) {
                    vec.x = skinWeight.getX(i);
                    vec.y = skinWeight.getY(i);
                    vec.z = skinWeight.getZ(i);
                    vec.w = skinWeight.getW(i);
                    scale = 1.0 / vec.manhattanLength();
                    if (scale !== Infinity) {
                        vec.multiplyScalar(scale);
                    } else {
                        vec.set(1, 0, 0, 0);
                    }
                    skinWeight.setXYZW(i, vec.x, vec.y, vec.z, vec.w);
                }
            }
        },
        updateMatrixWorld: function (force) {
            Mesh.prototype.updateMatrixWorld.call(this, force);
            if (this.bindMode === 'attached') {
                this.bindMatrixInverse.getInverse(this.matrixWorld);
            } else if (this.bindMode === 'detached') {
                this.bindMatrixInverse.getInverse(this.bindMatrix);
            } else {
                console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
            }
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });
    function LineBasicMaterial(parameters) {
        Material.call(this);
        this.type = 'LineBasicMaterial';
        this.color = new Color(0xffffff);
        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';
        this.lights = false;
        this.setValues(parameters);
    }
    LineBasicMaterial.prototype = Object.create(Material.prototype);
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    LineBasicMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        return this;
    }
        ;
    function Line(geometry, material, mode) {
        if (mode === 1) {
            console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');
            return new LineSegments(geometry, material);
        }
        Object3D.call(this);
        this.type = 'Line';
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new LineBasicMaterial({
            color: Math.random() * 0xffffff
        });
    }
    Line.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Line,
        isLine: true,
        computeLineDistances: (function () {
            var start = new Vector3();
            var end = new Vector3();
            return function computeLineDistances() {
                var geometry = this.geometry;
                if (geometry.isBufferGeometry) {
                    if (geometry.index === null) {
                        var positionAttribute = geometry.attributes.position;
                        var lineDistances = [0];
                        for (var i = 1, l = positionAttribute.count; i < l; i++) {
                            start.fromBufferAttribute(positionAttribute, i - 1);
                            end.fromBufferAttribute(positionAttribute, i);
                            lineDistances[i] = lineDistances[i - 1];
                            lineDistances[i] += start.distanceTo(end);
                        }
                        geometry.addAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
                    } else {
                        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
                    }
                } else if (geometry.isGeometry) {
                    var vertices = geometry.vertices;
                    var lineDistances = geometry.lineDistances;
                    lineDistances[0] = 0;
                    for (var i = 1, l = vertices.length; i < l; i++) {
                        lineDistances[i] = lineDistances[i - 1];
                        lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
                    }
                }
                return this;
            }
                ;
        }()),
        raycast: (function () {
            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();
            return function raycast(raycaster, intersects) {
                var precision = raycaster.linePrecision;
                var precisionSq = precision * precision;
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                if (geometry.boundingSphere === null)
                    geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                if (raycaster.ray.intersectsSphere(sphere) === false)
                    return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                var vStart = new Vector3();
                var vEnd = new Vector3();
                var interSegment = new Vector3();
                var interRay = new Vector3();
                var step = (this && this.isLineSegments) ? 2 : 1;
                if (geometry.isBufferGeometry) {
                    var index = geometry.index;
                    var attributes = geometry.attributes;
                    var positions = attributes.position.array;
                    if (index !== null) {
                        var indices = index.array;
                        for (var i = 0, l = indices.length - 1; i < l; i += step) {
                            var a = indices[i];
                            var b = indices[i + 1];
                            vStart.fromArray(positions, a * 3);
                            vEnd.fromArray(positions, b * 3);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (distSq > precisionSq)
                                continue;
                            interRay.applyMatrix4(this.matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(interRay);
                            if (distance < raycaster.near || distance > raycaster.far)
                                continue;
                            intersects.push({
                                distance: distance,
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            });
                        }
                    } else {
                        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
                            vStart.fromArray(positions, 3 * i);
                            vEnd.fromArray(positions, 3 * i + 3);
                            var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                            if (distSq > precisionSq)
                                continue;
                            interRay.applyMatrix4(this.matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(interRay);
                            if (distance < raycaster.near || distance > raycaster.far)
                                continue;
                            intersects.push({
                                distance: distance,
                                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                index: i,
                                face: null,
                                faceIndex: null,
                                object: this
                            });
                        }
                    }
                } else if (geometry.isGeometry) {
                    var vertices = geometry.vertices;
                    var nbVertices = vertices.length;
                    for (var i = 0; i < nbVertices - 1; i += step) {
                        var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
                        if (distSq > precisionSq)
                            continue;
                        interRay.applyMatrix4(this.matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(interRay);
                        if (distance < raycaster.near || distance > raycaster.far)
                            continue;
                        intersects.push({
                            distance: distance,
                            point: interSegment.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        });
                    }
                }
            }
                ;
        }()),
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });
    function LineSegments(geometry, material) {
        Line.call(this, geometry, material);
        this.type = 'LineSegments';
    }
    LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineSegments,
        isLineSegments: true,
        computeLineDistances: (function () {
            var start = new Vector3();
            var end = new Vector3();
            return function computeLineDistances() {
                var geometry = this.geometry;
                if (geometry.isBufferGeometry) {
                    if (geometry.index === null) {
                        var positionAttribute = geometry.attributes.position;
                        var lineDistances = [];
                        for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
                            start.fromBufferAttribute(positionAttribute, i);
                            end.fromBufferAttribute(positionAttribute, i + 1);
                            lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
                            lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
                        }
                        geometry.addAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
                    } else {
                        console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
                    }
                } else if (geometry.isGeometry) {
                    var vertices = geometry.vertices;
                    var lineDistances = geometry.lineDistances;
                    for (var i = 0, l = vertices.length; i < l; i += 2) {
                        start.copy(vertices[i]);
                        end.copy(vertices[i + 1]);
                        lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
                        lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
                    }
                }
                return this;
            }
                ;
        }())
    });
    function LineLoop(geometry, material) {
        Line.call(this, geometry, material);
        this.type = 'LineLoop';
    }
    LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
        constructor: LineLoop,
        isLineLoop: true,
    });
    function PointsMaterial(parameters) {
        Material.call(this);
        this.type = 'PointsMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.morphTargets = false;
        this.lights = false;
        this.setValues(parameters);
    }
    PointsMaterial.prototype = Object.create(Material.prototype);
    PointsMaterial.prototype.constructor = PointsMaterial;
    PointsMaterial.prototype.isPointsMaterial = true;
    PointsMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        this.morphTargets = source.morphTargets;
        return this;
    }
        ;
    function Points(geometry, material) {
        Object3D.call(this);
        this.type = 'Points';
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new PointsMaterial({
            color: Math.random() * 0xffffff
        });
    }
    Points.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Points,
        isPoints: true,
        raycast: (function () {
            var inverseMatrix = new Matrix4();
            var ray = new Ray();
            var sphere = new Sphere();
            return function raycast(raycaster, intersects) {
                var object = this;
                var geometry = this.geometry;
                var matrixWorld = this.matrixWorld;
                var threshold = raycaster.params.Points.threshold;
                if (geometry.boundingSphere === null)
                    geometry.computeBoundingSphere();
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(matrixWorld);
                sphere.radius += threshold;
                if (raycaster.ray.intersectsSphere(sphere) === false)
                    return;
                inverseMatrix.getInverse(matrixWorld);
                ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
                var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                var localThresholdSq = localThreshold * localThreshold;
                var position = new Vector3();
                var intersectPoint = new Vector3();
                function testPoint(point, index) {
                    var rayPointDistanceSq = ray.distanceSqToPoint(point);
                    if (rayPointDistanceSq < localThresholdSq) {
                        ray.closestPointToPoint(point, intersectPoint);
                        intersectPoint.applyMatrix4(matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far)
                            return;
                        intersects.push({
                            distance: distance,
                            distanceToRay: Math.sqrt(rayPointDistanceSq),
                            point: intersectPoint.clone(),
                            index: index,
                            face: null,
                            object: object
                        });
                    }
                }
                if (geometry.isBufferGeometry) {
                    var index = geometry.index;
                    var attributes = geometry.attributes;
                    var positions = attributes.position.array;
                    if (index !== null) {
                        var indices = index.array;
                        for (var i = 0, il = indices.length; i < il; i++) {
                            var a = indices[i];
                            position.fromArray(positions, a * 3);
                            testPoint(position, a);
                        }
                    } else {
                        for (var i = 0, l = positions.length / 3; i < l; i++) {
                            position.fromArray(positions, i * 3);
                            testPoint(position, i);
                        }
                    }
                } else {
                    var vertices = geometry.vertices;
                    for (var i = 0, l = vertices.length; i < l; i++) {
                        testPoint(vertices[i], i);
                    }
                }
            }
                ;
        }()),
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this);
        }
    });
    function Group() {
        Object3D.call(this);
        this.type = 'Group';
    }
    Group.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Group,
        isGroup: true
    });
    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.generateMipmaps = false;
    }
    VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
        constructor: VideoTexture,
        isVideoTexture: true,
        update: function () {
            var video = this.image;
            if (video.readyState >= video.HAVE_CURRENT_DATA) {
                this.needsUpdate = true;
            }
        }
    });
    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = {
            width: width,
            height: height
        };
        this.mipmaps = mipmaps;
        this.flipY = false;
        this.generateMipmaps = false;
    }
    CompressedTexture.prototype = Object.create(Texture.prototype);
    CompressedTexture.prototype.constructor = CompressedTexture;
    CompressedTexture.prototype.isCompressedTexture = true;
    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        format = format !== undefined ? format : DepthFormat;
        if (format !== DepthFormat && format !== DepthStencilFormat) {
            throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
        }
        if (type === undefined && format === DepthFormat)
            type = UnsignedShortType;
        if (type === undefined && format === DepthStencilFormat)
            type = UnsignedInt248Type;
        Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.image = {
            width: width,
            height: height
        };
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
        this.flipY = false;
        this.generateMipmaps = false;
    }
    DepthTexture.prototype = Object.create(Texture.prototype);
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;
    function WireframeGeometry(geometry) {
        BufferGeometry.call(this);
        this.type = 'WireframeGeometry';
        var vertices = [];
        var i, j, l, o, ol;
        var edge = [0, 0], edges = {}, e, edge1, edge2;
        var key, keys = ['a', 'b', 'c'];
        var vertex;
        if (geometry && geometry.isGeometry) {
            var faces = geometry.faces;
            for (i = 0,
                l = faces.length; i < l; i++) {
                var face = faces[i];
                for (j = 0; j < 3; j++) {
                    edge1 = face[keys[j]];
                    edge2 = face[keys[(j + 1) % 3]];
                    edge[0] = Math.min(edge1, edge2);
                    edge[1] = Math.max(edge1, edge2);
                    key = edge[0] + ',' + edge[1];
                    if (edges[key] === undefined) {
                        edges[key] = {
                            index1: edge[0],
                            index2: edge[1]
                        };
                    }
                }
            }
            for (key in edges) {
                e = edges[key];
                vertex = geometry.vertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z);
                vertex = geometry.vertices[e.index2];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        } else if (geometry && geometry.isBufferGeometry) {
            var position, indices, groups;
            var group, start, count;
            var index1, index2;
            vertex = new Vector3();
            if (geometry.index !== null) {
                position = geometry.attributes.position;
                indices = geometry.index;
                groups = geometry.groups;
                if (groups.length === 0) {
                    groups = [{
                        start: 0,
                        count: indices.count,
                        materialIndex: 0
                    }];
                }
                for (o = 0,
                    ol = groups.length; o < ol; ++o) {
                    group = groups[o];
                    start = group.start;
                    count = group.count;
                    for (i = start,
                        l = (start + count); i < l; i += 3) {
                        for (j = 0; j < 3; j++) {
                            edge1 = indices.getX(i + j);
                            edge2 = indices.getX(i + (j + 1) % 3);
                            edge[0] = Math.min(edge1, edge2);
                            edge[1] = Math.max(edge1, edge2);
                            key = edge[0] + ',' + edge[1];
                            if (edges[key] === undefined) {
                                edges[key] = {
                                    index1: edge[0],
                                    index2: edge[1]
                                };
                            }
                        }
                    }
                }
                for (key in edges) {
                    e = edges[key];
                    vertex.fromBufferAttribute(position, e.index1);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    vertex.fromBufferAttribute(position, e.index2);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                }
            } else {
                position = geometry.attributes.position;
                for (i = 0,
                    l = (position.count / 3); i < l; i++) {
                    for (j = 0; j < 3; j++) {
                        index1 = 3 * i + j;
                        vertex.fromBufferAttribute(position, index1);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                        index2 = 3 * i + ((j + 1) % 3);
                        vertex.fromBufferAttribute(position, index2);
                        vertices.push(vertex.x, vertex.y, vertex.z);
                    }
                }
            }
        }
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
    }
    WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
    WireframeGeometry.prototype.constructor = WireframeGeometry;
    function ParametricGeometry(func, slices, stacks) {
        Geometry.call(this);
        this.type = 'ParametricGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
        this.mergeVertices();
    }
    ParametricGeometry.prototype = Object.create(Geometry.prototype);
    ParametricGeometry.prototype.constructor = ParametricGeometry;
    function ParametricBufferGeometry(func, slices, stacks) {
        BufferGeometry.call(this);
        this.type = 'ParametricBufferGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var EPS = 0.00001;
        var normal = new Vector3();
        var p0 = new Vector3()
            , p1 = new Vector3();
        var pu = new Vector3()
            , pv = new Vector3();
        var i, j;
        if (func.length < 3) {
            console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
        }
        var sliceCount = slices + 1;
        for (i = 0; i <= stacks; i++) {
            var v = i / stacks;
            for (j = 0; j <= slices; j++) {
                var u = j / slices;
                func(u, v, p0);
                vertices.push(p0.x, p0.y, p0.z);
                if (u - EPS >= 0) {
                    func(u - EPS, v, p1);
                    pu.subVectors(p0, p1);
                } else {
                    func(u + EPS, v, p1);
                    pu.subVectors(p1, p0);
                }
                if (v - EPS >= 0) {
                    func(u, v - EPS, p1);
                    pv.subVectors(p0, p1);
                } else {
                    func(u, v + EPS, p1);
                    pv.subVectors(p1, p0);
                }
                normal.crossVectors(pu, pv).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u, v);
            }
        }
        for (i = 0; i < stacks; i++) {
            for (j = 0; j < slices; j++) {
                var a = i * sliceCount + j;
                var b = i * sliceCount + j + 1;
                var c = (i + 1) * sliceCount + j + 1;
                var d = (i + 1) * sliceCount + j;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
    function PolyhedronGeometry(vertices, indices, radius, detail) {
        Geometry.call(this);
        this.type = 'PolyhedronGeometry';
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
        this.mergeVertices();
    }
    PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
    function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
        BufferGeometry.call(this);
        this.type = 'PolyhedronBufferGeometry';
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
        radius = radius || 1;
        detail = detail || 0;
        var vertexBuffer = [];
        var uvBuffer = [];
        subdivide(detail);
        appplyRadius(radius);
        generateUVs();
        this.addAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
        this.addAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
        if (detail === 0) {
            this.computeVertexNormals();
        } else {
            this.normalizeNormals();
        }
        function subdivide(detail) {
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
            for (var i = 0; i < indices.length; i += 3) {
                getVertexByIndex(indices[i + 0], a);
                getVertexByIndex(indices[i + 1], b);
                getVertexByIndex(indices[i + 2], c);
                subdivideFace(a, b, c, detail);
            }
        }
        function subdivideFace(a, b, c, detail) {
            var cols = Math.pow(2, detail);
            var v = [];
            var i, j;
            for (i = 0; i <= cols; i++) {
                v[i] = [];
                var aj = a.clone().lerp(c, i / cols);
                var bj = b.clone().lerp(c, i / cols);
                var rows = cols - i;
                for (j = 0; j <= rows; j++) {
                    if (j === 0 && i === cols) {
                        v[i][j] = aj;
                    } else {
                        v[i][j] = aj.clone().lerp(bj, j / rows);
                    }
                }
            }
            for (i = 0; i < cols; i++) {
                for (j = 0; j < 2 * (cols - i) - 1; j++) {
                    var k = Math.floor(j / 2);
                    if (j % 2 === 0) {
                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k]);
                        pushVertex(v[i][k]);
                    } else {
                        pushVertex(v[i][k + 1]);
                        pushVertex(v[i + 1][k + 1]);
                        pushVertex(v[i + 1][k]);
                    }
                }
            }
        }
        function appplyRadius(radius) {
            var vertex = new Vector3();
            for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                vertex.normalize().multiplyScalar(radius);
                vertexBuffer[i + 0] = vertex.x;
                vertexBuffer[i + 1] = vertex.y;
                vertexBuffer[i + 2] = vertex.z;
            }
        }
        function generateUVs() {
            var vertex = new Vector3();
            for (var i = 0; i < vertexBuffer.length; i += 3) {
                vertex.x = vertexBuffer[i + 0];
                vertex.y = vertexBuffer[i + 1];
                vertex.z = vertexBuffer[i + 2];
                var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                var v = inclination(vertex) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }
        function correctSeam() {
            for (var i = 0; i < uvBuffer.length; i += 6) {
                var x0 = uvBuffer[i + 0];
                var x1 = uvBuffer[i + 2];
                var x2 = uvBuffer[i + 4];
                var max = Math.max(x0, x1, x2);
                var min = Math.min(x0, x1, x2);
                if (max > 0.9 && min < 0.1) {
                    if (x0 < 0.2)
                        uvBuffer[i + 0] += 1;
                    if (x1 < 0.2)
                        uvBuffer[i + 2] += 1;
                    if (x2 < 0.2)
                        uvBuffer[i + 4] += 1;
                }
            }
        }
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }
        function getVertexByIndex(index, vertex) {
            var stride = index * 3;
            vertex.x = vertices[stride + 0];
            vertex.y = vertices[stride + 1];
            vertex.z = vertices[stride + 2];
        }
        function correctUVs() {
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
            var centroid = new Vector3();
            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();
            for (var i = 0, j = 0; i < vertexBuffer.length; i += 9,
                j += 6) {
                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a).add(b).add(c).divideScalar(3);
                var azi = azimuth(centroid);
                correctUV(uvA, j + 0, a, azi);
                correctUV(uvB, j + 2, b, azi);
                correctUV(uvC, j + 4, c, azi);
            }
        }
        function correctUV(uv, stride, vector, azimuth) {
            if ((azimuth < 0) && (uv.x === 1)) {
                uvBuffer[stride] = uv.x - 1;
            }
            if ((vector.x === 0) && (vector.z === 0)) {
                uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
            }
        }
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
        }
    }
    PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
    function TetrahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'TetrahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
    function TetrahedronBufferGeometry(radius, detail) {
        var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
        var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'TetrahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
    function OctahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'OctahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    OctahedronGeometry.prototype = Object.create(Geometry.prototype);
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;
    function OctahedronBufferGeometry(radius, detail) {
        var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
        var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'OctahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
    function IcosahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'IcosahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
    function IcosahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2;
        var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
        var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'IcosahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
    function DodecahedronGeometry(radius, detail) {
        Geometry.call(this);
        this.type = 'DodecahedronGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
        this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
        this.mergeVertices();
    }
    DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
    function DodecahedronBufferGeometry(radius, detail) {
        var t = (1 + Math.sqrt(5)) / 2;
        var r = 1 / t;
        var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
        var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
        this.type = 'DodecahedronBufferGeometry';
        this.parameters = {
            radius: radius,
            detail: detail
        };
    }
    DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
    DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
        Geometry.call(this);
        this.type = 'TubeGeometry';
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        if (taper !== undefined)
            console.warn('THREE.TubeGeometry: taper has been removed.');
        var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
        this.tangents = bufferGeometry.tangents;
        this.normals = bufferGeometry.normals;
        this.binormals = bufferGeometry.binormals;
        this.fromBufferGeometry(bufferGeometry);
        this.mergeVertices();
    }
    TubeGeometry.prototype = Object.create(Geometry.prototype);
    TubeGeometry.prototype.constructor = TubeGeometry;
    function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
        BufferGeometry.call(this);
        this.type = 'TubeBufferGeometry';
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
        tubularSegments = tubularSegments || 64;
        radius = radius || 1;
        radialSegments = radialSegments || 8;
        closed = closed || false;
        var frames = path.computeFrenetFrames(tubularSegments, closed);
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        var vertex = new Vector3();
        var normal = new Vector3();
        var uv = new Vector2();
        var P = new Vector3();
        var i, j;
        var vertices = [];
        var normals = [];
        var uvs = [];
        var indices = [];
        generateBufferData();
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
        function generateBufferData() {
            for (i = 0; i < tubularSegments; i++) {
                generateSegment(i);
            }
            generateSegment((closed === false) ? tubularSegments : 0);
            generateUVs();
            generateIndices();
        }
        function generateSegment(i) {
            P = path.getPointAt(i / tubularSegments, P);
            var N = frames.normals[i];
            var B = frames.binormals[i];
            for (j = 0; j <= radialSegments; j++) {
                var v = j / radialSegments * Math.PI * 2;
                var sin = Math.sin(v);
                var cos = -Math.cos(v);
                normal.x = (cos * N.x + sin * B.x);
                normal.y = (cos * N.y + sin * B.y);
                normal.z = (cos * N.z + sin * B.z);
                normal.normalize();
                normals.push(normal.x, normal.y, normal.z);
                vertex.x = P.x + radius * normal.x;
                vertex.y = P.y + radius * normal.y;
                vertex.z = P.z + radius * normal.z;
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        function generateIndices() {
            for (j = 1; j <= tubularSegments; j++) {
                for (i = 1; i <= radialSegments; i++) {
                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
                    var b = (radialSegments + 1) * j + (i - 1);
                    var c = (radialSegments + 1) * j + i;
                    var d = (radialSegments + 1) * (j - 1) + i;
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                }
            }
        }
        function generateUVs() {
            for (i = 0; i <= tubularSegments; i++) {
                for (j = 0; j <= radialSegments; j++) {
                    uv.x = i / tubularSegments;
                    uv.y = j / radialSegments;
                    uvs.push(uv.x, uv.y);
                }
            }
        }
    }
    TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
        Geometry.call(this);
        this.type = 'TorusKnotGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
        if (heightScale !== undefined)
            console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
        this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
        this.mergeVertices();
    }
    TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
    function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
        BufferGeometry.call(this);
        this.type = 'TorusKnotBufferGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
        radius = radius || 1;
        tube = tube || 0.4;
        tubularSegments = Math.floor(tubularSegments) || 64;
        radialSegments = Math.floor(radialSegments) || 8;
        p = p || 2;
        q = q || 3;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var i, j;
        var vertex = new Vector3();
        var normal = new Vector3();
        var P1 = new Vector3();
        var P2 = new Vector3();
        var B = new Vector3();
        var T = new Vector3();
        var N = new Vector3();
        for (i = 0; i <= tubularSegments; ++i) {
            var u = i / tubularSegments * p * Math.PI * 2;
            calculatePositionOnCurve(u, p, q, radius, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            B.normalize();
            N.normalize();
            for (j = 0; j <= radialSegments; ++j) {
                var v = j / radialSegments * Math.PI * 2;
                var cx = -tube * Math.cos(v);
                var cy = tube * Math.sin(v);
                vertex.x = P1.x + (cx * N.x + cy * B.x);
                vertex.y = P1.y + (cx * N.y + cy * B.y);
                vertex.z = P1.z + (cx * N.z + cy * B.z);
                vertices.push(vertex.x, vertex.y, vertex.z);
                normal.subVectors(vertex, P1).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }
        for (j = 1; j <= tubularSegments; j++) {
            for (i = 1; i <= radialSegments; i++) {
                var a = (radialSegments + 1) * (j - 1) + (i - 1);
                var b = (radialSegments + 1) * j + (i - 1);
                var c = (radialSegments + 1) * j + i;
                var d = (radialSegments + 1) * (j - 1) + i;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
        function calculatePositionOnCurve(u, p, q, radius, position) {
            var cu = Math.cos(u);
            var su = Math.sin(u);
            var quOverP = q / p * u;
            var cs = Math.cos(quOverP);
            position.x = radius * (2 + cs) * 0.5 * cu;
            position.y = radius * (2 + cs) * su * 0.5;
            position.z = radius * Math.sin(quOverP) * 0.5;
        }
    }
    TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        Geometry.call(this);
        this.type = 'TorusGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
        this.mergeVertices();
    }
    TorusGeometry.prototype = Object.create(Geometry.prototype);
    TorusGeometry.prototype.constructor = TorusGeometry;
    function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
        BufferGeometry.call(this);
        this.type = 'TorusBufferGeometry';
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
        radius = radius || 1;
        tube = tube || 0.4;
        radialSegments = Math.floor(radialSegments) || 8;
        tubularSegments = Math.floor(tubularSegments) || 6;
        arc = arc || Math.PI * 2;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var center = new Vector3();
        var vertex = new Vector3();
        var normal = new Vector3();
        var j, i;
        for (j = 0; j <= radialSegments; j++) {
            for (i = 0; i <= tubularSegments; i++) {
                var u = i / tubularSegments * arc;
                var v = j / radialSegments * Math.PI * 2;
                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                vertex.z = tube * Math.sin(v);
                vertices.push(vertex.x, vertex.y, vertex.z);
                center.x = radius * Math.cos(u);
                center.y = radius * Math.sin(u);
                normal.subVectors(vertex, center).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(i / tubularSegments);
                uvs.push(j / radialSegments);
            }
        }
        for (j = 1; j <= radialSegments; j++) {
            for (i = 1; i <= tubularSegments; i++) {
                var a = (tubularSegments + 1) * j + i - 1;
                var b = (tubularSegments + 1) * (j - 1) + i - 1;
                var c = (tubularSegments + 1) * (j - 1) + i;
                var d = (tubularSegments + 1) * j + i;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
    var Earcut = {
        triangulate: function (data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length
                , outerLen = hasHoles ? holeIndices[0] * dim : data.length
                , outerNode = linkedList(data, 0, outerLen, dim, true)
                , triangles = [];
            if (!outerNode)
                return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles)
                outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                    x = data[i];
                    y = data[i + 1];
                    if (x < minX)
                        minX = x;
                    if (y < minY)
                        minY = y;
                    if (x > maxX)
                        maxX = x;
                    if (y > maxY)
                        maxY = y;
                }
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
        }
    };
    function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === (signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim)
                last = insertNode(i, data[i], data[i + 1], last);
        } else {
            for (i = end - dim; i >= start; i -= dim)
                last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
            removeNode(last);
            last = last.next;
        }
        return last;
    }
    function filterPoints(start, end) {
        if (!start)
            return start;
        if (!end)
            end = start;
        var p = start, again;
        do {
            again = false;
            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                removeNode(p);
                p = end = p.prev;
                if (p === p.next)
                    break;
                again = true;
            } else {
                p = p.next;
            }
        } while (again || p !== end); return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
            return;
        if (!pass && invSize)
            indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                removeNode(ear);
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            if (ear === stop) {
                if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                } else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
            }
        }
    }
    function isEar(ear) {
        var a = ear.prev
            , b = ear
            , c = ear.next;
        if (area(a, b, c) >= 0)
            return false;
        var p = ear.next.next;
        while (p !== ear.prev) {
            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.next;
        }
        return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev
            , b = ear
            , c = ear.next;
        if (area(a, b, c) >= 0)
            return false;
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x)
            , minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y)
            , maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x)
            , maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        var minZ = zOrder(minTX, minTY, minX, minY, invSize)
            , maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.nextZ;
        while (p && p.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
                return false;
            p = p.nextZ;
        }
        p = ear.prevZ;
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
                return false;
            p = p.prevZ;
        }
        return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev
                , b = p.next.next;
            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                removeNode(p);
                removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start); return p;
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && isValidDiagonal(a, b)) {
                    var c = splitPolygon(a, b);
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    earcutLinked(a, triangles, dim, minX, minY, invSize);
                    earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0,
            len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = linkedList(data, start, end, dim, false);
            if (list === list.next)
                list.steiner = true;
            queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
            eliminateHole(queue[i], outerNode);
            outerNode = filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }
    function compareX(a, b) {
        return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
        outerNode = findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = splitPolygon(outerNode, hole);
            filterPoints(b, b.next);
        }
    }
    function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y)
                            return p;
                        if (hy === p.next.y)
                            return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode); if (!m)
            return null;
        if (hx === qx)
            return m.prev;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m.next;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x);
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }
        return m;
    }
    function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null)
                p.z = zOrder(p.x, p.y, minX, minY, invSize);
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start); p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
    }
    function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q)
                        break;
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    } else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail)
                        tail.nextZ = e;
                    else
                        list = e;
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        } while (numMerges > 1); return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    function getLeftmost(start) {
        var p = start
            , leftmost = start;
        do {
            if (p.x < leftmost.x)
                leftmost = p;
            p = p.next;
        } while (p !== start); return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }
    function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
        if ((equals(p1, q1) && equals(p2, q2)) || (equals(p1, q2) && equals(p2, q1)))
            return true;
        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }
    function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
                return true;
            }
            p = p.next;
        } while (p !== a); return false;
    }
    function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
        var p = a
            , inside = false
            , px = (a.x + b.x) / 2
            , py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
                inside = !inside;
            }
            p = p.next;
        } while (p !== a); return inside;
    }
    function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y)
            , b2 = new Node(b.i, b.x, b.y)
            , an = a.next
            , bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }
    function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        } else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
            p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
            p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
        this.i = i;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
    }
    function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    var ShapeUtils = {
        area: function (contour) {
            var n = contour.length;
            var a = 0.0;
            for (var p = n - 1, q = 0; q < n; p = q++) {
                a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
            }
            return a * 0.5;
        },
        isClockWise: function (pts) {
            return ShapeUtils.area(pts) < 0;
        },
        triangulateShape: function (contour, holes) {
            var vertices = [];
            var holeIndices = [];
            var faces = [];
            removeDupEndPts(contour);
            addContour(vertices, contour);
            var holeIndex = contour.length;
            holes.forEach(removeDupEndPts);
            for (var i = 0; i < holes.length; i++) {
                holeIndices.push(holeIndex);
                holeIndex += holes[i].length;
                addContour(vertices, holes[i]);
            }
            var triangles = Earcut.triangulate(vertices, holeIndices);
            for (var i = 0; i < triangles.length; i += 3) {
                faces.push(triangles.slice(i, i + 3));
            }
            return faces;
        }
    };
    function removeDupEndPts(points) {
        var l = points.length;
        if (l > 2 && points[l - 1].equals(points[0])) {
            points.pop();
        }
    }
    function addContour(vertices, contour) {
        for (var i = 0; i < contour.length; i++) {
            vertices.push(contour[i].x);
            vertices.push(contour[i].y);
        }
    }
    function ExtrudeGeometry(shapes, options) {
        Geometry.call(this);
        this.type = 'ExtrudeGeometry';
        this.parameters = {
            shapes: shapes,
            options: options
        };
        this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
        this.mergeVertices();
    }
    ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
    ExtrudeGeometry.prototype.toJSON = function () {
        var data = Geometry.prototype.toJSON.call(this);
        var shapes = this.parameters.shapes;
        var options = this.parameters.options;
        return toJSON(shapes, options, data);
    }
        ;
    function ExtrudeBufferGeometry(shapes, options) {
        BufferGeometry.call(this);
        this.type = 'ExtrudeBufferGeometry';
        this.parameters = {
            shapes: shapes,
            options: options
        };
        shapes = Array.isArray(shapes) ? shapes : [shapes];
        var scope = this;
        var verticesArray = [];
        var uvArray = [];
        for (var i = 0, l = shapes.length; i < l; i++) {
            var shape = shapes[i];
            addShape(shape);
        }
        this.addAttribute('position', new Float32BufferAttribute(verticesArray, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvArray, 2));
        this.computeVertexNormals();
        function addShape(shape) {
            var placeholder = [];
            var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
            var steps = options.steps !== undefined ? options.steps : 1;
            var depth = options.depth !== undefined ? options.depth : 100;
            var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
            var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
            var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
            var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
            var extrudePath = options.extrudePath;
            var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
            if (options.amount !== undefined) {
                console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
                depth = options.amount;
            }
            var extrudePts, extrudeByPath = false;
            var splineTube, binormal, normal, position2;
            if (extrudePath) {
                extrudePts = extrudePath.getSpacedPoints(steps);
                extrudeByPath = true;
                bevelEnabled = false;
                splineTube = extrudePath.computeFrenetFrames(steps, false);
                binormal = new Vector3();
                normal = new Vector3();
                position2 = new Vector3();
            }
            if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
            }
            var ahole, h, hl;
            var shapePoints = shape.extractPoints(curveSegments);
            var vertices = shapePoints.shape;
            var holes = shapePoints.holes;
            var reverse = !ShapeUtils.isClockWise(vertices);
            if (reverse) {
                vertices = vertices.reverse();
                for (h = 0,
                    hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    if (ShapeUtils.isClockWise(ahole)) {
                        holes[h] = ahole.reverse();
                    }
                }
            }
            var faces = ShapeUtils.triangulateShape(vertices, holes);
            var contour = vertices;
            for (h = 0,
                hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                vertices = vertices.concat(ahole);
            }
            function scalePt2(pt, vec, size) {
                if (!vec)
                    console.error("THREE.ExtrudeGeometry: vec does not exist");
                return vec.clone().multiplyScalar(size).add(pt);
            }
            var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
            function getBevelVec(inPt, inPrev, inNext) {
                var v_trans_x, v_trans_y, shrink_by;
                var v_prev_x = inPt.x - inPrev.x
                    , v_prev_y = inPt.y - inPrev.y;
                var v_next_x = inNext.x - inPt.x
                    , v_next_y = inNext.y - inPt.y;
                var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
                var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
                if (Math.abs(collinear0) > Number.EPSILON) {
                    var v_prev_len = Math.sqrt(v_prev_lensq);
                    var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                    var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                    var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
                    var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                    var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
                    var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                    v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
                    var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                    if (v_trans_lensq <= 2) {
                        return new Vector2(v_trans_x, v_trans_y);
                    } else {
                        shrink_by = Math.sqrt(v_trans_lensq / 2);
                    }
                } else {
                    var direction_eq = false;
                    if (v_prev_x > Number.EPSILON) {
                        if (v_next_x > Number.EPSILON) {
                            direction_eq = true;
                        }
                    } else {
                        if (v_prev_x < -Number.EPSILON) {
                            if (v_next_x < -Number.EPSILON) {
                                direction_eq = true;
                            }
                        } else {
                            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                                direction_eq = true;
                            }
                        }
                    }
                    if (direction_eq) {
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt(v_prev_lensq);
                    } else {
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt(v_prev_lensq / 2);
                    }
                }
                return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            var contourMovements = [];
            for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++ ,
                j++ ,
                k++) {
                if (j === il)
                    j = 0;
                if (k === il)
                    k = 0;
                contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
            }
            var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
            for (h = 0,
                hl = holes.length; h < hl; h++) {
                ahole = holes[h];
                oneHoleMovements = [];
                for (i = 0,
                    il = ahole.length,
                    j = il - 1,
                    k = i + 1; i < il; i++ ,
                    j++ ,
                    k++) {
                    if (j === il)
                        j = 0;
                    if (k === il)
                        k = 0;
                    oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            for (b = 0; b < bevelSegments; b++) {
                t = b / bevelSegments;
                z = bevelThickness * Math.cos(t * Math.PI / 2);
                bs = bevelSize * Math.sin(t * Math.PI / 2);
                for (i = 0,
                    il = contour.length; i < il; i++) {
                    vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert.x, vert.y, -z);
                }
                for (h = 0,
                    hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (i = 0,
                        il = ahole.length; i < il; i++) {
                        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                        v(vert.x, vert.y, -z);
                    }
                }
            }
            bs = bevelSize;
            for (i = 0; i < vlen; i++) {
                vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                if (!extrudeByPath) {
                    v(vert.x, vert.y, 0);
                } else {
                    normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[0]).add(normal).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            var s;
            for (s = 1; s <= steps; s++) {
                for (i = 0; i < vlen; i++) {
                    vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                    if (!extrudeByPath) {
                        v(vert.x, vert.y, depth / steps * s);
                    } else {
                        normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                        position2.copy(extrudePts[s]).add(normal).add(binormal);
                        v(position2.x, position2.y, position2.z);
                    }
                }
            }
            for (b = bevelSegments - 1; b >= 0; b--) {
                t = b / bevelSegments;
                z = bevelThickness * Math.cos(t * Math.PI / 2);
                bs = bevelSize * Math.sin(t * Math.PI / 2);
                for (i = 0,
                    il = contour.length; i < il; i++) {
                    vert = scalePt2(contour[i], contourMovements[i], bs);
                    v(vert.x, vert.y, depth + z);
                }
                for (h = 0,
                    hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    oneHoleMovements = holesMovements[h];
                    for (i = 0,
                        il = ahole.length; i < il; i++) {
                        vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                        if (!extrudeByPath) {
                            v(vert.x, vert.y, depth + z);
                        } else {
                            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                        }
                    }
                }
            }
            buildLidFaces();
            buildSideFaces();
            function buildLidFaces() {
                var start = verticesArray.length / 3;
                if (bevelEnabled) {
                    var layer = 0;
                    var offset = vlen * layer;
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[2] + offset, face[1] + offset, face[0] + offset);
                    }
                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[0] + offset, face[1] + offset, face[2] + offset);
                    }
                } else {
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[2], face[1], face[0]);
                    }
                    for (i = 0; i < flen; i++) {
                        face = faces[i];
                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                    }
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            function buildSideFaces() {
                var start = verticesArray.length / 3;
                var layeroffset = 0;
                sidewalls(contour, layeroffset);
                layeroffset += contour.length;
                for (h = 0,
                    hl = holes.length; h < hl; h++) {
                    ahole = holes[h];
                    sidewalls(ahole, layeroffset);
                    layeroffset += ahole.length;
                }
                scope.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour, layeroffset) {
                var j, k;
                i = contour.length;
                while (--i >= 0) {
                    j = i;
                    k = i - 1;
                    if (k < 0)
                        k = contour.length - 1;
                    var s = 0
                        , sl = steps + bevelSegments * 2;
                    for (s = 0; s < sl; s++) {
                        var slen1 = vlen * s;
                        var slen2 = vlen * (s + 1);
                        var a = layeroffset + j + slen1
                            , b = layeroffset + k + slen1
                            , c = layeroffset + k + slen2
                            , d = layeroffset + j + slen2;
                        f4(a, b, c, d);
                    }
                }
            }
            function v(x, y, z) {
                placeholder.push(x);
                placeholder.push(y);
                placeholder.push(z);
            }
            function f3(a, b, c) {
                addVertex(a);
                addVertex(b);
                addVertex(c);
                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[2]);
            }
            function f4(a, b, c, d) {
                addVertex(a);
                addVertex(b);
                addVertex(d);
                addVertex(b);
                addVertex(c);
                addVertex(d);
                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs[0]);
                addUV(uvs[1]);
                addUV(uvs[3]);
                addUV(uvs[1]);
                addUV(uvs[2]);
                addUV(uvs[3]);
            }
            function addVertex(index) {
                verticesArray.push(placeholder[index * 3 + 0]);
                verticesArray.push(placeholder[index * 3 + 1]);
                verticesArray.push(placeholder[index * 3 + 2]);
            }
            function addUV(vector2) {
                uvArray.push(vector2.x);
                uvArray.push(vector2.y);
            }
        }
    }
    ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
    ExtrudeBufferGeometry.prototype.toJSON = function () {
        var data = BufferGeometry.prototype.toJSON.call(this);
        var shapes = this.parameters.shapes;
        var options = this.parameters.options;
        return toJSON(shapes, options, data);
    }
        ;
    var WorldUVGenerator = {
        generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
        },
        generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
            var a_x = vertices[indexA * 3];
            var a_y = vertices[indexA * 3 + 1];
            var a_z = vertices[indexA * 3 + 2];
            var b_x = vertices[indexB * 3];
            var b_y = vertices[indexB * 3 + 1];
            var b_z = vertices[indexB * 3 + 2];
            var c_x = vertices[indexC * 3];
            var c_y = vertices[indexC * 3 + 1];
            var c_z = vertices[indexC * 3 + 2];
            var d_x = vertices[indexD * 3];
            var d_y = vertices[indexD * 3 + 1];
            var d_z = vertices[indexD * 3 + 2];
            if (Math.abs(a_y - b_y) < 0.01) {
                return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
            } else {
                return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
            }
        }
    };
    function toJSON(shapes, options, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
                var shape = shapes[i];
                data.shapes.push(shape.uuid);
            }
        } else {
            data.shapes.push(shapes.uuid);
        }
        if (options.extrudePath !== undefined)
            data.options.extrudePath = options.extrudePath.toJSON();
        return data;
    }
    function TextGeometry(text, parameters) {
        Geometry.call(this);
        this.type = 'TextGeometry';
        this.parameters = {
            text: text,
            parameters: parameters
        };
        this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
        this.mergeVertices();
    }
    TextGeometry.prototype = Object.create(Geometry.prototype);
    TextGeometry.prototype.constructor = TextGeometry;
    function TextBufferGeometry(text, parameters) {
        parameters = parameters || {};
        var font = parameters.font;
        if (!(font && font.isFont)) {
            console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
            return new Geometry();
        }
        var shapes = font.generateShapes(text, parameters.size, parameters.curveSegments);
        parameters.depth = parameters.height !== undefined ? parameters.height : 50;
        if (parameters.bevelThickness === undefined)
            parameters.bevelThickness = 10;
        if (parameters.bevelSize === undefined)
            parameters.bevelSize = 8;
        if (parameters.bevelEnabled === undefined)
            parameters.bevelEnabled = false;
        ExtrudeBufferGeometry.call(this, shapes, parameters);
        this.type = 'TextBufferGeometry';
    }
    TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
    TextBufferGeometry.prototype.constructor = TextBufferGeometry;
    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'SphereGeometry';
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
        this.mergeVertices();
    }
    SphereGeometry.prototype = Object.create(Geometry.prototype);
    SphereGeometry.prototype.constructor = SphereGeometry;
    function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'SphereBufferGeometry';
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius = radius || 1;
        widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
        heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
        phiStart = phiStart !== undefined ? phiStart : 0;
        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
        var thetaEnd = thetaStart + thetaLength;
        var ix, iy;
        var index = 0;
        var grid = [];
        var vertex = new Vector3();
        var normal = new Vector3();
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        for (iy = 0; iy <= heightSegments; iy++) {
            var verticesRow = [];
            var v = iy / heightSegments;
            for (ix = 0; ix <= widthSegments; ix++) {
                var u = ix / widthSegments;
                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertices.push(vertex.x, vertex.y, vertex.z);
                normal.set(vertex.x, vertex.y, vertex.z).normalize();
                normals.push(normal.x, normal.y, normal.z);
                uvs.push(u, 1 - v);
                verticesRow.push(index++);
            }
            grid.push(verticesRow);
        }
        for (iy = 0; iy < heightSegments; iy++) {
            for (ix = 0; ix < widthSegments; ix++) {
                var a = grid[iy][ix + 1];
                var b = grid[iy][ix];
                var c = grid[iy + 1][ix];
                var d = grid[iy + 1][ix + 1];
                if (iy !== 0 || thetaStart > 0)
                    indices.push(a, b, d);
                if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                    indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
        this.mergeVertices();
    }
    RingGeometry.prototype = Object.create(Geometry.prototype);
    RingGeometry.prototype.constructor = RingGeometry;
    function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'RingBufferGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        innerRadius = innerRadius || 0.5;
        outerRadius = outerRadius || 1;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
        phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var segment;
        var radius = innerRadius;
        var radiusStep = ((outerRadius - innerRadius) / phiSegments);
        var vertex = new Vector3();
        var uv = new Vector2();
        var j, i;
        for (j = 0; j <= phiSegments; j++) {
            for (i = 0; i <= thetaSegments; i++) {
                segment = thetaStart + i / thetaSegments * thetaLength;
                vertex.x = radius * Math.cos(segment);
                vertex.y = radius * Math.sin(segment);
                vertices.push(vertex.x, vertex.y, vertex.z);
                normals.push(0, 0, 1);
                uv.x = (vertex.x / outerRadius + 1) / 2;
                uv.y = (vertex.y / outerRadius + 1) / 2;
                uvs.push(uv.x, uv.y);
            }
            radius += radiusStep;
        }
        for (j = 0; j < phiSegments; j++) {
            var thetaSegmentLevel = j * (thetaSegments + 1);
            for (i = 0; i < thetaSegments; i++) {
                segment = i + thetaSegmentLevel;
                var a = segment;
                var b = segment + thetaSegments + 1;
                var c = segment + thetaSegments + 2;
                var d = segment + 1;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;
    function LatheGeometry(points, segments, phiStart, phiLength) {
        Geometry.call(this);
        this.type = 'LatheGeometry';
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
        this.mergeVertices();
    }
    LatheGeometry.prototype = Object.create(Geometry.prototype);
    LatheGeometry.prototype.constructor = LatheGeometry;
    function LatheBufferGeometry(points, segments, phiStart, phiLength) {
        BufferGeometry.call(this);
        this.type = 'LatheBufferGeometry';
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
        segments = Math.floor(segments) || 12;
        phiStart = phiStart || 0;
        phiLength = phiLength || Math.PI * 2;
        phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
        var indices = [];
        var vertices = [];
        var uvs = [];
        var base;
        var inverseSegments = 1.0 / segments;
        var vertex = new Vector3();
        var uv = new Vector2();
        var i, j;
        for (i = 0; i <= segments; i++) {
            var phi = phiStart + i * inverseSegments * phiLength;
            var sin = Math.sin(phi);
            var cos = Math.cos(phi);
            for (j = 0; j <= (points.length - 1); j++) {
                vertex.x = points[j].x * sin;
                vertex.y = points[j].y;
                vertex.z = points[j].x * cos;
                vertices.push(vertex.x, vertex.y, vertex.z);
                uv.x = i / segments;
                uv.y = j / (points.length - 1);
                uvs.push(uv.x, uv.y);
            }
        }
        for (i = 0; i < segments; i++) {
            for (j = 0; j < (points.length - 1); j++) {
                base = j + i * points.length;
                var a = base;
                var b = base + points.length;
                var c = base + points.length + 1;
                var d = base + 1;
                indices.push(a, b, d);
                indices.push(b, c, d);
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
        this.computeVertexNormals();
        if (phiLength === Math.PI * 2) {
            var normals = this.attributes.normal.array;
            var n1 = new Vector3();
            var n2 = new Vector3();
            var n = new Vector3();
            base = segments * points.length * 3;
            for (i = 0,
                j = 0; i < points.length; i++ ,
                j += 3) {
                n1.x = normals[j + 0];
                n1.y = normals[j + 1];
                n1.z = normals[j + 2];
                n2.x = normals[base + j + 0];
                n2.y = normals[base + j + 1];
                n2.z = normals[base + j + 2];
                n.addVectors(n1, n2).normalize();
                normals[j + 0] = normals[base + j + 0] = n.x;
                normals[j + 1] = normals[base + j + 1] = n.y;
                normals[j + 2] = normals[base + j + 2] = n.z;
            }
        }
    }
    LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
    function ShapeGeometry(shapes, curveSegments) {
        Geometry.call(this);
        this.type = 'ShapeGeometry';
        if (typeof curveSegments === 'object') {
            console.warn('THREE.ShapeGeometry: Options parameter has been removed.');
            curveSegments = curveSegments.curveSegments;
        }
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
        this.mergeVertices();
    }
    ShapeGeometry.prototype = Object.create(Geometry.prototype);
    ShapeGeometry.prototype.constructor = ShapeGeometry;
    ShapeGeometry.prototype.toJSON = function () {
        var data = Geometry.prototype.toJSON.call(this);
        var shapes = this.parameters.shapes;
        return toJSON$1(shapes, data);
    }
        ;
    function ShapeBufferGeometry(shapes, curveSegments) {
        BufferGeometry.call(this);
        this.type = 'ShapeBufferGeometry';
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
        curveSegments = curveSegments || 12;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var groupStart = 0;
        var groupCount = 0;
        if (Array.isArray(shapes) === false) {
            addShape(shapes);
        } else {
            for (var i = 0; i < shapes.length; i++) {
                addShape(shapes[i]);
                this.addGroup(groupStart, groupCount, i);
                groupStart += groupCount;
                groupCount = 0;
            }
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
        function addShape(shape) {
            var i, l, shapeHole;
            var indexOffset = vertices.length / 3;
            var points = shape.extractPoints(curveSegments);
            var shapeVertices = points.shape;
            var shapeHoles = points.holes;
            if (ShapeUtils.isClockWise(shapeVertices) === false) {
                shapeVertices = shapeVertices.reverse();
                for (i = 0,
                    l = shapeHoles.length; i < l; i++) {
                    shapeHole = shapeHoles[i];
                    if (ShapeUtils.isClockWise(shapeHole) === true) {
                        shapeHoles[i] = shapeHole.reverse();
                    }
                }
            }
            var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
            for (i = 0,
                l = shapeHoles.length; i < l; i++) {
                shapeHole = shapeHoles[i];
                shapeVertices = shapeVertices.concat(shapeHole);
            }
            for (i = 0,
                l = shapeVertices.length; i < l; i++) {
                var vertex = shapeVertices[i];
                vertices.push(vertex.x, vertex.y, 0);
                normals.push(0, 0, 1);
                uvs.push(vertex.x, vertex.y);
            }
            for (i = 0,
                l = faces.length; i < l; i++) {
                var face = faces[i];
                var a = face[0] + indexOffset;
                var b = face[1] + indexOffset;
                var c = face[2] + indexOffset;
                indices.push(a, b, c);
                groupCount += 3;
            }
        }
    }
    ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
    ShapeBufferGeometry.prototype.toJSON = function () {
        var data = BufferGeometry.prototype.toJSON.call(this);
        var shapes = this.parameters.shapes;
        return toJSON$1(shapes, data);
    }
        ;
    function toJSON$1(shapes, data) {
        data.shapes = [];
        if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
                var shape = shapes[i];
                data.shapes.push(shape.uuid);
            }
        } else {
            data.shapes.push(shapes.uuid);
        }
        return data;
    }
    function EdgesGeometry(geometry, thresholdAngle) {
        BufferGeometry.call(this);
        this.type = 'EdgesGeometry';
        this.parameters = {
            thresholdAngle: thresholdAngle
        };
        thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;
        var vertices = [];
        var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
        var edge = [0, 0], edges = {}, edge1, edge2;
        var key, keys = ['a', 'b', 'c'];
        var geometry2;
        if (geometry.isBufferGeometry) {
            geometry2 = new Geometry();
            geometry2.fromBufferGeometry(geometry);
        } else {
            geometry2 = geometry.clone();
        }
        geometry2.mergeVertices();
        geometry2.computeFaceNormals();
        var sourceVertices = geometry2.vertices;
        var faces = geometry2.faces;
        for (var i = 0, l = faces.length; i < l; i++) {
            var face = faces[i];
            for (var j = 0; j < 3; j++) {
                edge1 = face[keys[j]];
                edge2 = face[keys[(j + 1) % 3]];
                edge[0] = Math.min(edge1, edge2);
                edge[1] = Math.max(edge1, edge2);
                key = edge[0] + ',' + edge[1];
                if (edges[key] === undefined) {
                    edges[key] = {
                        index1: edge[0],
                        index2: edge[1],
                        face1: i,
                        face2: undefined
                    };
                } else {
                    edges[key].face2 = i;
                }
            }
        }
        for (key in edges) {
            var e = edges[key];
            if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
                var vertex = sourceVertices[e.index1];
                vertices.push(vertex.x, vertex.y, vertex.z);
                vertex = sourceVertices[e.index2];
                vertices.push(vertex.x, vertex.y, vertex.z);
            }
        }
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
    }
    EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
    EdgesGeometry.prototype.constructor = EdgesGeometry;
    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'CylinderGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
        this.mergeVertices();
    }
    CylinderGeometry.prototype = Object.create(Geometry.prototype);
    CylinderGeometry.prototype.constructor = CylinderGeometry;
    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'CylinderBufferGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        var scope = this;
        radiusTop = radiusTop !== undefined ? radiusTop : 1;
        radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
        height = height || 1;
        radialSegments = Math.floor(radialSegments) || 8;
        heightSegments = Math.floor(heightSegments) || 1;
        openEnded = openEnded !== undefined ? openEnded : false;
        thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var index = 0;
        var indexArray = [];
        var halfHeight = height / 2;
        var groupStart = 0;
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0)
                generateCap(true);
            if (radiusBottom > 0)
                generateCap(false);
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
        function generateTorso() {
            var x, y;
            var normal = new Vector3();
            var vertex = new Vector3();
            var groupCount = 0;
            var slope = (radiusBottom - radiusTop) / height;
            for (y = 0; y <= heightSegments; y++) {
                var indexRow = [];
                var v = y / heightSegments;
                var radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments;
                    var theta = u * thetaLength + thetaStart;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta);
                    vertex.x = radius * sinTheta;
                    vertex.y = -v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    normal.set(sinTheta, slope, cosTheta).normalize();
                    normals.push(normal.x, normal.y, normal.z);
                    uvs.push(u, 1 - v);
                    indexRow.push(index++);
                }
                indexArray.push(indexRow);
            }
            for (x = 0; x < radialSegments; x++) {
                for (y = 0; y < heightSegments; y++) {
                    var a = indexArray[y][x];
                    var b = indexArray[y + 1][x];
                    var c = indexArray[y + 1][x + 1];
                    var d = indexArray[y][x + 1];
                    indices.push(a, b, d);
                    indices.push(b, c, d);
                    groupCount += 6;
                }
            }
            scope.addGroup(groupStart, groupCount, 0);
            groupStart += groupCount;
        }
        function generateCap(top) {
            var x, centerIndexStart, centerIndexEnd;
            var uv = new Vector2();
            var vertex = new Vector3();
            var groupCount = 0;
            var radius = (top === true) ? radiusTop : radiusBottom;
            var sign = (top === true) ? 1 : -1;
            centerIndexStart = index;
            for (x = 1; x <= radialSegments; x++) {
                vertices.push(0, halfHeight * sign, 0);
                normals.push(0, sign, 0);
                uvs.push(0.5, 0.5);
                index++;
            }
            centerIndexEnd = index;
            for (x = 0; x <= radialSegments; x++) {
                var u = x / radialSegments;
                var theta = u * thetaLength + thetaStart;
                var cosTheta = Math.cos(theta);
                var sinTheta = Math.sin(theta);
                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.push(vertex.x, vertex.y, vertex.z);
                normals.push(0, sign, 0);
                uv.x = (cosTheta * 0.5) + 0.5;
                uv.y = (sinTheta * 0.5 * sign) + 0.5;
                uvs.push(uv.x, uv.y);
                index++;
            }
            for (x = 0; x < radialSegments; x++) {
                var c = centerIndexStart + x;
                var i = centerIndexEnd + x;
                if (top === true) {
                    indices.push(i, i + 1, c);
                } else {
                    indices.push(i + 1, i, c);
                }
                groupCount += 3;
            }
            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
            groupStart += groupCount;
        }
    }
    CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = 'ConeGeometry';
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
    ConeGeometry.prototype.constructor = ConeGeometry;
    function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
        CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = 'ConeBufferGeometry';
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    }
    ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
        Geometry.call(this);
        this.type = 'CircleGeometry';
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
        this.mergeVertices();
    }
    CircleGeometry.prototype = Object.create(Geometry.prototype);
    CircleGeometry.prototype.constructor = CircleGeometry;
    function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
        BufferGeometry.call(this);
        this.type = 'CircleBufferGeometry';
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius = radius || 1;
        segments = segments !== undefined ? Math.max(3, segments) : 8;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
        var i, s;
        var vertex = new Vector3();
        var uv = new Vector2();
        vertices.push(0, 0, 0);
        normals.push(0, 0, 1);
        uvs.push(0.5, 0.5);
        for (s = 0,
            i = 3; s <= segments; s++ ,
            i += 3) {
            var segment = thetaStart + s / segments * thetaLength;
            vertex.x = radius * Math.cos(segment);
            vertex.y = radius * Math.sin(segment);
            vertices.push(vertex.x, vertex.y, vertex.z);
            normals.push(0, 0, 1);
            uv.x = (vertices[i] / radius + 1) / 2;
            uv.y = (vertices[i + 1] / radius + 1) / 2;
            uvs.push(uv.x, uv.y);
        }
        for (i = 1; i <= segments; i++) {
            indices.push(i, i + 1, 0);
        }
        this.setIndex(indices);
        this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
        this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
    }
    CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
    var Geometries = Object.freeze({
        WireframeGeometry: WireframeGeometry,
        ParametricGeometry: ParametricGeometry,
        ParametricBufferGeometry: ParametricBufferGeometry,
        TetrahedronGeometry: TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronBufferGeometry,
        OctahedronGeometry: OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronBufferGeometry,
        IcosahedronGeometry: IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronBufferGeometry,
        DodecahedronGeometry: DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronBufferGeometry,
        PolyhedronGeometry: PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronBufferGeometry,
        TubeGeometry: TubeGeometry,
        TubeBufferGeometry: TubeBufferGeometry,
        TorusKnotGeometry: TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotBufferGeometry,
        TorusGeometry: TorusGeometry,
        TorusBufferGeometry: TorusBufferGeometry,
        TextGeometry: TextGeometry,
        TextBufferGeometry: TextBufferGeometry,
        SphereGeometry: SphereGeometry,
        SphereBufferGeometry: SphereBufferGeometry,
        RingGeometry: RingGeometry,
        RingBufferGeometry: RingBufferGeometry,
        PlaneGeometry: PlaneGeometry,
        PlaneBufferGeometry: PlaneBufferGeometry,
        LatheGeometry: LatheGeometry,
        LatheBufferGeometry: LatheBufferGeometry,
        ShapeGeometry: ShapeGeometry,
        ShapeBufferGeometry: ShapeBufferGeometry,
        ExtrudeGeometry: ExtrudeGeometry,
        ExtrudeBufferGeometry: ExtrudeBufferGeometry,
        EdgesGeometry: EdgesGeometry,
        ConeGeometry: ConeGeometry,
        ConeBufferGeometry: ConeBufferGeometry,
        CylinderGeometry: CylinderGeometry,
        CylinderBufferGeometry: CylinderBufferGeometry,
        CircleGeometry: CircleGeometry,
        CircleBufferGeometry: CircleBufferGeometry,
        BoxGeometry: BoxGeometry,
        BoxBufferGeometry: BoxBufferGeometry
    });
    function ShadowMaterial(parameters) {
        Material.call(this);
        this.type = 'ShadowMaterial';
        this.color = new Color(0x000000);
        this.transparent = true;
        this.setValues(parameters);
    }
    ShadowMaterial.prototype = Object.create(Material.prototype);
    ShadowMaterial.prototype.constructor = ShadowMaterial;
    ShadowMaterial.prototype.isShadowMaterial = true;
    ShadowMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        return this;
    }
        ;
    function RawShaderMaterial(parameters) {
        ShaderMaterial.call(this, parameters);
        this.type = 'RawShaderMaterial';
    }
    RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;
    RawShaderMaterial.prototype.isRawShaderMaterial = true;
    function MeshStandardMaterial(parameters) {
        Material.call(this);
        this.defines = {
            'STANDARD': ''
        };
        this.type = 'MeshStandardMaterial';
        this.color = new Color(0xffffff);
        this.roughness = 0.5;
        this.metalness = 0.5;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1.0;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshStandardMaterial.prototype = Object.create(Material.prototype);
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    MeshStandardMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.defines = {
            'STANDARD': ''
        };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    }
        ;
    function MeshPhysicalMaterial(parameters) {
        MeshStandardMaterial.call(this);
        this.defines = {
            'PHYSICAL': ''
        };
        this.type = 'MeshPhysicalMaterial';
        this.reflectivity = 0.5;
        this.clearCoat = 0.0;
        this.clearCoatRoughness = 0.0;
        this.setValues(parameters);
    }
    MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    MeshPhysicalMaterial.prototype.copy = function (source) {
        MeshStandardMaterial.prototype.copy.call(this, source);
        this.defines = {
            'PHYSICAL': ''
        };
        this.reflectivity = source.reflectivity;
        this.clearCoat = source.clearCoat;
        this.clearCoatRoughness = source.clearCoatRoughness;
        return this;
    }
        ;
    function MeshPhongMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshPhongMaterial';
        this.color = new Color(0xffffff);
        this.specular = new Color(0x111111);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshPhongMaterial.prototype = Object.create(Material.prototype);
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    MeshPhongMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    }
        ;
    function MeshToonMaterial(parameters) {
        MeshPhongMaterial.call(this);
        this.defines = {
            'TOON': ''
        };
        this.type = 'MeshToonMaterial';
        this.gradientMap = null;
        this.setValues(parameters);
    }
    MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
    MeshToonMaterial.prototype.constructor = MeshToonMaterial;
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    MeshToonMaterial.prototype.copy = function (source) {
        MeshPhongMaterial.prototype.copy.call(this, source);
        this.gradientMap = source.gradientMap;
        return this;
    }
        ;
    function MeshNormalMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshNormalMaterial';
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshNormalMaterial.prototype = Object.create(Material.prototype);
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    MeshNormalMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    }
        ;
    function MeshLambertMaterial(parameters) {
        Material.call(this);
        this.type = 'MeshLambertMaterial';
        this.color = new Color(0xffffff);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
        this.emissive = new Color(0x000000);
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters);
    }
    MeshLambertMaterial.prototype = Object.create(Material.prototype);
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    MeshLambertMaterial.prototype.copy = function (source) {
        Material.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    }
        ;
    function LineDashedMaterial(parameters) {
        LineBasicMaterial.call(this);
        this.type = 'LineDashedMaterial';
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters);
    }
    LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    LineDashedMaterial.prototype.copy = function (source) {
        LineBasicMaterial.prototype.copy.call(this, source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
    }
        ;
    var Materials = Object.freeze({
        ShadowMaterial: ShadowMaterial,
        SpriteMaterial: SpriteMaterial,
        RawShaderMaterial: RawShaderMaterial,
        ShaderMaterial: ShaderMaterial,
        PointsMaterial: PointsMaterial,
        MeshPhysicalMaterial: MeshPhysicalMaterial,
        MeshStandardMaterial: MeshStandardMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        MeshToonMaterial: MeshToonMaterial,
        MeshNormalMaterial: MeshNormalMaterial,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshDepthMaterial: MeshDepthMaterial,
        MeshDistanceMaterial: MeshDistanceMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        LineDashedMaterial: LineDashedMaterial,
        LineBasicMaterial: LineBasicMaterial,
        Material: Material
    });
    var Cache = {
        enabled: false,
        files: {},
        add: function (key, file) {
            if (this.enabled === false)
                return;
            this.files[key] = file;
        },
        get: function (key) {
            if (this.enabled === false)
                return;
            return this.files[key];
        },
        remove: function (key) {
            delete this.files[key];
        },
        clear: function () {
            this.files = {};
        }
    };
    function LoadingManager(onLoad, onProgress, onError) {
        var scope = this;
        var isLoading = false;
        var itemsLoaded = 0;
        var itemsTotal = 0;
        var urlModifier = undefined;
        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function (url) {
            itemsTotal++;
            if (isLoading === false) {
                if (scope.onStart !== undefined) {
                    scope.onStart(url, itemsLoaded, itemsTotal);
                }
            }
            isLoading = true;
        }
            ;
        this.itemEnd = function (url) {
            itemsLoaded++;
            if (scope.onProgress !== undefined) {
                scope.onProgress(url, itemsLoaded, itemsTotal);
            }
            if (itemsLoaded === itemsTotal) {
                isLoading = false;
                if (scope.onLoad !== undefined) {
                    scope.onLoad();
                }
            }
        }
            ;
        this.itemError = function (url) {
            if (scope.onError !== undefined) {
                scope.onError(url);
            }
        }
            ;
        this.resolveURL = function (url) {
            if (urlModifier) {
                return urlModifier(url);
            }
            return url;
        }
            ;
        this.setURLModifier = function (transform) {
            urlModifier = transform;
            return this;
        }
            ;
    }
    var DefaultLoadingManager = new LoadingManager();
    var loading = {};
    function FileLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(FileLoader.prototype, {
        load: function (url, onLoad, onProgress, onError) {
            if (url === undefined)
                url = '';
            if (this.path !== undefined)
                url = this.path + url;
            url = this.manager.resolveURL(url);
            var scope = this;
            var cached = Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function () {
                    if (onLoad)
                        onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            if (loading[url] !== undefined) {
                loading[url].push({
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                });
                return;
            }
            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
            var dataUriRegexResult = url.match(dataUriRegex);
            if (dataUriRegexResult) {
                var mimeType = dataUriRegexResult[1];
                var isBase64 = !!dataUriRegexResult[2];
                var data = dataUriRegexResult[3];
                data = window.decodeURIComponent(data);
                if (isBase64)
                    data = window.atob(data);
                try {
                    var response;
                    var responseType = (this.responseType || '').toLowerCase();
                    switch (responseType) {
                        case 'arraybuffer':
                        case 'blob':
                            var view = new Uint8Array(data.length);
                            for (var i = 0; i < data.length; i++) {
                                view[i] = data.charCodeAt(i);
                            }
                            if (responseType === 'blob') {
                                response = new Blob([view.buffer], {
                                    type: mimeType
                                });
                            } else {
                                response = view.buffer;
                            }
                            break;
                        case 'document':
                            var parser = new DOMParser();
                            response = parser.parseFromString(data, mimeType);
                            break;
                        case 'json':
                            response = JSON.parse(data);
                            break;
                        default:
                            response = data;
                            break;
                    }
                    window.setTimeout(function () {
                        if (onLoad)
                            onLoad(response);
                        scope.manager.itemEnd(url);
                    }, 0);
                } catch (error) {
                    window.setTimeout(function () {
                        if (onError)
                            onError(error);
                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url);
                    }, 0);
                }
            } else {
                loading[url] = [];
                loading[url].push({
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
                });
                var request = new XMLHttpRequest();
                request.open('GET', url, true);
                request.addEventListener('load', function (event) {
                    var response = this.response;
                    Cache.add(url, response);
                    var callbacks = loading[url];
                    delete loading[url];
                    if (this.status === 200 || this.status === 0) {
                        if (this.status === 0)
                            console.warn('THREE.FileLoader: HTTP Status 0 received.');
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            if (callback.onLoad)
                                callback.onLoad(response);
                        }
                        scope.manager.itemEnd(url);
                    } else {
                        for (var i = 0, il = callbacks.length; i < il; i++) {
                            var callback = callbacks[i];
                            if (callback.onError)
                                callback.onError(event);
                        }
                        scope.manager.itemEnd(url);
                        scope.manager.itemError(url);
                    }
                }, false);
                request.addEventListener('progress', function (event) {
                    var callbacks = loading[url];
                    for (var i = 0, il = callbacks.length; i < il; i++) {
                        var callback = callbacks[i];
                        if (callback.onProgress)
                            callback.onProgress(event);
                    }
                }, false);
                request.addEventListener('error', function (event) {
                    var callbacks = loading[url];
                    delete loading[url];
                    for (var i = 0, il = callbacks.length; i < il; i++) {
                        var callback = callbacks[i];
                        if (callback.onError)
                            callback.onError(event);
                    }
                    scope.manager.itemEnd(url);
                    scope.manager.itemError(url);
                }, false);
                if (this.responseType !== undefined)
                    request.responseType = this.responseType;
                if (this.withCredentials !== undefined)
                    request.withCredentials = this.withCredentials;
                if (request.overrideMimeType)
                    request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
                for (var header in this.requestHeader) {
                    request.setRequestHeader(header, this.requestHeader[header]);
                }
                request.send(null);
            }
            scope.manager.itemStart(url);
            return request;
        },
        setPath: function (value) {
            this.path = value;
            return this;
        },
        setResponseType: function (value) {
            this.responseType = value;
            return this;
        },
        setWithCredentials: function (value) {
            this.withCredentials = value;
            return this;
        },
        setMimeType: function (value) {
            this.mimeType = value;
            return this;
        },
        setRequestHeader: function (value) {
            this.requestHeader = value;
            return this;
        }
    });
    function CompressedTextureLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this._parser = null;
    }
    Object.assign(CompressedTextureLoader.prototype, {
        load: function (url, onLoad, onProgress, onError) {
            var scope = this;
            var images = [];
            var texture = new CompressedTexture();
            texture.image = images;
            var loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.setResponseType('arraybuffer');
            function loadTexture(i) {
                loader.load(url[i], function (buffer) {
                    var texDatas = scope._parser(buffer, true);
                    images[i] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };
                    loaded += 1;
                    if (loaded === 6) {
                        if (texDatas.mipmapCount === 1)
                            texture.minFilter = LinearFilter;
                        texture.format = texDatas.format;
                        texture.needsUpdate = true;
                        if (onLoad)
                            onLoad(texture);
                    }
                }, onProgress, onError);
            }
            if (Array.isArray(url)) {
                var loaded = 0;
                for (var i = 0, il = url.length; i < il; ++i) {
                    loadTexture(i);
                }
            } else {
                loader.load(url, function (buffer) {
                    var texDatas = scope._parser(buffer, true);
                    if (texDatas.isCubemap) {
                        var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                        for (var f = 0; f < faces; f++) {
                            images[f] = {
                                mipmaps: []
                            };
                            for (var i = 0; i < texDatas.mipmapCount; i++) {
                                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                images[f].format = texDatas.format;
                                images[f].width = texDatas.width;
                                images[f].height = texDatas.height;
                            }
                        }
                    } else {
                        texture.image.width = texDatas.width;
                        texture.image.height = texDatas.height;
                        texture.mipmaps = texDatas.mipmaps;
                    }
                    if (texDatas.mipmapCount === 1) {
                        texture.minFilter = LinearFilter;
                    }
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad)
                        onLoad(texture);
                }, onProgress, onError);
            }
            return texture;
        },
        setPath: function (value) {
            this.path = value;
            return this;
        }
    });
    function DataTextureLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this._parser = null;
    }
    Object.assign(DataTextureLoader.prototype, {
        load: function (url, onLoad, onProgress, onError) {
            var scope = this;
            var texture = new DataTexture();
            var loader = new FileLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.load(url, function (buffer) {
                var texData = scope._parser(buffer);
                if (!texData)
                    return;
                if (undefined !== texData.image) {
                    texture.image = texData.image;
                } else if (undefined !== texData.data) {
                    texture.image.width = texData.width;
                    texture.image.height = texData.height;
                    texture.image.data = texData.data;
                }
                texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
                texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
                texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
                texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
                texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
                if (undefined !== texData.format) {
                    texture.format = texData.format;
                }
                if (undefined !== texData.type) {
                    texture.type = texData.type;
                }
                if (undefined !== texData.mipmaps) {
                    texture.mipmaps = texData.mipmaps;
                }
                if (1 === texData.mipmapCount) {
                    texture.minFilter = LinearFilter;
                }
                texture.needsUpdate = true;
                if (onLoad)
                    onLoad(texture, texData);
            }, onProgress, onError);
            return texture;
        }
    });
    function ImageLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(ImageLoader.prototype, {
        crossOrigin: 'Anonymous',
        load: function (url, onLoad, onProgress, onError) {
            if (url === undefined)
                url = '';
            if (this.path !== undefined)
                url = this.path + url;
            url = this.manager.resolveURL(url);
            var scope = this;
            var cached = Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function () {
                    if (onLoad)
                        onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            var image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
            function onImageLoad() {
                image.removeEventListener('load', onImageLoad, false);
                image.removeEventListener('error', onImageError, false);
                Cache.add(url, this);
                if (onLoad)
                    onLoad(this);
                scope.manager.itemEnd(url);
            }
            function onImageError(event) {
                image.removeEventListener('load', onImageLoad, false);
                image.removeEventListener('error', onImageError, false);
                if (onError)
                    onError(event);
                scope.manager.itemEnd(url);
                scope.manager.itemError(url);
            }
            image.addEventListener('load', onImageLoad, false);
            image.addEventListener('error', onImageError, false);
            if (url.substr(0, 5) !== 'data:') {
                if (this.crossOrigin !== undefined)
                    image.crossOrigin = this.crossOrigin;
            }
            scope.manager.itemStart(url);
            image.src = url;
            return image;
        },
        setCrossOrigin: function (value) {
            this.crossOrigin = value;
            return this;
        },
        setPath: function (value) {
            this.path = value;
            return this;
        }
    });
    function CubeTextureLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(CubeTextureLoader.prototype, {
        crossOrigin: 'Anonymous',
        load: function (urls, onLoad, onProgress, onError) {
            var texture = new CubeTexture();
            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            var loaded = 0;
            function loadTexture(i) {
                loader.load(urls[i], function (image) {
                    texture.images[i] = image;
                    loaded++;
                    if (loaded === 6) {
                        texture.needsUpdate = true;
                        if (onLoad)
                            onLoad(texture);
                    }
                }, undefined, onError);
            }
            for (var i = 0; i < urls.length; ++i) {
                loadTexture(i);
            }
            return texture;
        },
        setCrossOrigin: function (value) {
            this.crossOrigin = value;
            return this;
        },
        setPath: function (value) {
            this.path = value;
            return this;
        }
    });
    function TextureLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(TextureLoader.prototype, {
        crossOrigin: 'Anonymous',
        load: function (url, onLoad, onProgress, onError) {
            var texture = new Texture();
            var loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            loader.setPath(this.path);
            loader.load(url, function (image) {
                texture.image = image;
                var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;
                texture.format = isJPEG ? RGBFormat : RGBAFormat;
                texture.needsUpdate = true;
                if (onLoad !== undefined) {
                    onLoad(texture);
                }
            }, onProgress, onError);
            return texture;
        },
        setCrossOrigin: function (value) {
            this.crossOrigin = value;
            return this;
        },
        setPath: function (value) {
            this.path = value;
            return this;
        }
    });
    function Curve() {
        this.type = 'Curve';
        this.arcLengthDivisions = 200;
    }
    Object.assign(Curve.prototype, {
        getPoint: function () {
            console.warn('THREE.Curve: .getPoint() not implemented.');
            return null;
        },
        getPointAt: function (u, optionalTarget) {
            var t = this.getUtoTmapping(u);
            return this.getPoint(t, optionalTarget);
        },
        getPoints: function (divisions) {
            if (divisions === undefined)
                divisions = 5;
            var points = [];
            for (var d = 0; d <= divisions; d++) {
                points.push(this.getPoint(d / divisions));
            }
            return points;
        },
        getSpacedPoints: function (divisions) {
            if (divisions === undefined)
                divisions = 5;
            var points = [];
            for (var d = 0; d <= divisions; d++) {
                points.push(this.getPointAt(d / divisions));
            }
            return points;
        },
        getLength: function () {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        },
        getLengths: function (divisions) {
            if (divisions === undefined)
                divisions = this.arcLengthDivisions;
            if (this.cacheArcLengths && (this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate) {
                return this.cacheArcLengths;
            }
            this.needsUpdate = false;
            var cache = [];
            var current, last = this.getPoint(0);
            var p, sum = 0;
            cache.push(0);
            for (p = 1; p <= divisions; p++) {
                current = this.getPoint(p / divisions);
                sum += current.distanceTo(last);
                cache.push(sum);
                last = current;
            }
            this.cacheArcLengths = cache;
            return cache;
        },
        updateArcLengths: function () {
            this.needsUpdate = true;
            this.getLengths();
        },
        getUtoTmapping: function (u, distance) {
            var arcLengths = this.getLengths();
            var i = 0
                , il = arcLengths.length;
            var targetArcLength;
            if (distance) {
                targetArcLength = distance;
            } else {
                targetArcLength = u * arcLengths[il - 1];
            }
            var low = 0, high = il - 1, comparison;
            while (low <= high) {
                i = Math.floor(low + (high - low) / 2);
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                    low = i + 1;
                } else if (comparison > 0) {
                    high = i - 1;
                } else {
                    high = i;
                    break;
                }
            }
            i = high;
            if (arcLengths[i] === targetArcLength) {
                return i / (il - 1);
            }
            var lengthBefore = arcLengths[i];
            var lengthAfter = arcLengths[i + 1];
            var segmentLength = lengthAfter - lengthBefore;
            var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
            var t = (i + segmentFraction) / (il - 1);
            return t;
        },
        getTangent: function (t) {
            var delta = 0.0001;
            var t1 = t - delta;
            var t2 = t + delta;
            if (t1 < 0)
                t1 = 0;
            if (t2 > 1)
                t2 = 1;
            var pt1 = this.getPoint(t1);
            var pt2 = this.getPoint(t2);
            var vec = pt2.clone().sub(pt1);
            return vec.normalize();
        },
        getTangentAt: function (u) {
            var t = this.getUtoTmapping(u);
            return this.getTangent(t);
        },
        computeFrenetFrames: function (segments, closed) {
            var normal = new Vector3();
            var tangents = [];
            var normals = [];
            var binormals = [];
            var vec = new Vector3();
            var mat = new Matrix4();
            var i, u, theta;
            for (i = 0; i <= segments; i++) {
                u = i / segments;
                tangents[i] = this.getTangentAt(u);
                tangents[i].normalize();
            }
            normals[0] = new Vector3();
            binormals[0] = new Vector3();
            var min = Number.MAX_VALUE;
            var tx = Math.abs(tangents[0].x);
            var ty = Math.abs(tangents[0].y);
            var tz = Math.abs(tangents[0].z);
            if (tx <= min) {
                min = tx;
                normal.set(1, 0, 0);
            }
            if (ty <= min) {
                min = ty;
                normal.set(0, 1, 0);
            }
            if (tz <= min) {
                normal.set(0, 0, 1);
            }
            vec.crossVectors(tangents[0], normal).normalize();
            normals[0].crossVectors(tangents[0], vec);
            binormals[0].crossVectors(tangents[0], normals[0]);
            for (i = 1; i <= segments; i++) {
                normals[i] = normals[i - 1].clone();
                binormals[i] = binormals[i - 1].clone();
                vec.crossVectors(tangents[i - 1], tangents[i]);
                if (vec.length() > Number.EPSILON) {
                    vec.normalize();
                    theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
                    normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                }
                binormals[i].crossVectors(tangents[i], normals[i]);
            }
            if (closed === true) {
                theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
                theta /= segments;
                if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                    theta = -theta;
                }
                for (i = 1; i <= segments; i++) {
                    normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                    binormals[i].crossVectors(tangents[i], normals[i]);
                }
            }
            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (source) {
            this.arcLengthDivisions = source.arcLengthDivisions;
            return this;
        },
        toJSON: function () {
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Curve',
                    generator: 'Curve.toJSON'
                }
            };
            data.arcLengthDivisions = this.arcLengthDivisions;
            data.type = this.type;
            return data;
        },
        fromJSON: function (json) {
            this.arcLengthDivisions = json.arcLengthDivisions;
            return this;
        }
    });
    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        Curve.call(this);
        this.type = 'EllipseCurve';
        this.aX = aX || 0;
        this.aY = aY || 0;
        this.xRadius = xRadius || 1;
        this.yRadius = yRadius || 1;
        this.aStartAngle = aStartAngle || 0;
        this.aEndAngle = aEndAngle || 2 * Math.PI;
        this.aClockwise = aClockwise || false;
        this.aRotation = aRotation || 0;
    }
    EllipseCurve.prototype = Object.create(Curve.prototype);
    EllipseCurve.prototype.constructor = EllipseCurve;
    EllipseCurve.prototype.isEllipseCurve = true;
    EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        var twoPi = Math.PI * 2;
        var deltaAngle = this.aEndAngle - this.aStartAngle;
        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        while (deltaAngle < 0)
            deltaAngle += twoPi;
        while (deltaAngle > twoPi)
            deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
            if (samePoints) {
                deltaAngle = 0;
            } else {
                deltaAngle = twoPi;
            }
        }
        if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) {
                deltaAngle = -twoPi;
            } else {
                deltaAngle = deltaAngle - twoPi;
            }
        }
        var angle = this.aStartAngle + t * deltaAngle;
        var x = this.aX + this.xRadius * Math.cos(angle);
        var y = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
            var cos = Math.cos(this.aRotation);
            var sin = Math.sin(this.aRotation);
            var tx = x - this.aX;
            var ty = y - this.aY;
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y);
    }
        ;
    EllipseCurve.prototype.copy = function (source) {
        Curve.prototype.copy.call(this, source);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
    }
        ;
    EllipseCurve.prototype.toJSON = function () {
        var data = Curve.prototype.toJSON.call(this);
        data.aX = this.aX;
        data.aY = this.aY;
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
        data.aClockwise = this.aClockwise;
        data.aRotation = this.aRotation;
        return data;
    }
        ;
    EllipseCurve.prototype.fromJSON = function (json) {
        Curve.prototype.fromJSON.call(this, json);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
    }
        ;
    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        this.type = 'ArcCurve';
    }
    ArcCurve.prototype = Object.create(EllipseCurve.prototype);
    ArcCurve.prototype.constructor = ArcCurve;
    ArcCurve.prototype.isArcCurve = true;
    function CubicPoly() {
        var c0 = 0
            , c1 = 0
            , c2 = 0
            , c3 = 0;
        function init(x0, x1, t0, t1) {
            c0 = x0;
            c1 = t0;
            c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
        }
        return {
            initCatmullRom: function (x0, x1, x2, x3, tension) {
                init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
            },
            initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
                var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                t1 *= dt1;
                t2 *= dt1;
                init(x1, x2, t1, t2);
            },
            calc: function (t) {
                var t2 = t * t;
                var t3 = t2 * t;
                return c0 + c1 * t + c2 * t2 + c3 * t3;
            }
        };
    }
    var tmp = new Vector3();
    var px = new CubicPoly()
        , py = new CubicPoly()
        , pz = new CubicPoly();
    function CatmullRomCurve3(points, closed, curveType, tension) {
        Curve.call(this);
        this.type = 'CatmullRomCurve3';
        this.points = points || [];
        this.closed = closed || false;
        this.curveType = curveType || 'centripetal';
        this.tension = tension || 0.5;
    }
    CatmullRomCurve3.prototype = Object.create(Curve.prototype);
    CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
    CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {
        var point = optionalTarget || new Vector3();
        var points = this.points;
        var l = points.length;
        var p = (l - (this.closed ? 0 : 1)) * t;
        var intPoint = Math.floor(p);
        var weight = p - intPoint;
        if (this.closed) {
            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
        } else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
        }
        var p0, p1, p2, p3;
        if (this.closed || intPoint > 0) {
            p0 = points[(intPoint - 1) % l];
        } else {
            tmp.subVectors(points[0], points[1]).add(points[0]);
            p0 = tmp;
        }
        p1 = points[intPoint % l];
        p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) {
            p3 = points[(intPoint + 2) % l];
        } else {
            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
            p3 = tmp;
        }
        if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
            var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
            var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
            var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
            var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
            if (dt1 < 1e-4)
                dt1 = 1.0;
            if (dt0 < 1e-4)
                dt0 = dt1;
            if (dt2 < 1e-4)
                dt2 = dt1;
            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.curveType === 'catmullrom') {
            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
        }
        point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
        return point;
    }
        ;
    CatmullRomCurve3.prototype.copy = function (source) {
        Curve.prototype.copy.call(this, source);
        this.points = [];
        for (var i = 0, l = source.points.length; i < l; i++) {
            var point = source.points[i];
            this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
    }
        ;
    CatmullRomCurve3.prototype.toJSON = function () {
        var data = Curve.prototype.toJSON.call(this);
        data.points = [];
        for (var i = 0, l = this.points.length; i < l; i++) {
            var point = this.points[i];
            data.points.push(point.toArray());
        }
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
        return data;
    }
        ;
    CatmullRomCurve3.prototype.fromJSON = function (json) {
        Curve.prototype.fromJSON.call(this, json);
        this.points = [];
        for (var i = 0, l = json.points.length; i < l; i++) {
            var point = json.points[i];
            this.points.push(new Vector3().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
    }
        ;
    function CatmullRom(t, p0, p1, p2, p3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function QuadraticBezierP0(t, p) {
        var k = 1 - t;
        return k * k * p;
    }
    function QuadraticBezierP1(t, p) {
        return 2 * (1 - t) * t * p;
    }
    function QuadraticBezierP2(t, p) {
        return t * t * p;
    }
    function QuadraticBezier(t, p0, p1, p2) {
        return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
    }
    function CubicBezierP0(t, p) {
        var k = 1 - t;
        return k * k * k * p;
    }
    function CubicBezierP1(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
    }
    function CubicBezierP2(t, p) {
        return 3 * (1 - t) * t * t * p;
    }
    function CubicBezierP3(t, p) {
        return t * t * t * p;
    }
    function CubicBezier(t, p0, p1, p2, p3) {
        return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
    }
    function CubicBezierCurve(v0, v1, v2, v3) {
        Curve.call(this);
        this.type = 'CubicBezierCurve';
        this.v0 = v0 || new Vector2();
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
        this.v3 = v3 || new Vector2();
    }
    CubicBezierCurve.prototype = Object.create(Curve.prototype);
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;
    CubicBezierCurve.prototype.isCubicBezierCurve = true;
    CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        var v0 = this.v0
            , v1 = this.v1
            , v2 = this.v2
            , v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
        return point;
    }
        ;
    CubicBezierCurve.prototype.copy = function (source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    }
        ;
    CubicBezierCurve.prototype.toJSON = function () {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
    }
        ;
    CubicBezierCurve.prototype.fromJSON = function (json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    }
        ;
    function CubicBezierCurve3(v0, v1, v2, v3) {
        Curve.call(this);
        this.type = 'CubicBezierCurve3';
        this.v0 = v0 || new Vector3();
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
        this.v3 = v3 || new Vector3();
    }
    CubicBezierCurve3.prototype = Object.create(Curve.prototype);
    CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
    CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
        var point = optionalTarget || new Vector3();
        var v0 = this.v0
            , v1 = this.v1
            , v2 = this.v2
            , v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
        return point;
    }
        ;
    CubicBezierCurve3.prototype.copy = function (source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    }
        ;
    CubicBezierCurve3.prototype.toJSON = function () {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
    }
        ;
    CubicBezierCurve3.prototype.fromJSON = function (json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    }
        ;
    function LineCurve(v1, v2) {
        Curve.call(this);
        this.type = 'LineCurve';
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
    }
    LineCurve.prototype = Object.create(Curve.prototype);
    LineCurve.prototype.constructor = LineCurve;
    LineCurve.prototype.isLineCurve = true;
    LineCurve.prototype.getPoint = function (t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        if (t === 1) {
            point.copy(this.v2);
        } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    }
        ;
    LineCurve.prototype.getPointAt = function (u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }
        ;
    LineCurve.prototype.getTangent = function () {
        var tangent = this.v2.clone().sub(this.v1);
        return tangent.normalize();
    }
        ;
    LineCurve.prototype.copy = function (source) {
        Curve.prototype.copy.call(this, source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
        ;
    LineCurve.prototype.toJSON = function () {
        var data = Curve.prototype.toJSON.call(this);
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
        ;
    LineCurve.prototype.fromJSON = function (json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
        ;
    function LineCurve3(v1, v2) {
        Curve.call(this);
        this.type = 'LineCurve3';
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
    }
    LineCurve3.prototype = Object.create(Curve.prototype);
    LineCurve3.prototype.constructor = LineCurve3;
    LineCurve3.prototype.isLineCurve3 = true;
    LineCurve3.prototype.getPoint = function (t, optionalTarget) {
        var point = optionalTarget || new Vector3();
        if (t === 1) {
            point.copy(this.v2);
        } else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    }
        ;
    LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }
        ;
    LineCurve3.prototype.copy = function (source) {
        Curve.prototype.copy.call(this, source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
        ;
    LineCurve3.prototype.toJSON = function () {
        var data = Curve.prototype.toJSON.call(this);
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
        ;
    LineCurve3.prototype.fromJSON = function (json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
        ;
    function QuadraticBezierCurve(v0, v1, v2) {
        Curve.call(this);
        this.type = 'QuadraticBezierCurve';
        this.v0 = v0 || new Vector2();
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
    }
    QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
    QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        var v0 = this.v0
            , v1 = this.v1
            , v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
        return point;
    }
        ;
    QuadraticBezierCurve.prototype.copy = function (source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
        ;
    QuadraticBezierCurve.prototype.toJSON = function () {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
        ;
    QuadraticBezierCurve.prototype.fromJSON = function (json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
        ;
    function QuadraticBezierCurve3(v0, v1, v2) {
        Curve.call(this);
        this.type = 'QuadraticBezierCurve3';
        this.v0 = v0 || new Vector3();
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
    }
    QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
    QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
    QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
        var point = optionalTarget || new Vector3();
        var v0 = this.v0
            , v1 = this.v1
            , v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
        return point;
    }
        ;
    QuadraticBezierCurve3.prototype.copy = function (source) {
        Curve.prototype.copy.call(this, source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
        ;
    QuadraticBezierCurve3.prototype.toJSON = function () {
        var data = Curve.prototype.toJSON.call(this);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
    }
        ;
    QuadraticBezierCurve3.prototype.fromJSON = function (json) {
        Curve.prototype.fromJSON.call(this, json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
        ;
    function SplineCurve(points) {
        Curve.call(this);
        this.type = 'SplineCurve';
        this.points = points || [];
    }
    SplineCurve.prototype = Object.create(Curve.prototype);
    SplineCurve.prototype.constructor = SplineCurve;
    SplineCurve.prototype.isSplineCurve = true;
    SplineCurve.prototype.getPoint = function (t, optionalTarget) {
        var point = optionalTarget || new Vector2();
        var points = this.points;
        var p = (points.length - 1) * t;
        var intPoint = Math.floor(p);
        var weight = p - intPoint;
        var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        var p1 = points[intPoint];
        var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
        return point;
    }
        ;
    SplineCurve.prototype.copy = function (source) {
        Curve.prototype.copy.call(this, source);
        this.points = [];
        for (var i = 0, l = source.points.length; i < l; i++) {
            var point = source.points[i];
            this.points.push(point.clone());
        }
        return this;
    }
        ;
    SplineCurve.prototype.toJSON = function () {
        var data = Curve.prototype.toJSON.call(this);
        data.points = [];
        for (var i = 0, l = this.points.length; i < l; i++) {
            var point = this.points[i];
            data.points.push(point.toArray());
        }
        return data;
    }
        ;
    SplineCurve.prototype.fromJSON = function (json) {
        Curve.prototype.fromJSON.call(this, json);
        this.points = [];
        for (var i = 0, l = json.points.length; i < l; i++) {
            var point = json.points[i];
            this.points.push(new Vector2().fromArray(point));
        }
        return this;
    }
        ;
    var Curves = Object.freeze({
        ArcCurve: ArcCurve,
        CatmullRomCurve3: CatmullRomCurve3,
        CubicBezierCurve: CubicBezierCurve,
        CubicBezierCurve3: CubicBezierCurve3,
        EllipseCurve: EllipseCurve,
        LineCurve: LineCurve,
        LineCurve3: LineCurve3,
        QuadraticBezierCurve: QuadraticBezierCurve,
        QuadraticBezierCurve3: QuadraticBezierCurve3,
        SplineCurve: SplineCurve
    });
    function CurvePath() {
        Curve.call(this);
        this.type = 'CurvePath';
        this.curves = [];
        this.autoClose = false;
    }
    CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
        constructor: CurvePath,
        add: function (curve) {
            this.curves.push(curve);
        },
        closePath: function () {
            var startPoint = this.curves[0].getPoint(0);
            var endPoint = this.curves[this.curves.length - 1].getPoint(1);
            if (!startPoint.equals(endPoint)) {
                this.curves.push(new LineCurve(endPoint, startPoint));
            }
        },
        getPoint: function (t) {
            var d = t * this.getLength();
            var curveLengths = this.getCurveLengths();
            var i = 0;
            while (i < curveLengths.length) {
                if (curveLengths[i] >= d) {
                    var diff = curveLengths[i] - d;
                    var curve = this.curves[i];
                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                    return curve.getPointAt(u);
                }
                i++;
            }
            return null;
        },
        getLength: function () {
            var lens = this.getCurveLengths();
            return lens[lens.length - 1];
        },
        updateArcLengths: function () {
            this.needsUpdate = true;
            this.cacheLengths = null;
            this.getCurveLengths();
        },
        getCurveLengths: function () {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                return this.cacheLengths;
            }
            var lengths = []
                , sums = 0;
            for (var i = 0, l = this.curves.length; i < l; i++) {
                sums += this.curves[i].getLength();
                lengths.push(sums);
            }
            this.cacheLengths = lengths;
            return lengths;
        },
        getSpacedPoints: function (divisions) {
            if (divisions === undefined)
                divisions = 40;
            var points = [];
            for (var i = 0; i <= divisions; i++) {
                points.push(this.getPoint(i / divisions));
            }
            if (this.autoClose) {
                points.push(points[0]);
            }
            return points;
        },
        getPoints: function (divisions) {
            divisions = divisions || 12;
            var points = [], last;
            for (var i = 0, curves = this.curves; i < curves.length; i++) {
                var curve = curves[i];
                var resolution = (curve && curve.isEllipseCurve) ? divisions * 2 : (curve && curve.isLineCurve) ? 1 : (curve && curve.isSplineCurve) ? divisions * curve.points.length : divisions;
                var pts = curve.getPoints(resolution);
                for (var j = 0; j < pts.length; j++) {
                    var point = pts[j];
                    if (last && last.equals(point))
                        continue;
                    points.push(point);
                    last = point;
                }
            }
            if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                points.push(points[0]);
            }
            return points;
        },
        copy: function (source) {
            Curve.prototype.copy.call(this, source);
            this.curves = [];
            for (var i = 0, l = source.curves.length; i < l; i++) {
                var curve = source.curves[i];
                this.curves.push(curve.clone());
            }
            this.autoClose = source.autoClose;
            return this;
        },
        toJSON: function () {
            var data = Curve.prototype.toJSON.call(this);
            data.autoClose = this.autoClose;
            data.curves = [];
            for (var i = 0, l = this.curves.length; i < l; i++) {
                var curve = this.curves[i];
                data.curves.push(curve.toJSON());
            }
            return data;
        },
        fromJSON: function (json) {
            Curve.prototype.fromJSON.call(this, json);
            this.autoClose = json.autoClose;
            this.curves = [];
            for (var i = 0, l = json.curves.length; i < l; i++) {
                var curve = json.curves[i];
                this.curves.push(new Curves[curve.type]().fromJSON(curve));
            }
            return this;
        }
    });
    function Path(points) {
        CurvePath.call(this);
        this.type = 'Path';
        this.currentPoint = new Vector2();
        if (points) {
            this.setFromPoints(points);
        }
    }
    Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
        constructor: Path,
        setFromPoints: function (points) {
            this.moveTo(points[0].x, points[0].y);
            for (var i = 1, l = points.length; i < l; i++) {
                this.lineTo(points[i].x, points[i].y);
            }
        },
        moveTo: function (x, y) {
            this.currentPoint.set(x, y);
        },
        lineTo: function (x, y) {
            var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
            this.curves.push(curve);
            this.currentPoint.set(x, y);
        },
        quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
            var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
        },
        bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
            this.curves.push(curve);
            this.currentPoint.set(aX, aY);
        },
        splineThru: function (pts) {
            var npts = [this.currentPoint.clone()].concat(pts);
            var curve = new SplineCurve(npts);
            this.curves.push(curve);
            this.currentPoint.copy(pts[pts.length - 1]);
        },
        arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
            this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        },
        ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
            this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        },
        absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
            var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
            if (this.curves.length > 0) {
                var firstPoint = curve.getPoint(0);
                if (!firstPoint.equals(this.currentPoint)) {
                    this.lineTo(firstPoint.x, firstPoint.y);
                }
            }
            this.curves.push(curve);
            var lastPoint = curve.getPoint(1);
            this.currentPoint.copy(lastPoint);
        },
        copy: function (source) {
            CurvePath.prototype.copy.call(this, source);
            this.currentPoint.copy(source.currentPoint);
            return this;
        },
        toJSON: function () {
            var data = CurvePath.prototype.toJSON.call(this);
            data.currentPoint = this.currentPoint.toArray();
            return data;
        },
        fromJSON: function (json) {
            CurvePath.prototype.fromJSON.call(this, json);
            this.currentPoint.fromArray(json.currentPoint);
            return this;
        }
    });
    function Shape(points) {
        Path.call(this, points);
        this.uuid = _Math.generateUUID();
        this.type = 'Shape';
        this.holes = [];
    }
    Shape.prototype = Object.assign(Object.create(Path.prototype), {
        constructor: Shape,
        getPointsHoles: function (divisions) {
            var holesPts = [];
            for (var i = 0, l = this.holes.length; i < l; i++) {
                holesPts[i] = this.holes[i].getPoints(divisions);
            }
            return holesPts;
        },
        extractPoints: function (divisions) {
            return {
                shape: this.getPoints(divisions),
                holes: this.getPointsHoles(divisions)
            };
        },
        copy: function (source) {
            Path.prototype.copy.call(this, source);
            this.holes = [];
            for (var i = 0, l = source.holes.length; i < l; i++) {
                var hole = source.holes[i];
                this.holes.push(hole.clone());
            }
            return this;
        },
        toJSON: function () {
            var data = Path.prototype.toJSON.call(this);
            data.uuid = this.uuid;
            data.holes = [];
            for (var i = 0, l = this.holes.length; i < l; i++) {
                var hole = this.holes[i];
                data.holes.push(hole.toJSON());
            }
            return data;
        },
        fromJSON: function (json) {
            Path.prototype.fromJSON.call(this, json);
            this.uuid = json.uuid;
            this.holes = [];
            for (var i = 0, l = json.holes.length; i < l; i++) {
                var hole = json.holes[i];
                this.holes.push(new Path().fromJSON(hole));
            }
            return this;
        }
    });
    function Light(color, intensity) {
        Object3D.call(this);
        this.type = 'Light';
        this.color = new Color(color);
        this.intensity = intensity !== undefined ? intensity : 1;
        this.receiveShadow = undefined;
    }
    Light.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Light,
        isLight: true,
        copy: function (source) {
            Object3D.prototype.copy.call(this, source);
            this.color.copy(source.color);
            this.intensity = source.intensity;
            return this;
        },
        toJSON: function (meta) {
            var data = Object3D.prototype.toJSON.call(this, meta);
            data.object.color = this.color.getHex();
            data.object.intensity = this.intensity;
            if (this.groundColor !== undefined)
                data.object.groundColor = this.groundColor.getHex();
            if (this.distance !== undefined)
                data.object.distance = this.distance;
            if (this.angle !== undefined)
                data.object.angle = this.angle;
            if (this.decay !== undefined)
                data.object.decay = this.decay;
            if (this.penumbra !== undefined)
                data.object.penumbra = this.penumbra;
            if (this.shadow !== undefined)
                data.object.shadow = this.shadow.toJSON();
            return data;
        }
    });
    function HemisphereLight(skyColor, groundColor, intensity) {
        Light.call(this, skyColor, intensity);
        this.type = 'HemisphereLight';
        this.castShadow = undefined;
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.groundColor = new Color(groundColor);
    }
    HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: HemisphereLight,
        isHemisphereLight: true,
        copy: function (source) {
            Light.prototype.copy.call(this, source);
            this.groundColor.copy(source.groundColor);
            return this;
        }
    });
    function LightShadow(camera) {
        this.camera = camera;
        this.bias = 0;
        this.radius = 1;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.matrix = new Matrix4();
    }
    Object.assign(LightShadow.prototype, {
        copy: function (source) {
            this.camera = source.camera.clone();
            this.bias = source.bias;
            this.radius = source.radius;
            this.mapSize.copy(source.mapSize);
            return this;
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        toJSON: function () {
            var object = {};
            if (this.bias !== 0)
                object.bias = this.bias;
            if (this.radius !== 1)
                object.radius = this.radius;
            if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
                object.mapSize = this.mapSize.toArray();
            object.camera = this.camera.toJSON(false).object;
            delete object.camera.matrix;
            return object;
        }
    });
    function SpotLightShadow() {
        LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
    }
    SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: SpotLightShadow,
        isSpotLightShadow: true,
        update: function (light) {
            var camera = this.camera;
            var fov = _Math.RAD2DEG * 2 * light.angle;
            var aspect = this.mapSize.width / this.mapSize.height;
            var far = light.distance || camera.far;
            if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                camera.fov = fov;
                camera.aspect = aspect;
                camera.far = far;
                camera.updateProjectionMatrix();
            }
        }
    });
    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
        Light.call(this, color, intensity);
        this.type = 'SpotLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        Object.defineProperty(this, 'power', {
            get: function () {
                return this.intensity * Math.PI;
            },
            set: function (power) {
                this.intensity = power / Math.PI;
            }
        });
        this.distance = (distance !== undefined) ? distance : 0;
        this.angle = (angle !== undefined) ? angle : Math.PI / 3;
        this.penumbra = (penumbra !== undefined) ? penumbra : 0;
        this.decay = (decay !== undefined) ? decay : 1;
        this.shadow = new SpotLightShadow();
    }
    SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: SpotLight,
        isSpotLight: true,
        copy: function (source) {
            Light.prototype.copy.call(this, source);
            this.distance = source.distance;
            this.angle = source.angle;
            this.penumbra = source.penumbra;
            this.decay = source.decay;
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    });
    function PointLight(color, intensity, distance, decay) {
        Light.call(this, color, intensity);
        this.type = 'PointLight';
        Object.defineProperty(this, 'power', {
            get: function () {
                return this.intensity * 4 * Math.PI;
            },
            set: function (power) {
                this.intensity = power / (4 * Math.PI);
            }
        });
        this.distance = (distance !== undefined) ? distance : 0;
        this.decay = (decay !== undefined) ? decay : 1;
        this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
    }
    PointLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: PointLight,
        isPointLight: true,
        copy: function (source) {
            Light.prototype.copy.call(this, source);
            this.distance = source.distance;
            this.decay = source.decay;
            this.shadow = source.shadow.clone();
            return this;
        }
    });
    function DirectionalLightShadow() {
        LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
    DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
        constructor: DirectionalLightShadow
    });
    function DirectionalLight(color, intensity) {
        Light.call(this, color, intensity);
        this.type = 'DirectionalLight';
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.shadow = new DirectionalLightShadow();
    }
    DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: DirectionalLight,
        isDirectionalLight: true,
        copy: function (source) {
            Light.prototype.copy.call(this, source);
            this.target = source.target.clone();
            this.shadow = source.shadow.clone();
            return this;
        }
    });
    function AmbientLight(color, intensity) {
        Light.call(this, color, intensity);
        this.type = 'AmbientLight';
        this.castShadow = undefined;
    }
    AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: AmbientLight,
        isAmbientLight: true
    });
    function RectAreaLight(color, intensity, width, height) {
        Light.call(this, color, intensity);
        this.type = 'RectAreaLight';
        this.width = (width !== undefined) ? width : 10;
        this.height = (height !== undefined) ? height : 10;
    }
    RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
        constructor: RectAreaLight,
        isRectAreaLight: true,
        copy: function (source) {
            Light.prototype.copy.call(this, source);
            this.width = source.width;
            this.height = source.height;
            return this;
        },
        toJSON: function (meta) {
            var data = Light.prototype.toJSON.call(this, meta);
            data.object.width = this.width;
            data.object.height = this.height;
            return data;
        }
    });
    function StringKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: StringKeyframeTrack,
        ValueTypeName: 'string',
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    });
    function BooleanKeyframeTrack(name, times, values) {
        KeyframeTrack.call(this, name, times, values);
    }
    BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: BooleanKeyframeTrack,
        ValueTypeName: 'bool',
        ValueBufferType: Array,
        DefaultInterpolation: InterpolateDiscrete,
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    });
    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
    }
    Object.assign(Interpolant.prototype, {
        evaluate: function (t) {
            var pp = this.parameterPositions
                , i1 = this._cachedIndex
                , t1 = pp[i1]
                , t0 = pp[i1 - 1];
            validate_interval: {
                seek: {
                    var right;
                    linear_scan: {
                        forward_scan: if (!(t < t1)) {
                            for (var giveUpAt = i1 + 2; ;) {
                                if (t1 === undefined) {
                                    if (t < t0)
                                        break forward_scan;
                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.afterEnd_(i1 - 1, t, t0);
                                }
                                if (i1 === giveUpAt)
                                    break;
                                t0 = t1;
                                t1 = pp[++i1];
                                if (t < t1) {
                                    break seek;
                                }
                            }
                            right = pp.length;
                            break linear_scan;
                        }
                        if (!(t >= t0)) {
                            var t1global = pp[1];
                            if (t < t1global) {
                                i1 = 2;
                                t0 = t1global;
                            }
                            for (var giveUpAt = i1 - 2; ;) {
                                if (t0 === undefined) {
                                    this._cachedIndex = 0;
                                    return this.beforeStart_(0, t, t1);
                                }
                                if (i1 === giveUpAt)
                                    break;
                                t1 = t0;
                                t0 = pp[--i1 - 1];
                                if (t >= t0) {
                                    break seek;
                                }
                            }
                            right = i1;
                            i1 = 0;
                            break linear_scan;
                        }
                        break validate_interval;
                    }
                    while (i1 < right) {
                        var mid = (i1 + right) >>> 1;
                        if (t < pp[mid]) {
                            right = mid;
                        } else {
                            i1 = mid + 1;
                        }
                    }
                    t1 = pp[i1];
                    t0 = pp[i1 - 1];
                    if (t0 === undefined) {
                        this._cachedIndex = 0;
                        return this.beforeStart_(0, t, t1);
                    }
                    if (t1 === undefined) {
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t0, t);
                    }
                }
                this._cachedIndex = i1;
                this.intervalChanged_(i1, t0, t1);
            }
            return this.interpolate_(i1, t0, t, t1);
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function () {
            return this.settings || this.DefaultSettings_;
        },
        copySampleValue_: function (index) {
            var result = this.resultBuffer
                , values = this.sampleValues
                , stride = this.valueSize
                , offset = index * stride;
            for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset + i];
            }
            return result;
        },
        interpolate_: function () {
            throw new Error('call to abstract method');
        },
        intervalChanged_: function () { }
    });
    Object.assign(Interpolant.prototype, {
        beforeStart_: Interpolant.prototype.copySampleValue_,
        afterEnd_: Interpolant.prototype.copySampleValue_,
    });
    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: QuaternionLinearInterpolant,
        interpolate_: function (i1, t0, t, t1) {
            var result = this.resultBuffer
                , values = this.sampleValues
                , stride = this.valueSize
                , offset = i1 * stride
                , alpha = (t - t0) / (t1 - t0);
            for (var end = offset + stride; offset !== end; offset += 4) {
                Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
            }
            return result;
        }
    });
    function QuaternionKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: QuaternionKeyframeTrack,
        ValueTypeName: 'quaternion',
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodLinear: function (result) {
            return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: undefined
    });
    function ColorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: ColorKeyframeTrack,
        ValueTypeName: 'color'
    });
    function NumberKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: NumberKeyframeTrack,
        ValueTypeName: 'number'
    });
    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
    }
    CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: CubicInterpolant,
        DefaultSettings_: {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        },
        intervalChanged_: function (i1, t0, t1) {
            var pp = this.parameterPositions
                , iPrev = i1 - 2
                , iNext = i1 + 1
                , tPrev = pp[iPrev]
                , tNext = pp[iNext];
            if (tPrev === undefined) {
                switch (this.getSettings_().endingStart) {
                    case ZeroSlopeEnding:
                        iPrev = i1;
                        tPrev = 2 * t0 - t1;
                        break;
                    case WrapAroundEnding:
                        iPrev = pp.length - 2;
                        tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                        break;
                    default:
                        iPrev = i1;
                        tPrev = t1;
                }
            }
            if (tNext === undefined) {
                switch (this.getSettings_().endingEnd) {
                    case ZeroSlopeEnding:
                        iNext = i1;
                        tNext = 2 * t1 - t0;
                        break;
                    case WrapAroundEnding:
                        iNext = 1;
                        tNext = t1 + pp[1] - pp[0];
                        break;
                    default:
                        iNext = i1 - 1;
                        tNext = t0;
                }
            }
            var halfDt = (t1 - t0) * 0.5
                , stride = this.valueSize;
            this._weightPrev = halfDt / (t0 - tPrev);
            this._weightNext = halfDt / (tNext - t1);
            this._offsetPrev = iPrev * stride;
            this._offsetNext = iNext * stride;
        },
        interpolate_: function (i1, t0, t, t1) {
            var result = this.resultBuffer
                , values = this.sampleValues
                , stride = this.valueSize
                , o1 = i1 * stride
                , o0 = o1 - stride
                , oP = this._offsetPrev
                , oN = this._offsetNext
                , wP = this._weightPrev
                , wN = this._weightNext
                , p = (t - t0) / (t1 - t0)
                , pp = p * p
                , ppp = pp * p;
            var sP = -wP * ppp + 2 * wP * pp - wP * p;
            var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
            var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
            var sN = wN * ppp - wN * pp;
            for (var i = 0; i !== stride; ++i) {
                result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
            }
            return result;
        }
    });
    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: LinearInterpolant,
        interpolate_: function (i1, t0, t, t1) {
            var result = this.resultBuffer
                , values = this.sampleValues
                , stride = this.valueSize
                , offset1 = i1 * stride
                , offset0 = offset1 - stride
                , weight1 = (t - t0) / (t1 - t0)
                , weight0 = 1 - weight1;
            for (var i = 0; i !== stride; ++i) {
                result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
            }
            return result;
        }
    });
    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
        constructor: DiscreteInterpolant,
        interpolate_: function (i1) {
            return this.copySampleValue_(i1 - 1);
        }
    });
    var AnimationUtils = {
        arraySlice: function (array, from, to) {
            if (AnimationUtils.isTypedArray(array)) {
                return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
            }
            return array.slice(from, to);
        },
        convertArray: function (array, type, forceClone) {
            if (!array || !forceClone && array.constructor === type)
                return array;
            if (typeof type.BYTES_PER_ELEMENT === 'number') {
                return new type(array);
            }
            return Array.prototype.slice.call(array);
        },
        isTypedArray: function (object) {
            return ArrayBuffer.isView(object) && !(object instanceof DataView);
        },
        getKeyframeOrder: function (times) {
            function compareTime(i, j) {
                return times[i] - times[j];
            }
            var n = times.length;
            var result = new Array(n);
            for (var i = 0; i !== n; ++i)
                result[i] = i;
            result.sort(compareTime);
            return result;
        },
        sortedArray: function (values, stride, order) {
            var nValues = values.length;
            var result = new values.constructor(nValues);
            for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
                var srcOffset = order[i] * stride;
                for (var j = 0; j !== stride; ++j) {
                    result[dstOffset++] = values[srcOffset + j];
                }
            }
            return result;
        },
        flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
            var i = 1
                , key = jsonKeys[0];
            while (key !== undefined && key[valuePropertyName] === undefined) {
                key = jsonKeys[i++];
            }
            if (key === undefined)
                return;
            var value = key[valuePropertyName];
            if (value === undefined)
                return;
            if (Array.isArray(value)) {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        values.push.apply(values, value);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            } else if (value.toArray !== undefined) {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        value.toArray(values, values.length);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            } else {
                do {
                    value = key[valuePropertyName];
                    if (value !== undefined) {
                        times.push(key.time);
                        values.push(value);
                    }
                    key = jsonKeys[i++];
                } while (key !== undefined);
            }
        }
    };
    function KeyframeTrack(name, times, values, interpolation) {
        if (name === undefined)
            throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (times === undefined || times.length === 0)
            throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
        this.name = name;
        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
        this.validate();
        this.optimize();
    }
    Object.assign(KeyframeTrack, {
        parse: function (json) {
            if (json.type === undefined) {
                throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
            }
            var trackType = KeyframeTrack._getTrackTypeForValueTypeName(json.type);
            if (json.times === undefined) {
                var times = []
                    , values = [];
                AnimationUtils.flattenJSON(json.keys, times, values, 'value');
                json.times = times;
                json.values = values;
            }
            if (trackType.parse !== undefined) {
                return trackType.parse(json);
            } else {
                return new trackType(json.name, json.times, json.values, json.interpolation);
            }
        },
        toJSON: function (track) {
            var trackType = track.constructor;
            var json;
            if (trackType.toJSON !== undefined) {
                json = trackType.toJSON(track);
            } else {
                json = {
                    'name': track.name,
                    'times': AnimationUtils.convertArray(track.times, Array),
                    'values': AnimationUtils.convertArray(track.values, Array)
                };
                var interpolation = track.getInterpolation();
                if (interpolation !== track.DefaultInterpolation) {
                    json.interpolation = interpolation;
                }
            }
            json.type = track.ValueTypeName;
            return json;
        },
        _getTrackTypeForValueTypeName: function (typeName) {
            switch (typeName.toLowerCase()) {
                case 'scalar':
                case 'double':
                case 'float':
                case 'number':
                case 'integer':
                    return NumberKeyframeTrack;
                case 'vector':
                case 'vector2':
                case 'vector3':
                case 'vector4':
                    return VectorKeyframeTrack;
                case 'color':
                    return ColorKeyframeTrack;
                case 'quaternion':
                    return QuaternionKeyframeTrack;
                case 'bool':
                case 'boolean':
                    return BooleanKeyframeTrack;
                case 'string':
                    return StringKeyframeTrack;
            }
            throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
        }
    });
    Object.assign(KeyframeTrack.prototype, {
        constructor: KeyframeTrack,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: InterpolateLinear,
        InterpolantFactoryMethodDiscrete: function (result) {
            return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodLinear: function (result) {
            return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        InterpolantFactoryMethodSmooth: function (result) {
            return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
        },
        setInterpolation: function (interpolation) {
            var factoryMethod;
            switch (interpolation) {
                case InterpolateDiscrete:
                    factoryMethod = this.InterpolantFactoryMethodDiscrete;
                    break;
                case InterpolateLinear:
                    factoryMethod = this.InterpolantFactoryMethodLinear;
                    break;
                case InterpolateSmooth:
                    factoryMethod = this.InterpolantFactoryMethodSmooth;
                    break;
            }
            if (factoryMethod === undefined) {
                var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (this.createInterpolant === undefined) {
                    if (interpolation !== this.DefaultInterpolation) {
                        this.setInterpolation(this.DefaultInterpolation);
                    } else {
                        throw new Error(message);
                    }
                }
                console.warn('THREE.KeyframeTrack:', message);
                return;
            }
            this.createInterpolant = factoryMethod;
        },
        getInterpolation: function () {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return InterpolateDiscrete;
                case this.InterpolantFactoryMethodLinear:
                    return InterpolateLinear;
                case this.InterpolantFactoryMethodSmooth:
                    return InterpolateSmooth;
            }
        },
        getValueSize: function () {
            return this.values.length / this.times.length;
        },
        shift: function (timeOffset) {
            if (timeOffset !== 0.0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                    times[i] += timeOffset;
                }
            }
            return this;
        },
        scale: function (timeScale) {
            if (timeScale !== 1.0) {
                var times = this.times;
                for (var i = 0, n = times.length; i !== n; ++i) {
                    times[i] *= timeScale;
                }
            }
            return this;
        },
        trim: function (startTime, endTime) {
            var times = this.times
                , nKeys = times.length
                , from = 0
                , to = nKeys - 1;
            while (from !== nKeys && times[from] < startTime) {
                ++from;
            }
            while (to !== -1 && times[to] > endTime) {
                --to;
            }
            ++to;
            if (from !== 0 || to !== nKeys) {
                if (from >= to)
                    to = Math.max(to, 1),
                        from = to - 1;
                var stride = this.getValueSize();
                this.times = AnimationUtils.arraySlice(times, from, to);
                this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
            }
            return this;
        },
        validate: function () {
            var valid = true;
            var valueSize = this.getValueSize();
            if (valueSize - Math.floor(valueSize) !== 0) {
                console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
                valid = false;
            }
            var times = this.times
                , values = this.values
                , nKeys = times.length;
            if (nKeys === 0) {
                console.error('THREE.KeyframeTrack: Track is empty.', this);
                valid = false;
            }
            var prevTime = null;
            for (var i = 0; i !== nKeys; i++) {
                var currTime = times[i];
                if (typeof currTime === 'number' && isNaN(currTime)) {
                    console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
                    valid = false;
                    break;
                }
                if (prevTime !== null && prevTime > currTime) {
                    console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
                    valid = false;
                    break;
                }
                prevTime = currTime;
            }
            if (values !== undefined) {
                if (AnimationUtils.isTypedArray(values)) {
                    for (var i = 0, n = values.length; i !== n; ++i) {
                        var value = values[i];
                        if (isNaN(value)) {
                            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
                            valid = false;
                            break;
                        }
                    }
                }
            }
            return valid;
        },
        optimize: function () {
            var times = this.times
                , values = this.values
                , stride = this.getValueSize()
                , smoothInterpolation = this.getInterpolation() === InterpolateSmooth
                , writeIndex = 1
                , lastIndex = times.length - 1;
            for (var i = 1; i < lastIndex; ++i) {
                var keep = false;
                var time = times[i];
                var timeNext = times[i + 1];
                if (time !== timeNext && (i !== 1 || time !== time[0])) {
                    if (!smoothInterpolation) {
                        var offset = i * stride
                            , offsetP = offset - stride
                            , offsetN = offset + stride;
                        for (var j = 0; j !== stride; ++j) {
                            var value = values[offset + j];
                            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                                keep = true;
                                break;
                            }
                        }
                    } else {
                        keep = true;
                    }
                }
                if (keep) {
                    if (i !== writeIndex) {
                        times[writeIndex] = times[i];
                        var readOffset = i * stride
                            , writeOffset = writeIndex * stride;
                        for (var j = 0; j !== stride; ++j) {
                            values[writeOffset + j] = values[readOffset + j];
                        }
                    }
                    ++writeIndex;
                }
            }
            if (lastIndex > 0) {
                times[writeIndex] = times[lastIndex];
                for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
                    values[writeOffset + j] = values[readOffset + j];
                }
                ++writeIndex;
            }
            if (writeIndex !== times.length) {
                this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
                this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
            }
            return this;
        }
    });
    function VectorKeyframeTrack(name, times, values, interpolation) {
        KeyframeTrack.call(this, name, times, values, interpolation);
    }
    VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
        constructor: VectorKeyframeTrack,
        ValueTypeName: 'vector'
    });
    function AnimationClip(name, duration, tracks) {
        this.name = name;
        this.tracks = tracks;
        this.duration = (duration !== undefined) ? duration : -1;
        this.uuid = _Math.generateUUID();
        if (this.duration < 0) {
            this.resetDuration();
        }
        this.optimize();
    }
    Object.assign(AnimationClip, {
        parse: function (json) {
            var tracks = []
                , jsonTracks = json.tracks
                , frameTime = 1.0 / (json.fps || 1.0);
            for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
                tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));
            }
            return new AnimationClip(json.name, json.duration, tracks);
        },
        toJSON: function (clip) {
            var tracks = []
                , clipTracks = clip.tracks;
            var json = {
                'name': clip.name,
                'duration': clip.duration,
                'tracks': tracks,
                'uuid': clip.uuid
            };
            for (var i = 0, n = clipTracks.length; i !== n; ++i) {
                tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
            }
            return json;
        },
        CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {
            var numMorphTargets = morphTargetSequence.length;
            var tracks = [];
            for (var i = 0; i < numMorphTargets; i++) {
                var times = [];
                var values = [];
                times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
                values.push(0, 1, 0);
                var order = AnimationUtils.getKeyframeOrder(times);
                times = AnimationUtils.sortedArray(times, 1, order);
                values = AnimationUtils.sortedArray(values, 1, order);
                if (!noLoop && times[0] === 0) {
                    times.push(numMorphTargets);
                    values.push(values[0]);
                }
                tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
            }
            return new AnimationClip(name, -1, tracks);
        },
        findByName: function (objectOrClipArray, name) {
            var clipArray = objectOrClipArray;
            if (!Array.isArray(objectOrClipArray)) {
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
            }
            for (var i = 0; i < clipArray.length; i++) {
                if (clipArray[i].name === name) {
                    return clipArray[i];
                }
            }
            return null;
        },
        CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {
            var animationToMorphTargets = {};
            var pattern = /^([\w-]*?)([\d]+)$/;
            for (var i = 0, il = morphTargets.length; i < il; i++) {
                var morphTarget = morphTargets[i];
                var parts = morphTarget.name.match(pattern);
                if (parts && parts.length > 1) {
                    var name = parts[1];
                    var animationMorphTargets = animationToMorphTargets[name];
                    if (!animationMorphTargets) {
                        animationToMorphTargets[name] = animationMorphTargets = [];
                    }
                    animationMorphTargets.push(morphTarget);
                }
            }
            var clips = [];
            for (var name in animationToMorphTargets) {
                clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
            }
            return clips;
        },
        parseAnimation: function (animation, bones) {
            if (!animation) {
                console.error('THREE.AnimationClip: No animation in JSONLoader data.');
                return null;
            }
            var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
                if (animationKeys.length !== 0) {
                    var times = [];
                    var values = [];
                    AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                    if (times.length !== 0) {
                        destTracks.push(new trackType(trackName, times, values));
                    }
                }
            };
            var tracks = [];
            var clipName = animation.name || 'default';
            var duration = animation.length || -1;
            var fps = animation.fps || 30;
            var hierarchyTracks = animation.hierarchy || [];
            for (var h = 0; h < hierarchyTracks.length; h++) {
                var animationKeys = hierarchyTracks[h].keys;
                if (!animationKeys || animationKeys.length === 0)
                    continue;
                if (animationKeys[0].morphTargets) {
                    var morphTargetNames = {};
                    for (var k = 0; k < animationKeys.length; k++) {
                        if (animationKeys[k].morphTargets) {
                            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                            }
                        }
                    }
                    for (var morphTargetName in morphTargetNames) {
                        var times = [];
                        var values = [];
                        for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                            var animationKey = animationKeys[k];
                            times.push(animationKey.time);
                            values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
                        }
                        tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                    }
                    duration = morphTargetNames.length * (fps || 1.0);
                } else {
                    var boneName = '.bones[' + bones[h].name + ']';
                    addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                    addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                    addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
                }
            }
            if (tracks.length === 0) {
                return null;
            }
            var clip = new AnimationClip(clipName, duration, tracks);
            return clip;
        }
    });
    Object.assign(AnimationClip.prototype, {
        resetDuration: function () {
            var tracks = this.tracks
                , duration = 0;
            for (var i = 0, n = tracks.length; i !== n; ++i) {
                var track = this.tracks[i];
                duration = Math.max(duration, track.times[track.times.length - 1]);
            }
            this.duration = duration;
        },
        trim: function () {
            for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].trim(0, this.duration);
            }
            return this;
        },
        optimize: function () {
            for (var i = 0; i < this.tracks.length; i++) {
                this.tracks[i].optimize();
            }
            return this;
        }
    });
    function MaterialLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this.textures = {};
    }
    Object.assign(MaterialLoader.prototype, {
        load: function (url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.load(url, function (text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        setTextures: function (value) {
            this.textures = value;
        },
        parse: function (json) {
            var textures = this.textures;
            function getTexture(name) {
                if (textures[name] === undefined) {
                    console.warn('THREE.MaterialLoader: Undefined texture', name);
                }
                return textures[name];
            }
            var material = new Materials[json.type]();
            if (json.uuid !== undefined)
                material.uuid = json.uuid;
            if (json.name !== undefined)
                material.name = json.name;
            if (json.color !== undefined)
                material.color.setHex(json.color);
            if (json.roughness !== undefined)
                material.roughness = json.roughness;
            if (json.metalness !== undefined)
                material.metalness = json.metalness;
            if (json.emissive !== undefined)
                material.emissive.setHex(json.emissive);
            if (json.specular !== undefined)
                material.specular.setHex(json.specular);
            if (json.shininess !== undefined)
                material.shininess = json.shininess;
            if (json.clearCoat !== undefined)
                material.clearCoat = json.clearCoat;
            if (json.clearCoatRoughness !== undefined)
                material.clearCoatRoughness = json.clearCoatRoughness;
            if (json.uniforms !== undefined)
                material.uniforms = json.uniforms;
            if (json.vertexShader !== undefined)
                material.vertexShader = json.vertexShader;
            if (json.fragmentShader !== undefined)
                material.fragmentShader = json.fragmentShader;
            if (json.vertexColors !== undefined)
                material.vertexColors = json.vertexColors;
            if (json.fog !== undefined)
                material.fog = json.fog;
            if (json.flatShading !== undefined)
                material.flatShading = json.flatShading;
            if (json.blending !== undefined)
                material.blending = json.blending;
            if (json.side !== undefined)
                material.side = json.side;
            if (json.opacity !== undefined)
                material.opacity = json.opacity;
            if (json.transparent !== undefined)
                material.transparent = json.transparent;
            if (json.alphaTest !== undefined)
                material.alphaTest = json.alphaTest;
            if (json.depthTest !== undefined)
                material.depthTest = json.depthTest;
            if (json.depthWrite !== undefined)
                material.depthWrite = json.depthWrite;
            if (json.colorWrite !== undefined)
                material.colorWrite = json.colorWrite;
            if (json.wireframe !== undefined)
                material.wireframe = json.wireframe;
            if (json.wireframeLinewidth !== undefined)
                material.wireframeLinewidth = json.wireframeLinewidth;
            if (json.wireframeLinecap !== undefined)
                material.wireframeLinecap = json.wireframeLinecap;
            if (json.wireframeLinejoin !== undefined)
                material.wireframeLinejoin = json.wireframeLinejoin;
            if (json.rotation !== undefined)
                material.rotation = json.rotation;
            if (json.linewidth !== 1)
                material.linewidth = json.linewidth;
            if (json.dashSize !== undefined)
                material.dashSize = json.dashSize;
            if (json.gapSize !== undefined)
                material.gapSize = json.gapSize;
            if (json.scale !== undefined)
                material.scale = json.scale;
            if (json.polygonOffset !== undefined)
                material.polygonOffset = json.polygonOffset;
            if (json.polygonOffsetFactor !== undefined)
                material.polygonOffsetFactor = json.polygonOffsetFactor;
            if (json.polygonOffsetUnits !== undefined)
                material.polygonOffsetUnits = json.polygonOffsetUnits;
            if (json.skinning !== undefined)
                material.skinning = json.skinning;
            if (json.morphTargets !== undefined)
                material.morphTargets = json.morphTargets;
            if (json.dithering !== undefined)
                material.dithering = json.dithering;
            if (json.visible !== undefined)
                material.visible = json.visible;
            if (json.userData !== undefined)
                material.userData = json.userData;
            if (json.shading !== undefined)
                material.flatShading = json.shading === 1;
            if (json.size !== undefined)
                material.size = json.size;
            if (json.sizeAttenuation !== undefined)
                material.sizeAttenuation = json.sizeAttenuation;
            if (json.map !== undefined)
                material.map = getTexture(json.map);
            if (json.alphaMap !== undefined) {
                material.alphaMap = getTexture(json.alphaMap);
                material.transparent = true;
            }
            if (json.bumpMap !== undefined)
                material.bumpMap = getTexture(json.bumpMap);
            if (json.bumpScale !== undefined)
                material.bumpScale = json.bumpScale;
            if (json.normalMap !== undefined)
                material.normalMap = getTexture(json.normalMap);
            if (json.normalScale !== undefined) {
                var normalScale = json.normalScale;
                if (Array.isArray(normalScale) === false) {
                    normalScale = [normalScale, normalScale];
                }
                material.normalScale = new Vector2().fromArray(normalScale);
            }
            if (json.displacementMap !== undefined)
                material.displacementMap = getTexture(json.displacementMap);
            if (json.displacementScale !== undefined)
                material.displacementScale = json.displacementScale;
            if (json.displacementBias !== undefined)
                material.displacementBias = json.displacementBias;
            if (json.roughnessMap !== undefined)
                material.roughnessMap = getTexture(json.roughnessMap);
            if (json.metalnessMap !== undefined)
                material.metalnessMap = getTexture(json.metalnessMap);
            if (json.emissiveMap !== undefined)
                material.emissiveMap = getTexture(json.emissiveMap);
            if (json.emissiveIntensity !== undefined)
                material.emissiveIntensity = json.emissiveIntensity;
            if (json.specularMap !== undefined)
                material.specularMap = getTexture(json.specularMap);
            if (json.envMap !== undefined)
                material.envMap = getTexture(json.envMap);
            if (json.reflectivity !== undefined)
                material.reflectivity = json.reflectivity;
            if (json.lightMap !== undefined)
                material.lightMap = getTexture(json.lightMap);
            if (json.lightMapIntensity !== undefined)
                material.lightMapIntensity = json.lightMapIntensity;
            if (json.aoMap !== undefined)
                material.aoMap = getTexture(json.aoMap);
            if (json.aoMapIntensity !== undefined)
                material.aoMapIntensity = json.aoMapIntensity;
            if (json.gradientMap !== undefined)
                material.gradientMap = getTexture(json.gradientMap);
            return material;
        }
    });
    function BufferGeometryLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(BufferGeometryLoader.prototype, {
        load: function (url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.load(url, function (text) {
                onLoad(scope.parse(JSON.parse(text)));
            }, onProgress, onError);
        },
        parse: function (json) {
            var geometry = new BufferGeometry();
            var index = json.data.index;
            if (index !== undefined) {
                var typedArray = new TYPED_ARRAYS[index.type](index.array);
                geometry.setIndex(new BufferAttribute(typedArray, 1));
            }
            var attributes = json.data.attributes;
            for (var key in attributes) {
                var attribute = attributes[key];
                var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
            }
            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
            if (groups !== undefined) {
                for (var i = 0, n = groups.length; i !== n; ++i) {
                    var group = groups[i];
                    geometry.addGroup(group.start, group.count, group.materialIndex);
                }
            }
            var boundingSphere = json.data.boundingSphere;
            if (boundingSphere !== undefined) {
                var center = new Vector3();
                if (boundingSphere.center !== undefined) {
                    center.fromArray(boundingSphere.center);
                }
                geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
            }
            return geometry;
        }
    });
    var TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    function Loader() { }
    Loader.Handlers = {
        handlers: [],
        add: function (regex, loader) {
            this.handlers.push(regex, loader);
        },
        get: function (file) {
            var handlers = this.handlers;
            for (var i = 0, l = handlers.length; i < l; i += 2) {
                var regex = handlers[i];
                var loader = handlers[i + 1];
                if (regex.test(file)) {
                    return loader;
                }
            }
            return null;
        }
    };
    Object.assign(Loader.prototype, {
        crossOrigin: undefined,
        onLoadStart: function () { },
        onLoadProgress: function () { },
        onLoadComplete: function () { },
        initMaterials: function (materials, texturePath, crossOrigin) {
            var array = [];
            for (var i = 0; i < materials.length; ++i) {
                array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
            }
            return array;
        },
        createMaterial: (function () {
            var BlendingMode = {
                NoBlending: NoBlending,
                NormalBlending: NormalBlending,
                AdditiveBlending: AdditiveBlending,
                SubtractiveBlending: SubtractiveBlending,
                MultiplyBlending: MultiplyBlending,
                CustomBlending: CustomBlending
            };
            var color = new Color();
            var textureLoader = new TextureLoader();
            var materialLoader = new MaterialLoader();
            return function createMaterial(m, texturePath, crossOrigin) {
                var textures = {};
                function loadTexture(path, repeat, offset, wrap, anisotropy) {
                    var fullPath = texturePath + path;
                    var loader = Loader.Handlers.get(fullPath);
                    var texture;
                    if (loader !== null) {
                        texture = loader.load(fullPath);
                    } else {
                        textureLoader.setCrossOrigin(crossOrigin);
                        texture = textureLoader.load(fullPath);
                    }
                    if (repeat !== undefined) {
                        texture.repeat.fromArray(repeat);
                        if (repeat[0] !== 1)
                            texture.wrapS = RepeatWrapping;
                        if (repeat[1] !== 1)
                            texture.wrapT = RepeatWrapping;
                    }
                    if (offset !== undefined) {
                        texture.offset.fromArray(offset);
                    }
                    if (wrap !== undefined) {
                        if (wrap[0] === 'repeat')
                            texture.wrapS = RepeatWrapping;
                        if (wrap[0] === 'mirror')
                            texture.wrapS = MirroredRepeatWrapping;
                        if (wrap[1] === 'repeat')
                            texture.wrapT = RepeatWrapping;
                        if (wrap[1] === 'mirror')
                            texture.wrapT = MirroredRepeatWrapping;
                    }
                    if (anisotropy !== undefined) {
                        texture.anisotropy = anisotropy;
                    }
                    var uuid = _Math.generateUUID();
                    textures[uuid] = texture;
                    return uuid;
                }
                var json = {
                    uuid: _Math.generateUUID(),
                    type: 'MeshLambertMaterial'
                };
                for (var name in m) {
                    var value = m[name];
                    switch (name) {
                        case 'DbgColor':
                        case 'DbgIndex':
                        case 'opticalDensity':
                        case 'illumination':
                            break;
                        case 'DbgName':
                            json.name = value;
                            break;
                        case 'blending':
                            json.blending = BlendingMode[value];
                            break;
                        case 'colorAmbient':
                        case 'mapAmbient':
                            console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
                            break;
                        case 'colorDiffuse':
                            json.color = color.fromArray(value).getHex();
                            break;
                        case 'colorSpecular':
                            json.specular = color.fromArray(value).getHex();
                            break;
                        case 'colorEmissive':
                            json.emissive = color.fromArray(value).getHex();
                            break;
                        case 'specularCoef':
                            json.shininess = value;
                            break;
                        case 'shading':
                            if (value.toLowerCase() === 'basic')
                                json.type = 'MeshBasicMaterial';
                            if (value.toLowerCase() === 'phong')
                                json.type = 'MeshPhongMaterial';
                            if (value.toLowerCase() === 'standard')
                                json.type = 'MeshStandardMaterial';
                            break;
                        case 'mapDiffuse':
                            json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
                            break;
                        case 'mapDiffuseRepeat':
                        case 'mapDiffuseOffset':
                        case 'mapDiffuseWrap':
                        case 'mapDiffuseAnisotropy':
                            break;
                        case 'mapEmissive':
                            json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
                            break;
                        case 'mapEmissiveRepeat':
                        case 'mapEmissiveOffset':
                        case 'mapEmissiveWrap':
                        case 'mapEmissiveAnisotropy':
                            break;
                        case 'mapLight':
                            json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
                            break;
                        case 'mapLightRepeat':
                        case 'mapLightOffset':
                        case 'mapLightWrap':
                        case 'mapLightAnisotropy':
                            break;
                        case 'mapAO':
                            json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
                            break;
                        case 'mapAORepeat':
                        case 'mapAOOffset':
                        case 'mapAOWrap':
                        case 'mapAOAnisotropy':
                            break;
                        case 'mapBump':
                            json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
                            break;
                        case 'mapBumpScale':
                            json.bumpScale = value;
                            break;
                        case 'mapBumpRepeat':
                        case 'mapBumpOffset':
                        case 'mapBumpWrap':
                        case 'mapBumpAnisotropy':
                            break;
                        case 'mapNormal':
                            json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
                            break;
                        case 'mapNormalFactor':
                            json.normalScale = value;
                            break;
                        case 'mapNormalRepeat':
                        case 'mapNormalOffset':
                        case 'mapNormalWrap':
                        case 'mapNormalAnisotropy':
                            break;
                        case 'mapSpecular':
                            json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
                            break;
                        case 'mapSpecularRepeat':
                        case 'mapSpecularOffset':
                        case 'mapSpecularWrap':
                        case 'mapSpecularAnisotropy':
                            break;
                        case 'mapMetalness':
                            json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
                            break;
                        case 'mapMetalnessRepeat':
                        case 'mapMetalnessOffset':
                        case 'mapMetalnessWrap':
                        case 'mapMetalnessAnisotropy':
                            break;
                        case 'mapRoughness':
                            json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
                            break;
                        case 'mapRoughnessRepeat':
                        case 'mapRoughnessOffset':
                        case 'mapRoughnessWrap':
                        case 'mapRoughnessAnisotropy':
                            break;
                        case 'mapAlpha':
                            json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
                            break;
                        case 'mapAlphaRepeat':
                        case 'mapAlphaOffset':
                        case 'mapAlphaWrap':
                        case 'mapAlphaAnisotropy':
                            break;
                        case 'flipSided':
                            json.side = BackSide;
                            break;
                        case 'doubleSided':
                            json.side = DoubleSide;
                            break;
                        case 'transparency':
                            console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
                            json.opacity = value;
                            break;
                        case 'depthTest':
                        case 'depthWrite':
                        case 'colorWrite':
                        case 'opacity':
                        case 'reflectivity':
                        case 'transparent':
                        case 'visible':
                        case 'wireframe':
                            json[name] = value;
                            break;
                        case 'vertexColors':
                            if (value === true)
                                json.vertexColors = VertexColors;
                            if (value === 'face')
                                json.vertexColors = FaceColors;
                            break;
                        default:
                            console.error('THREE.Loader.createMaterial: Unsupported', name, value);
                            break;
                    }
                }
                if (json.type === 'MeshBasicMaterial')
                    delete json.emissive;
                if (json.type !== 'MeshPhongMaterial')
                    delete json.specular;
                if (json.opacity < 1)
                    json.transparent = true;
                materialLoader.setTextures(textures);
                return materialLoader.parse(json);
            }
                ;
        }
        )()
    });
    var LoaderUtils = {
        decodeText: function (array) {
            if (typeof TextDecoder !== 'undefined') {
                return new TextDecoder().decode(array);
            }
            var s = '';
            for (var i = 0, il = array.length; i < il; i++) {
                s += String.fromCharCode(array[i]);
            }
            return decodeURIComponent(escape(s));
        },
        extractUrlBase: function (url) {
            var index = url.lastIndexOf('/');
            if (index === -1)
                return './';
            return url.substr(0, index + 1);
        }
    };
    function JSONLoader(manager) {
        if (typeof manager === 'boolean') {
            console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');
            manager = undefined;
        }
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this.withCredentials = false;
    }
    Object.assign(JSONLoader.prototype, {
        load: function (url, onLoad, onProgress, onError) {
            var scope = this;
            var texturePath = this.texturePath && (typeof this.texturePath === 'string') ? this.texturePath : LoaderUtils.extractUrlBase(url);
            var loader = new FileLoader(this.manager);
            loader.setWithCredentials(this.withCredentials);
            loader.load(url, function (text) {
                var json = JSON.parse(text);
                var metadata = json.metadata;
                if (metadata !== undefined) {
                    var type = metadata.type;
                    if (type !== undefined) {
                        if (type.toLowerCase() === 'object') {
                            console.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                            return;
                        }
                    }
                }
                var object = scope.parse(json, texturePath);
                onLoad(object.geometry, object.materials);
            }, onProgress, onError);
        },
        setTexturePath: function (value) {
            this.texturePath = value;
        },
        parse: (function () {
            function parseModel(json, geometry) {
                function isBitSet(value, position) {
                    return value & (1 << position);
                }
                var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces, vertices = json.vertices, normals = json.normals, colors = json.colors, scale = json.scale, nUvLayers = 0;
                if (json.uvs !== undefined) {
                    for (i = 0; i < json.uvs.length; i++) {
                        if (json.uvs[i].length)
                            nUvLayers++;
                    }
                    for (i = 0; i < nUvLayers; i++) {
                        geometry.faceVertexUvs[i] = [];
                    }
                }
                offset = 0;
                zLength = vertices.length;
                while (offset < zLength) {
                    vertex = new Vector3();
                    vertex.x = vertices[offset++] * scale;
                    vertex.y = vertices[offset++] * scale;
                    vertex.z = vertices[offset++] * scale;
                    geometry.vertices.push(vertex);
                }
                offset = 0;
                zLength = faces.length;
                while (offset < zLength) {
                    type = faces[offset++];
                    isQuad = isBitSet(type, 0);
                    hasMaterial = isBitSet(type, 1);
                    hasFaceVertexUv = isBitSet(type, 3);
                    hasFaceNormal = isBitSet(type, 4);
                    hasFaceVertexNormal = isBitSet(type, 5);
                    hasFaceColor = isBitSet(type, 6);
                    hasFaceVertexColor = isBitSet(type, 7);
                    if (isQuad) {
                        faceA = new Face3();
                        faceA.a = faces[offset];
                        faceA.b = faces[offset + 1];
                        faceA.c = faces[offset + 3];
                        faceB = new Face3();
                        faceB.a = faces[offset + 1];
                        faceB.b = faces[offset + 2];
                        faceB.c = faces[offset + 3];
                        offset += 4;
                        if (hasMaterial) {
                            materialIndex = faces[offset++];
                            faceA.materialIndex = materialIndex;
                            faceB.materialIndex = materialIndex;
                        }
                        fi = geometry.faces.length;
                        if (hasFaceVertexUv) {
                            for (i = 0; i < nUvLayers; i++) {
                                uvLayer = json.uvs[i];
                                geometry.faceVertexUvs[i][fi] = [];
                                geometry.faceVertexUvs[i][fi + 1] = [];
                                for (j = 0; j < 4; j++) {
                                    uvIndex = faces[offset++];
                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];
                                    uv = new Vector2(u, v);
                                    if (j !== 2)
                                        geometry.faceVertexUvs[i][fi].push(uv);
                                    if (j !== 0)
                                        geometry.faceVertexUvs[i][fi + 1].push(uv);
                                }
                            }
                        }
                        if (hasFaceNormal) {
                            normalIndex = faces[offset++] * 3;
                            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                            faceB.normal.copy(faceA.normal);
                        }
                        if (hasFaceVertexNormal) {
                            for (i = 0; i < 4; i++) {
                                normalIndex = faces[offset++] * 3;
                                normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                if (i !== 2)
                                    faceA.vertexNormals.push(normal);
                                if (i !== 0)
                                    faceB.vertexNormals.push(normal);
                            }
                        }
                        if (hasFaceColor) {
                            colorIndex = faces[offset++];
                            hex = colors[colorIndex];
                            faceA.color.setHex(hex);
                            faceB.color.setHex(hex);
                        }
                        if (hasFaceVertexColor) {
                            for (i = 0; i < 4; i++) {
                                colorIndex = faces[offset++];
                                hex = colors[colorIndex];
                                if (i !== 2)
                                    faceA.vertexColors.push(new Color(hex));
                                if (i !== 0)
                                    faceB.vertexColors.push(new Color(hex));
                            }
                        }
                        geometry.faces.push(faceA);
                        geometry.faces.push(faceB);
                    } else {
                        face = new Face3();
                        face.a = faces[offset++];
                        face.b = faces[offset++];
                        face.c = faces[offset++];
                        if (hasMaterial) {
                            materialIndex = faces[offset++];
                            face.materialIndex = materialIndex;
                        }
                        fi = geometry.faces.length;
                        if (hasFaceVertexUv) {
                            for (i = 0; i < nUvLayers; i++) {
                                uvLayer = json.uvs[i];
                                geometry.faceVertexUvs[i][fi] = [];
                                for (j = 0; j < 3; j++) {
                                    uvIndex = faces[offset++];
                                    u = uvLayer[uvIndex * 2];
                                    v = uvLayer[uvIndex * 2 + 1];
                                    uv = new Vector2(u, v);
                                    geometry.faceVertexUvs[i][fi].push(uv);
                                }
                            }
                        }
                        if (hasFaceNormal) {
                            normalIndex = faces[offset++] * 3;
                            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                        }
                        if (hasFaceVertexNormal) {
                            for (i = 0; i < 3; i++) {
                                normalIndex = faces[offset++] * 3;
                                normal = new Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                                face.vertexNormals.push(normal);
                            }
                        }
                        if (hasFaceColor) {
                            colorIndex = faces[offset++];
                            face.color.setHex(colors[colorIndex]);
                        }
                        if (hasFaceVertexColor) {
                            for (i = 0; i < 3; i++) {
                                colorIndex = faces[offset++];
                                face.vertexColors.push(new Color(colors[colorIndex]));
                            }
                        }
                        geometry.faces.push(face);
                    }
                }
            }
            function parseSkin(json, geometry) {
                var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
                if (json.skinWeights) {
                    for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
                        var x = json.skinWeights[i];
                        var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
                        var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
                        var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
                        geometry.skinWeights.push(new Vector4(x, y, z, w));
                    }
                }
                if (json.skinIndices) {
                    for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
                        var a = json.skinIndices[i];
                        var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
                        var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
                        var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
                        geometry.skinIndices.push(new Vector4(a, b, c, d));
                    }
                }
                geometry.bones = json.bones;
                if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
                    console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
                }
            }
            function parseMorphing(json, geometry) {
                var scale = json.scale;
                if (json.morphTargets !== undefined) {
                    for (var i = 0, l = json.morphTargets.length; i < l; i++) {
                        geometry.morphTargets[i] = {};
                        geometry.morphTargets[i].name = json.morphTargets[i].name;
                        geometry.morphTargets[i].vertices = [];
                        var dstVertices = geometry.morphTargets[i].vertices;
                        var srcVertices = json.morphTargets[i].vertices;
                        for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
                            var vertex = new Vector3();
                            vertex.x = srcVertices[v] * scale;
                            vertex.y = srcVertices[v + 1] * scale;
                            vertex.z = srcVertices[v + 2] * scale;
                            dstVertices.push(vertex);
                        }
                    }
                }
                if (json.morphColors !== undefined && json.morphColors.length > 0) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    var faces = geometry.faces;
                    var morphColors = json.morphColors[0].colors;
                    for (var i = 0, l = faces.length; i < l; i++) {
                        faces[i].color.fromArray(morphColors, i * 3);
                    }
                }
            }
            function parseAnimations(json, geometry) {
                var outputAnimations = [];
                var animations = [];
                if (json.animation !== undefined) {
                    animations.push(json.animation);
                }
                if (json.animations !== undefined) {
                    if (json.animations.length) {
                        animations = animations.concat(json.animations);
                    } else {
                        animations.push(json.animations);
                    }
                }
                for (var i = 0; i < animations.length; i++) {
                    var clip = AnimationClip.parseAnimation(animations[i], geometry.bones);
                    if (clip)
                        outputAnimations.push(clip);
                }
                if (geometry.morphTargets) {
                    var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
                    outputAnimations = outputAnimations.concat(morphAnimationClips);
                }
                if (outputAnimations.length > 0)
                    geometry.animations = outputAnimations;
            }
            return function parse(json, texturePath) {
                if (json.data !== undefined) {
                    json = json.data;
                }
                if (json.scale !== undefined) {
                    json.scale = 1.0 / json.scale;
                } else {
                    json.scale = 1.0;
                }
                var geometry = new Geometry();
                parseModel(json, geometry);
                parseSkin(json, geometry);
                parseMorphing(json, geometry);
                parseAnimations(json, geometry);
                geometry.computeFaceNormals();
                geometry.computeBoundingSphere();
                if (json.materials === undefined || json.materials.length === 0) {
                    return {
                        geometry: geometry
                    };
                } else {
                    var materials = Loader.prototype.initMaterials(json.materials, texturePath, this.crossOrigin);
                    return {
                        geometry: geometry,
                        materials: materials
                    };
                }
            }
                ;
        }
        )()
    });
    function ObjectLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
        this.texturePath = '';
    }
    Object.assign(ObjectLoader.prototype, {
        load: function (url, onLoad, onProgress, onError) {
            if (this.texturePath === '') {
                this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
            }
            var scope = this;
            var loader = new FileLoader(scope.manager);
            loader.load(url, function (text) {
                var json = null;
                try {
                    json = JSON.parse(text);
                } catch (error) {
                    if (onError !== undefined)
                        onError(error);
                    console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                    return;
                }
                var metadata = json.metadata;
                if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                    console.error('THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.');
                    return;
                }
                scope.parse(json, onLoad);
            }, onProgress, onError);
        },
        setTexturePath: function (value) {
            this.texturePath = value;
            return this;
        },
        setCrossOrigin: function (value) {
            this.crossOrigin = value;
            return this;
        },
        parse: function (json, onLoad) {
            var shapes = this.parseShape(json.shapes);
            var geometries = this.parseGeometries(json.geometries, shapes);
            var images = this.parseImages(json.images, function () {
                if (onLoad !== undefined)
                    onLoad(object);
            });
            var textures = this.parseTextures(json.textures, images);
            var materials = this.parseMaterials(json.materials, textures);
            var object = this.parseObject(json.object, geometries, materials);
            if (json.animations) {
                object.animations = this.parseAnimations(json.animations);
            }
            if (json.images === undefined || json.images.length === 0) {
                if (onLoad !== undefined)
                    onLoad(object);
            }
            return object;
        },
        parseShape: function (json) {
            var shapes = {};
            if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                    var shape = new Shape().fromJSON(json[i]);
                    shapes[shape.uuid] = shape;
                }
            }
            return shapes;
        },
        parseGeometries: function (json, shapes) {
            var geometries = {};
            if (json !== undefined) {
                var geometryLoader = new JSONLoader();
                var bufferGeometryLoader = new BufferGeometryLoader();
                for (var i = 0, l = json.length; i < l; i++) {
                    var geometry;
                    var data = json[i];
                    switch (data.type) {
                        case 'PlaneGeometry':
                        case 'PlaneBufferGeometry':
                            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                            break;
                        case 'BoxGeometry':
                        case 'BoxBufferGeometry':
                        case 'CubeGeometry':
                            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                            break;
                        case 'CircleGeometry':
                        case 'CircleBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                            break;
                        case 'CylinderGeometry':
                        case 'CylinderBufferGeometry':
                            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                            break;
                        case 'ConeGeometry':
                        case 'ConeBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                            break;
                        case 'SphereGeometry':
                        case 'SphereBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                            break;
                        case 'DodecahedronGeometry':
                        case 'DodecahedronBufferGeometry':
                        case 'IcosahedronGeometry':
                        case 'IcosahedronBufferGeometry':
                        case 'OctahedronGeometry':
                        case 'OctahedronBufferGeometry':
                        case 'TetrahedronGeometry':
                        case 'TetrahedronBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.detail);
                            break;
                        case 'RingGeometry':
                        case 'RingBufferGeometry':
                            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                            break;
                        case 'TorusGeometry':
                        case 'TorusBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                            break;
                        case 'TorusKnotGeometry':
                        case 'TorusKnotBufferGeometry':
                            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                            break;
                        case 'LatheGeometry':
                        case 'LatheBufferGeometry':
                            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                            break;
                        case 'PolyhedronGeometry':
                        case 'PolyhedronBufferGeometry':
                            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                            break;
                        case 'ShapeGeometry':
                        case 'ShapeBufferGeometry':
                            var geometryShapes = [];
                            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                                var shape = shapes[data.shapes[j]];
                                geometryShapes.push(shape);
                            }
                            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                            break;
                        case 'ExtrudeGeometry':
                        case 'ExtrudeBufferGeometry':
                            var geometryShapes = [];
                            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                                var shape = shapes[data.shapes[j]];
                                geometryShapes.push(shape);
                            }
                            var extrudePath = data.options.extrudePath;
                            if (extrudePath !== undefined) {
                                data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
                            }
                            geometry = new Geometries[data.type](geometryShapes, data.options);
                            break;
                        case 'BufferGeometry':
                            geometry = bufferGeometryLoader.parse(data);
                            break;
                        case 'Geometry':
                            geometry = geometryLoader.parse(data, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                            continue;
                    }
                    geometry.uuid = data.uuid;
                    if (data.name !== undefined)
                        geometry.name = data.name;
                    if (geometry.isBufferGeometry === true && data.userData !== undefined)
                        geometry.userData = data.userData;
                    geometries[data.uuid] = geometry;
                }
            }
            return geometries;
        },
        parseMaterials: function (json, textures) {
            var materials = {};
            if (json !== undefined) {
                var loader = new MaterialLoader();
                loader.setTextures(textures);
                for (var i = 0, l = json.length; i < l; i++) {
                    var data = json[i];
                    if (data.type === 'MultiMaterial') {
                        var array = [];
                        for (var j = 0; j < data.materials.length; j++) {
                            array.push(loader.parse(data.materials[j]));
                        }
                        materials[data.uuid] = array;
                    } else {
                        materials[data.uuid] = loader.parse(data);
                    }
                }
            }
            return materials;
        },
        parseAnimations: function (json) {
            var animations = [];
            for (var i = 0; i < json.length; i++) {
                var data = json[i];
                var clip = AnimationClip.parse(data);
                if (data.uuid !== undefined)
                    clip.uuid = data.uuid;
                animations.push(clip);
            }
            return animations;
        },
        parseImages: function (json, onLoad) {
            var scope = this;
            var images = {};
            function loadImage(url) {
                scope.manager.itemStart(url);
                return loader.load(url, function () {
                    scope.manager.itemEnd(url);
                }, undefined, function () {
                    scope.manager.itemEnd(url);
                    scope.manager.itemError(url);
                });
            }
            if (json !== undefined && json.length > 0) {
                var manager = new LoadingManager(onLoad);
                var loader = new ImageLoader(manager);
                loader.setCrossOrigin(this.crossOrigin);
                for (var i = 0, l = json.length; i < l; i++) {
                    var image = json[i];
                    var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
                    images[image.uuid] = loadImage(path);
                }
            }
            return images;
        },
        parseTextures: function (json, images) {
            function parseConstant(value, type) {
                if (typeof value === 'number')
                    return value;
                console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
                return type[value];
            }
            var textures = {};
            if (json !== undefined) {
                for (var i = 0, l = json.length; i < l; i++) {
                    var data = json[i];
                    if (data.image === undefined) {
                        console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                    }
                    if (images[data.image] === undefined) {
                        console.warn('THREE.ObjectLoader: Undefined image', data.image);
                    }
                    var texture = new Texture(images[data.image]);
                    texture.needsUpdate = true;
                    texture.uuid = data.uuid;
                    if (data.name !== undefined)
                        texture.name = data.name;
                    if (data.mapping !== undefined)
                        texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
                    if (data.offset !== undefined)
                        texture.offset.fromArray(data.offset);
                    if (data.repeat !== undefined)
                        texture.repeat.fromArray(data.repeat);
                    if (data.center !== undefined)
                        texture.center.fromArray(data.center);
                    if (data.rotation !== undefined)
                        texture.rotation = data.rotation;
                    if (data.wrap !== undefined) {
                        texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                        texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
                    }
                    if (data.format !== undefined)
                        texture.format = data.format;
                    if (data.minFilter !== undefined)
                        texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                    if (data.magFilter !== undefined)
                        texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                    if (data.anisotropy !== undefined)
                        texture.anisotropy = data.anisotropy;
                    if (data.flipY !== undefined)
                        texture.flipY = data.flipY;
                    textures[data.uuid] = texture;
                }
            }
            return textures;
        },
        parseObject: function (data, geometries, materials) {
            var object;
            function getGeometry(name) {
                if (geometries[name] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined geometry', name);
                }
                return geometries[name];
            }
            function getMaterial(name) {
                if (name === undefined)
                    return undefined;
                if (Array.isArray(name)) {
                    var array = [];
                    for (var i = 0, l = name.length; i < l; i++) {
                        var uuid = name[i];
                        if (materials[uuid] === undefined) {
                            console.warn('THREE.ObjectLoader: Undefined material', uuid);
                        }
                        array.push(materials[uuid]);
                    }
                    return array;
                }
                if (materials[name] === undefined) {
                    console.warn('THREE.ObjectLoader: Undefined material', name);
                }
                return materials[name];
            }
            switch (data.type) {
                case 'Scene':
                    object = new Scene();
                    if (data.background !== undefined) {
                        if (Number.isInteger(data.background)) {
                            object.background = new Color(data.background);
                        }
                    }
                    if (data.fog !== undefined) {
                        if (data.fog.type === 'Fog') {
                            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                        } else if (data.fog.type === 'FogExp2') {
                            object.fog = new FogExp2(data.fog.color, data.fog.density);
                        }
                    }
                    break;
                case 'PerspectiveCamera':
                    object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                    if (data.focus !== undefined)
                        object.focus = data.focus;
                    if (data.zoom !== undefined)
                        object.zoom = data.zoom;
                    if (data.filmGauge !== undefined)
                        object.filmGauge = data.filmGauge;
                    if (data.filmOffset !== undefined)
                        object.filmOffset = data.filmOffset;
                    if (data.view !== undefined)
                        object.view = Object.assign({}, data.view);
                    break;
                case 'OrthographicCamera':
                    object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                    if (data.zoom !== undefined)
                        object.zoom = data.zoom;
                    if (data.view !== undefined)
                        object.view = Object.assign({}, data.view);
                    break;
                case 'AmbientLight':
                    object = new AmbientLight(data.color, data.intensity);
                    break;
                case 'DirectionalLight':
                    object = new DirectionalLight(data.color, data.intensity);
                    break;
                case 'PointLight':
                    object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                    break;
                case 'RectAreaLight':
                    object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                    break;
                case 'SpotLight':
                    object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                    break;
                case 'HemisphereLight':
                    object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                    break;
                case 'SkinnedMesh':
                    console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');
                case 'Mesh':
                    var geometry = getGeometry(data.geometry);
                    var material = getMaterial(data.material);
                    if (geometry.bones && geometry.bones.length > 0) {
                        object = new SkinnedMesh(geometry, material);
                    } else {
                        object = new Mesh(geometry, material);
                    }
                    break;
                case 'LOD':
                    object = new LOD();
                    break;
                case 'Line':
                    object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                    break;
                case 'LineLoop':
                    object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'LineSegments':
                    object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'PointCloud':
                case 'Points':
                    object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                    break;
                case 'Sprite':
                    object = new Sprite(getMaterial(data.material));
                    break;
                case 'Group':
                    object = new Group();
                    break;
                default:
                    object = new Object3D();
            }
            object.uuid = data.uuid;
            if (data.name !== undefined)
                object.name = data.name;
            if (data.matrix !== undefined) {
                object.matrix.fromArray(data.matrix);
                if (data.matrixAutoUpdate !== undefined)
                    object.matrixAutoUpdate = data.matrixAutoUpdate;
                if (object.matrixAutoUpdate)
                    object.matrix.decompose(object.position, object.quaternion, object.scale);
            } else {
                if (data.position !== undefined)
                    object.position.fromArray(data.position);
                if (data.rotation !== undefined)
                    object.rotation.fromArray(data.rotation);
                if (data.quaternion !== undefined)
                    object.quaternion.fromArray(data.quaternion);
                if (data.scale !== undefined)
                    object.scale.fromArray(data.scale);
            }
            if (data.castShadow !== undefined)
                object.castShadow = data.castShadow;
            if (data.receiveShadow !== undefined)
                object.receiveShadow = data.receiveShadow;
            if (data.shadow) {
                if (data.shadow.bias !== undefined)
                    object.shadow.bias = data.shadow.bias;
                if (data.shadow.radius !== undefined)
                    object.shadow.radius = data.shadow.radius;
                if (data.shadow.mapSize !== undefined)
                    object.shadow.mapSize.fromArray(data.shadow.mapSize);
                if (data.shadow.camera !== undefined)
                    object.shadow.camera = this.parseObject(data.shadow.camera);
            }
            if (data.visible !== undefined)
                object.visible = data.visible;
            if (data.frustumCulled !== undefined)
                object.frustumCulled = data.frustumCulled;
            if (data.renderOrder !== undefined)
                object.renderOrder = data.renderOrder;
            if (data.userData !== undefined)
                object.userData = data.userData;
            if (data.children !== undefined) {
                var children = data.children;
                for (var i = 0; i < children.length; i++) {
                    object.add(this.parseObject(children[i], geometries, materials));
                }
            }
            if (data.type === 'LOD') {
                var levels = data.levels;
                for (var l = 0; l < levels.length; l++) {
                    var level = levels[l];
                    var child = object.getObjectByProperty('uuid', level.object);
                    if (child !== undefined) {
                        object.addLevel(child, level.distance);
                    }
                }
            }
            return object;
        }
    });
    var TEXTURE_MAPPING = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    };
    var TEXTURE_WRAPPING = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    };
    var TEXTURE_FILTER = {
        NearestFilter: NearestFilter,
        NearestMipMapNearestFilter: NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: NearestMipMapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipMapNearestFilter: LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: LinearMipMapLinearFilter
    };
    function ImageBitmapLoader(manager) {
        if (typeof createImageBitmap === 'undefined') {
            console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
        }
        if (typeof fetch === 'undefined') {
            console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
        }
        this.manager = manager !== undefined ? manager : DefaultLoadingManager;
        this.options = undefined;
    }
    ImageBitmapLoader.prototype = {
        constructor: ImageBitmapLoader,
        setOptions: function setOptions(options) {
            this.options = options;
            return this;
        },
        load: function (url, onLoad, onProgress, onError) {
            if (url === undefined)
                url = '';
            if (this.path !== undefined)
                url = this.path + url;
            url = this.manager.resolveURL(url);
            var scope = this;
            var cached = Cache.get(url);
            if (cached !== undefined) {
                scope.manager.itemStart(url);
                setTimeout(function () {
                    if (onLoad)
                        onLoad(cached);
                    scope.manager.itemEnd(url);
                }, 0);
                return cached;
            }
            fetch(url).then(function (res) {
                return res.blob();
            }).then(function (blob) {
                return createImageBitmap(blob, scope.options);
            }).then(function (imageBitmap) {
                Cache.add(url, imageBitmap);
                if (onLoad)
                    onLoad(imageBitmap);
                scope.manager.itemEnd(url);
            }).catch(function (e) {
                if (onError)
                    onError(e);
                scope.manager.itemEnd(url);
                scope.manager.itemError(url);
            });
        },
        setCrossOrigin: function () {
            return this;
        },
        setPath: function (value) {
            this.path = value;
            return this;
        }
    };
    function ShapePath() {
        this.type = 'ShapePath';
        this.color = new Color();
        this.subPaths = [];
        this.currentPath = null;
    }
    Object.assign(ShapePath.prototype, {
        moveTo: function (x, y) {
            this.currentPath = new Path();
            this.subPaths.push(this.currentPath);
            this.currentPath.moveTo(x, y);
        },
        lineTo: function (x, y) {
            this.currentPath.lineTo(x, y);
        },
        quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
            this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        },
        bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
            this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        },
        splineThru: function (pts) {
            this.currentPath.splineThru(pts);
        },
        toShapes: function (isCCW, noHoles) {
            function toShapesNoHoles(inSubpaths) {
                var shapes = [];
                for (var i = 0, l = inSubpaths.length; i < l; i++) {
                    var tmpPath = inSubpaths[i];
                    var tmpShape = new Shape();
                    tmpShape.curves = tmpPath.curves;
                    shapes.push(tmpShape);
                }
                return shapes;
            }
            function isPointInsidePolygon(inPt, inPolygon) {
                var polyLen = inPolygon.length;
                var inside = false;
                for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                    var edgeLowPt = inPolygon[p];
                    var edgeHighPt = inPolygon[q];
                    var edgeDx = edgeHighPt.x - edgeLowPt.x;
                    var edgeDy = edgeHighPt.y - edgeLowPt.y;
                    if (Math.abs(edgeDy) > Number.EPSILON) {
                        if (edgeDy < 0) {
                            edgeLowPt = inPolygon[q];
                            edgeDx = -edgeDx;
                            edgeHighPt = inPolygon[p];
                            edgeDy = -edgeDy;
                        }
                        if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
                            continue;
                        if (inPt.y === edgeLowPt.y) {
                            if (inPt.x === edgeLowPt.x)
                                return true;
                        } else {
                            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                            if (perpEdge === 0)
                                return true;
                            if (perpEdge < 0)
                                continue;
                            inside = !inside;
                        }
                    } else {
                        if (inPt.y !== edgeLowPt.y)
                            continue;
                        if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) || ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
                            return true;
                    }
                }
                return inside;
            }
            var isClockWise = ShapeUtils.isClockWise;
            var subPaths = this.subPaths;
            if (subPaths.length === 0)
                return [];
            if (noHoles === true)
                return toShapesNoHoles(subPaths);
            var solid, tmpPath, tmpShape, shapes = [];
            if (subPaths.length === 1) {
                tmpPath = subPaths[0];
                tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push(tmpShape);
                return shapes;
            }
            var holesFirst = !isClockWise(subPaths[0].getPoints());
            holesFirst = isCCW ? !holesFirst : holesFirst;
            var betterShapeHoles = [];
            var newShapes = [];
            var newShapeHoles = [];
            var mainIdx = 0;
            var tmpPoints;
            newShapes[mainIdx] = undefined;
            newShapeHoles[mainIdx] = [];
            for (var i = 0, l = subPaths.length; i < l; i++) {
                tmpPath = subPaths[i];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise(tmpPoints);
                solid = isCCW ? !solid : solid;
                if (solid) {
                    if ((!holesFirst) && (newShapes[mainIdx]))
                        mainIdx++;
                    newShapes[mainIdx] = {
                        s: new Shape(),
                        p: tmpPoints
                    };
                    newShapes[mainIdx].s.curves = tmpPath.curves;
                    if (holesFirst)
                        mainIdx++;
                    newShapeHoles[mainIdx] = [];
                } else {
                    newShapeHoles[mainIdx].push({
                        h: tmpPath,
                        p: tmpPoints[0]
                    });
                }
            }
            if (!newShapes[0])
                return toShapesNoHoles(subPaths);
            if (newShapes.length > 1) {
                var ambiguous = false;
                var toChange = [];
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    betterShapeHoles[sIdx] = [];
                }
                for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                    var sho = newShapeHoles[sIdx];
                    for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                        var ho = sho[hIdx];
                        var hole_unassigned = true;
                        for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                                if (sIdx !== s2Idx)
                                    toChange.push({
                                        froms: sIdx,
                                        tos: s2Idx,
                                        hole: hIdx
                                    });
                                if (hole_unassigned) {
                                    hole_unassigned = false;
                                    betterShapeHoles[s2Idx].push(ho);
                                } else {
                                    ambiguous = true;
                                }
                            }
                        }
                        if (hole_unassigned) {
                            betterShapeHoles[sIdx].push(ho);
                        }
                    }
                }
                if (toChange.length > 0) {
                    if (!ambiguous)
                        newShapeHoles = betterShapeHoles;
                }
            }
            var tmpHoles;
            for (var i = 0, il = newShapes.length; i < il; i++) {
                tmpShape = newShapes[i].s;
                shapes.push(tmpShape);
                tmpHoles = newShapeHoles[i];
                for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                    tmpShape.holes.push(tmpHoles[j].h);
                }
            }
            return shapes;
        }
    });
    function Font(data) {
        this.type = 'Font';
        this.data = data;
    }
    Object.assign(Font.prototype, {
        isFont: true,
        generateShapes: function (text, size, divisions) {
            if (size === undefined)
                size = 100;
            if (divisions === undefined)
                divisions = 4;
            var shapes = [];
            var paths = createPaths(text, size, divisions, this.data);
            for (var p = 0, pl = paths.length; p < pl; p++) {
                Array.prototype.push.apply(shapes, paths[p].toShapes());
            }
            return shapes;
        }
    });
    function createPaths(text, size, divisions, data) {
        var chars = Array.from ? Array.from(text) : String(text).split('');
        var scale = size / data.resolution;
        var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
        var paths = [];
        var offsetX = 0
            , offsetY = 0;
        for (var i = 0; i < chars.length; i++) {
            var char = chars[i];
            if (char === '\n') {
                offsetX = 0;
                offsetY -= line_height;
            } else {
                var ret = createPath(char, divisions, scale, offsetX, offsetY, data);
                offsetX += ret.offsetX;
                paths.push(ret.path);
            }
        }
        return paths;
    }
    function createPath(char, divisions, scale, offsetX, offsetY, data) {
        var glyph = data.glyphs[char] || data.glyphs['?'];
        if (!glyph)
            return;
        var path = new ShapePath();
        var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
        if (glyph.o) {
            var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
            for (var i = 0, l = outline.length; i < l;) {
                var action = outline[i++];
                switch (action) {
                    case 'm':
                        x = outline[i++] * scale + offsetX;
                        y = outline[i++] * scale + offsetY;
                        path.moveTo(x, y);
                        break;
                    case 'l':
                        x = outline[i++] * scale + offsetX;
                        y = outline[i++] * scale + offsetY;
                        path.lineTo(x, y);
                        break;
                    case 'q':
                        cpx = outline[i++] * scale + offsetX;
                        cpy = outline[i++] * scale + offsetY;
                        cpx1 = outline[i++] * scale + offsetX;
                        cpy1 = outline[i++] * scale + offsetY;
                        path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                        break;
                    case 'b':
                        cpx = outline[i++] * scale + offsetX;
                        cpy = outline[i++] * scale + offsetY;
                        cpx1 = outline[i++] * scale + offsetX;
                        cpy1 = outline[i++] * scale + offsetY;
                        cpx2 = outline[i++] * scale + offsetX;
                        cpy2 = outline[i++] * scale + offsetY;
                        path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                        break;
                }
            }
        }
        return {
            offsetX: glyph.ha * scale,
            path: path
        };
    }
    function FontLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(FontLoader.prototype, {
        load: function (url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new FileLoader(this.manager);
            loader.setPath(this.path);
            loader.load(url, function (text) {
                var json;
                try {
                    json = JSON.parse(text);
                } catch (e) {
                    console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                    json = JSON.parse(text.substring(65, text.length - 2));
                }
                var font = scope.parse(json);
                if (onLoad)
                    onLoad(font);
            }, onProgress, onError);
        },
        parse: function (json) {
            return new Font(json);
        },
        setPath: function (value) {
            this.path = value;
            return this;
        }
    });
    var context;
    var AudioContext = {
        getContext: function () {
            if (context === undefined) {
                context = new (window.AudioContext || window.webkitAudioContext)();
            }
            return context;
        },
        setContext: function (value) {
            context = value;
        }
    };
    function AudioLoader(manager) {
        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
    }
    Object.assign(AudioLoader.prototype, {
        load: function (url, onLoad, onProgress, onError) {
            var loader = new FileLoader(this.manager);
            loader.setResponseType('arraybuffer');
            loader.load(url, function (buffer) {
                var context = AudioContext.getContext();
                context.decodeAudioData(buffer, function (audioBuffer) {
                    onLoad(audioBuffer);
                });
            }, onProgress, onError);
        }
    });
    function StereoCamera() {
        this.type = 'StereoCamera';
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
    }
    Object.assign(StereoCamera.prototype, {
        update: (function () {
            var instance, focus, fov, aspect, near, far, zoom, eyeSep;
            var eyeRight = new Matrix4();
            var eyeLeft = new Matrix4();
            return function update(camera) {
                var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov || aspect !== camera.aspect * this.aspect || near !== camera.near || far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;
                if (needsUpdate) {
                    instance = this;
                    focus = camera.focus;
                    fov = camera.fov;
                    aspect = camera.aspect * this.aspect;
                    near = camera.near;
                    far = camera.far;
                    zoom = camera.zoom;
                    var projectionMatrix = camera.projectionMatrix.clone();
                    eyeSep = this.eyeSep / 2;
                    var eyeSepOnProjection = eyeSep * near / focus;
                    var ymax = (near * Math.tan(_Math.DEG2RAD * fov * 0.5)) / zoom;
                    var xmin, xmax;
                    eyeLeft.elements[12] = -eyeSep;
                    eyeRight.elements[12] = eyeSep;
                    xmin = -ymax * aspect + eyeSepOnProjection;
                    xmax = ymax * aspect + eyeSepOnProjection;
                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                    this.cameraL.projectionMatrix.copy(projectionMatrix);
                    xmin = -ymax * aspect - eyeSepOnProjection;
                    xmax = ymax * aspect - eyeSepOnProjection;
                    projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
                    projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                    this.cameraR.projectionMatrix.copy(projectionMatrix);
                }
                this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
                this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
            }
                ;
        }
        )()
    });
    function CubeCamera(near, far, cubeResolution) {
        Object3D.call(this);
        this.type = 'CubeCamera';
        var fov = 90
            , aspect = 1;
        var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new Vector3(1, 0, 0));
        this.add(cameraPX);
        var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new Vector3(-1, 0, 0));
        this.add(cameraNX);
        var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new Vector3(0, 1, 0));
        this.add(cameraPY);
        var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new Vector3(0, -1, 0));
        this.add(cameraNY);
        var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new Vector3(0, 0, 1));
        this.add(cameraPZ);
        var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new Vector3(0, 0, -1));
        this.add(cameraNZ);
        var options = {
            format: RGBFormat,
            magFilter: LinearFilter,
            minFilter: LinearFilter
        };
        this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
        this.renderTarget.texture.name = "CubeCamera";
        this.update = function (renderer, scene) {
            if (this.parent === null)
                this.updateMatrixWorld();
            var renderTarget = this.renderTarget;
            var generateMipmaps = renderTarget.texture.generateMipmaps;
            renderTarget.texture.generateMipmaps = false;
            renderTarget.activeCubeFace = 0;
            renderer.render(scene, cameraPX, renderTarget);
            renderTarget.activeCubeFace = 1;
            renderer.render(scene, cameraNX, renderTarget);
            renderTarget.activeCubeFace = 2;
            renderer.render(scene, cameraPY, renderTarget);
            renderTarget.activeCubeFace = 3;
            renderer.render(scene, cameraNY, renderTarget);
            renderTarget.activeCubeFace = 4;
            renderer.render(scene, cameraPZ, renderTarget);
            renderTarget.texture.generateMipmaps = generateMipmaps;
            renderTarget.activeCubeFace = 5;
            renderer.render(scene, cameraNZ, renderTarget);
            renderer.setRenderTarget(null);
        }
            ;
        this.clear = function (renderer, color, depth, stencil) {
            var renderTarget = this.renderTarget;
            for (var i = 0; i < 6; i++) {
                renderTarget.activeCubeFace = i;
                renderer.setRenderTarget(renderTarget);
                renderer.clear(color, depth, stencil);
            }
            renderer.setRenderTarget(null);
        }
            ;
    }
    CubeCamera.prototype = Object.create(Object3D.prototype);
    CubeCamera.prototype.constructor = CubeCamera;
    function AudioListener() {
        Object3D.call(this);
        this.type = 'AudioListener';
        this.context = AudioContext.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
    }
    AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: AudioListener,
        getInput: function () {
            return this.gain;
        },
        removeFilter: function () {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
                this.gain.connect(this.context.destination);
                this.filter = null;
            }
        },
        getFilter: function () {
            return this.filter;
        },
        setFilter: function (value) {
            if (this.filter !== null) {
                this.gain.disconnect(this.filter);
                this.filter.disconnect(this.context.destination);
            } else {
                this.gain.disconnect(this.context.destination);
            }
            this.filter = value;
            this.gain.connect(this.filter);
            this.filter.connect(this.context.destination);
        },
        getMasterVolume: function () {
            return this.gain.gain.value;
        },
        setMasterVolume: function (value) {
            this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        },
        updateMatrixWorld: (function () {
            var position = new Vector3();
            var quaternion = new Quaternion();
            var scale = new Vector3();
            var orientation = new Vector3();
            return function updateMatrixWorld(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                var listener = this.context.listener;
                var up = this.up;
                this.matrixWorld.decompose(position, quaternion, scale);
                orientation.set(0, 0, -1).applyQuaternion(quaternion);
                if (listener.positionX) {
                    listener.positionX.setValueAtTime(position.x, this.context.currentTime);
                    listener.positionY.setValueAtTime(position.y, this.context.currentTime);
                    listener.positionZ.setValueAtTime(position.z, this.context.currentTime);
                    listener.forwardX.setValueAtTime(orientation.x, this.context.currentTime);
                    listener.forwardY.setValueAtTime(orientation.y, this.context.currentTime);
                    listener.forwardZ.setValueAtTime(orientation.z, this.context.currentTime);
                    listener.upX.setValueAtTime(up.x, this.context.currentTime);
                    listener.upY.setValueAtTime(up.y, this.context.currentTime);
                    listener.upZ.setValueAtTime(up.z, this.context.currentTime);
                } else {
                    listener.setPosition(position.x, position.y, position.z);
                    listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
                }
            }
                ;
        }
        )()
    });
    function Audio(listener) {
        Object3D.call(this);
        this.type = 'Audio';
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.loop = false;
        this.startTime = 0;
        this.offset = 0;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.sourceType = 'empty';
        this.filters = [];
    }
    Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
        constructor: Audio,
        getOutput: function () {
            return this.gain;
        },
        setNodeSource: function (audioNode) {
            this.hasPlaybackControl = false;
            this.sourceType = 'audioNode';
            this.source = audioNode;
            this.connect();
            return this;
        },
        setMediaElementSource: function (mediaElement) {
            this.hasPlaybackControl = false;
            this.sourceType = 'mediaNode';
            this.source = this.context.createMediaElementSource(mediaElement);
            this.connect();
            return this;
        },
        setBuffer: function (audioBuffer) {
            this.buffer = audioBuffer;
            this.sourceType = 'buffer';
            if (this.autoplay)
                this.play();
            return this;
        },
        play: function () {
            if (this.isPlaying === true) {
                console.warn('THREE.Audio: Audio is already playing.');
                return;
            }
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            var source = this.context.createBufferSource();
            source.buffer = this.buffer;
            source.loop = this.loop;
            source.onended = this.onEnded.bind(this);
            source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
            this.startTime = this.context.currentTime;
            source.start(this.startTime, this.offset);
            this.isPlaying = true;
            this.source = source;
            return this.connect();
        },
        pause: function () {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            if (this.isPlaying === true) {
                this.source.stop();
                this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
                this.isPlaying = false;
            }
            return this;
        },
        stop: function () {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.source.stop();
            this.offset = 0;
            this.isPlaying = false;
            return this;
        },
        connect: function () {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].connect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].connect(this.getOutput());
            } else {
                this.source.connect(this.getOutput());
            }
            return this;
        },
        disconnect: function () {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (var i = 1, l = this.filters.length; i < l; i++) {
                    this.filters[i - 1].disconnect(this.filters[i]);
                }
                this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else {
                this.source.disconnect(this.getOutput());
            }
            return this;
        },
        getFilters: function () {
            return this.filters;
        },
        setFilters: function (value) {
            if (!value)
                value = [];
            if (this.isPlaying === true) {
                this.disconnect();
                this.filters = value;
                this.connect();
            } else {
                this.filters = value;
            }
            return this;
        },
        getFilter: function () {
            return this.getFilters()[0];
        },
        setFilter: function (filter) {
            return this.setFilters(filter ? [filter] : []);
        },
        setPlaybackRate: function (value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.playbackRate = value;
            if (this.isPlaying === true) {
                this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime);
            }
            return this;
        },
        getPlaybackRate: function () {
            return this.playbackRate;
        },
        onEnded: function () {
            this.isPlaying = false;
        },
        getLoop: function () {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return false;
            }
            return this.loop;
        },
        setLoop: function (value) {
            if (this.hasPlaybackControl === false) {
                console.warn('THREE.Audio: this Audio has no playback control.');
                return;
            }
            this.loop = value;
            if (this.isPlaying === true) {
                this.source.loop = this.loop;
            }
            return this;
        },
        getVolume: function () {
            return this.gain.gain.value;
        },
        setVolume: function (value) {
            this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
            return this;
        }
    });
    function PositionalAudio(listener) {
        Audio.call(this, listener);
        this.panner = this.context.createPanner();
        this.panner.connect(this.gain);
    }
    PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
        constructor: PositionalAudio,
        getOutput: function () {
            return this.panner;
        },
        getRefDistance: function () {
            return this.panner.refDistance;
        },
        setRefDistance: function (value) {
            this.panner.refDistance = value;
        },
        getRolloffFactor: function () {
            return this.panner.rolloffFactor;
        },
        setRolloffFactor: function (value) {
            this.panner.rolloffFactor = value;
        },
        getDistanceModel: function () {
            return this.panner.distanceModel;
        },
        setDistanceModel: function (value) {
            this.panner.distanceModel = value;
        },
        getMaxDistance: function () {
            return this.panner.maxDistance;
        },
        setMaxDistance: function (value) {
            this.panner.maxDistance = value;
        },
        updateMatrixWorld: (function () {
            var position = new Vector3();
            return function updateMatrixWorld(force) {
                Object3D.prototype.updateMatrixWorld.call(this, force);
                position.setFromMatrixPosition(this.matrixWorld);
                this.panner.setPosition(position.x, position.y, position.z);
            }
                ;
        }
        )()
    });
    function AudioAnalyser(audio, fftSize) {
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
    Object.assign(AudioAnalyser.prototype, {
        getFrequencyData: function () {
            this.analyser.getByteFrequencyData(this.data);
            return this.data;
        },
        getAverageFrequency: function () {
            var value = 0
                , data = this.getFrequencyData();
            for (var i = 0; i < data.length; i++) {
                value += data[i];
            }
            return value / data.length;
        }
    });
    function PropertyMixer(binding, typeName, valueSize) {
        this.binding = binding;
        this.valueSize = valueSize;
        var bufferType = Float64Array, mixFunction;
        switch (typeName) {
            case 'quaternion':
                mixFunction = this._slerp;
                break;
            case 'string':
            case 'bool':
                bufferType = Array;
                mixFunction = this._select;
                break;
            default:
                mixFunction = this._lerp;
        }
        this.buffer = new bufferType(valueSize * 4);
        this._mixBufferRegion = mixFunction;
        this.cumulativeWeight = 0;
        this.useCount = 0;
        this.referenceCount = 0;
    }
    Object.assign(PropertyMixer.prototype, {
        accumulate: function (accuIndex, weight) {
            var buffer = this.buffer
                , stride = this.valueSize
                , offset = accuIndex * stride + stride
                , currentWeight = this.cumulativeWeight;
            if (currentWeight === 0) {
                for (var i = 0; i !== stride; ++i) {
                    buffer[offset + i] = buffer[i];
                }
                currentWeight = weight;
            } else {
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion(buffer, offset, 0, mix, stride);
            }
            this.cumulativeWeight = currentWeight;
        },
        apply: function (accuIndex) {
            var stride = this.valueSize
                , buffer = this.buffer
                , offset = accuIndex * stride + stride
                , weight = this.cumulativeWeight
                , binding = this.binding;
            this.cumulativeWeight = 0;
            if (weight < 1) {
                var originalValueOffset = stride * 3;
                this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
            }
            for (var i = stride, e = stride + stride; i !== e; ++i) {
                if (buffer[i] !== buffer[i + stride]) {
                    binding.setValue(buffer, offset);
                    break;
                }
            }
        },
        saveOriginalState: function () {
            var binding = this.binding;
            var buffer = this.buffer
                , stride = this.valueSize
                , originalValueOffset = stride * 3;
            binding.getValue(buffer, originalValueOffset);
            for (var i = stride, e = originalValueOffset; i !== e; ++i) {
                buffer[i] = buffer[originalValueOffset + (i % stride)];
            }
            this.cumulativeWeight = 0;
        },
        restoreOriginalState: function () {
            var originalValueOffset = this.valueSize * 3;
            this.binding.setValue(this.buffer, originalValueOffset);
        },
        _select: function (buffer, dstOffset, srcOffset, t, stride) {
            if (t >= 0.5) {
                for (var i = 0; i !== stride; ++i) {
                    buffer[dstOffset + i] = buffer[srcOffset + i];
                }
            }
        },
        _slerp: function (buffer, dstOffset, srcOffset, t) {
            Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
        },
        _lerp: function (buffer, dstOffset, srcOffset, t, stride) {
            var s = 1 - t;
            for (var i = 0; i !== stride; ++i) {
                var j = dstOffset + i;
                buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
            }
        }
    });
    var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
    function Composite(targetGroup, path, optionalParsedPath) {
        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    Object.assign(Composite.prototype, {
        getValue: function (array, offset) {
            this.bind();
            var firstValidIndex = this._targetGroup.nCachedObjects_
                , binding = this._bindings[firstValidIndex];
            if (binding !== undefined)
                binding.getValue(array, offset);
        },
        setValue: function (array, offset) {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].setValue(array, offset);
            }
        },
        bind: function () {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].bind();
            }
        },
        unbind: function () {
            var bindings = this._bindings;
            for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                bindings[i].unbind();
            }
        }
    });
    function PropertyBinding(rootNode, path, parsedPath) {
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
    }
    Object.assign(PropertyBinding, {
        Composite: Composite,
        create: function (root, path, parsedPath) {
            if (!(root && root.isAnimationObjectGroup)) {
                return new PropertyBinding(root, path, parsedPath);
            } else {
                return new PropertyBinding.Composite(root, path, parsedPath);
            }
        },
        sanitizeNodeName: (function () {
            var reservedRe = new RegExp('[' + RESERVED_CHARS_RE + ']', 'g');
            return function sanitizeNodeName(name) {
                return name.replace(/\s/g, '_').replace(reservedRe, '');
            }
                ;
        }()),
        parseTrackName: function () {
            var wordChar = '[^' + RESERVED_CHARS_RE + ']';
            var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace('\\.', '') + ']';
            var directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', wordChar);
            var nodeRe = /(WCOD+)?/.source.replace('WCOD', wordCharOrDot);
            var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', wordChar);
            var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', wordChar);
            var trackRe = new RegExp('' + '^' + directoryRe + nodeRe + objectRe + propertyRe + '$');
            var supportedObjectNames = ['material', 'materials', 'bones'];
            return function parseTrackName(trackName) {
                var matches = trackRe.exec(trackName);
                if (!matches) {
                    throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
                }
                var results = {
                    nodeName: matches[2],
                    objectName: matches[3],
                    objectIndex: matches[4],
                    propertyName: matches[5],
                    propertyIndex: matches[6]
                };
                var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
                if (lastDot !== undefined && lastDot !== -1) {
                    var objectName = results.nodeName.substring(lastDot + 1);
                    if (supportedObjectNames.indexOf(objectName) !== -1) {
                        results.nodeName = results.nodeName.substring(0, lastDot);
                        results.objectName = objectName;
                    }
                }
                if (results.propertyName === null || results.propertyName.length === 0) {
                    throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
                }
                return results;
            }
                ;
        }(),
        findNode: function (root, nodeName) {
            if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
                return root;
            }
            if (root.skeleton) {
                var bone = root.skeleton.getBoneByName(nodeName);
                if (bone !== undefined) {
                    return bone;
                }
            }
            if (root.children) {
                var searchNodeSubtree = function (children) {
                    for (var i = 0; i < children.length; i++) {
                        var childNode = children[i];
                        if (childNode.name === nodeName || childNode.uuid === nodeName) {
                            return childNode;
                        }
                        var result = searchNodeSubtree(childNode.children);
                        if (result)
                            return result;
                    }
                    return null;
                };
                var subTreeNode = searchNodeSubtree(root.children);
                if (subTreeNode) {
                    return subTreeNode;
                }
            }
            return null;
        }
    });
    Object.assign(PropertyBinding.prototype, {
        _getValue_unavailable: function () { },
        _setValue_unavailable: function () { },
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function getValue_direct(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        }
            , function getValue_array(buffer, offset) {
                var source = this.resolvedProperty;
                for (var i = 0, n = source.length; i !== n; ++i) {
                    buffer[offset++] = source[i];
                }
            }
            , function getValue_arrayElement(buffer, offset) {
                buffer[offset] = this.resolvedProperty[this.propertyIndex];
            }
            , function getValue_toArray(buffer, offset) {
                this.resolvedProperty.toArray(buffer, offset);
            }
        ],
        SetterByBindingTypeAndVersioning: [[function setValue_direct(buffer, offset) {
            this.targetObject[this.propertyName] = buffer[offset];
        }
            , function setValue_direct_setNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.needsUpdate = true;
            }
            , function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ], [function setValue_array(buffer, offset) {
            var dest = this.resolvedProperty;
            for (var i = 0, n = dest.length; i !== n; ++i) {
                dest[i] = buffer[offset++];
            }
        }
            , function setValue_array_setNeedsUpdate(buffer, offset) {
                var dest = this.resolvedProperty;
                for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                }
                this.targetObject.needsUpdate = true;
            }
            , function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                var dest = this.resolvedProperty;
                for (var i = 0, n = dest.length; i !== n; ++i) {
                    dest[i] = buffer[offset++];
                }
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ], [function setValue_arrayElement(buffer, offset) {
            this.resolvedProperty[this.propertyIndex] = buffer[offset];
        }
            , function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.needsUpdate = true;
            }
            , function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ], [function setValue_fromArray(buffer, offset) {
            this.resolvedProperty.fromArray(buffer, offset);
        }
            , function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.needsUpdate = true;
            }
            , function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ]],
        getValue: function getValue_unbound(targetArray, offset) {
            this.bind();
            this.getValue(targetArray, offset);
        },
        setValue: function getValue_unbound(sourceArray, offset) {
            this.bind();
            this.setValue(sourceArray, offset);
        },
        bind: function () {
            var targetObject = this.node
                , parsedPath = this.parsedPath
                , objectName = parsedPath.objectName
                , propertyName = parsedPath.propertyName
                , propertyIndex = parsedPath.propertyIndex;
            if (!targetObject) {
                targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
                this.node = targetObject;
            }
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;
            if (!targetObject) {
                console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
                return;
            }
            if (objectName) {
                var objectIndex = parsedPath.objectIndex;
                switch (objectName) {
                    case 'materials':
                        if (!targetObject.material) {
                            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                            return;
                        }
                        if (!targetObject.material.materials) {
                            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                            return;
                        }
                        targetObject = targetObject.material.materials;
                        break;
                    case 'bones':
                        if (!targetObject.skeleton) {
                            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                            return;
                        }
                        targetObject = targetObject.skeleton.bones;
                        for (var i = 0; i < targetObject.length; i++) {
                            if (targetObject[i].name === objectIndex) {
                                objectIndex = i;
                                break;
                            }
                        }
                        break;
                    default:
                        if (targetObject[objectName] === undefined) {
                            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                            return;
                        }
                        targetObject = targetObject[objectName];
                }
                if (objectIndex !== undefined) {
                    if (targetObject[objectIndex] === undefined) {
                        console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                        return;
                    }
                    targetObject = targetObject[objectIndex];
                }
            }
            var nodeProperty = targetObject[propertyName];
            if (nodeProperty === undefined) {
                var nodeName = parsedPath.nodeName;
                console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
                return;
            }
            var versioning = this.Versioning.None;
            if (targetObject.needsUpdate !== undefined) {
                versioning = this.Versioning.NeedsUpdate;
                this.targetObject = targetObject;
            } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
                versioning = this.Versioning.MatrixWorldNeedsUpdate;
                this.targetObject = targetObject;
            }
            var bindingType = this.BindingType.Direct;
            if (propertyIndex !== undefined) {
                if (propertyName === "morphTargetInfluences") {
                    if (!targetObject.geometry) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                        return;
                    }
                    if (targetObject.geometry.isBufferGeometry) {
                        if (!targetObject.geometry.morphAttributes) {
                            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                            return;
                        }
                        for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
                            if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
                                propertyIndex = i;
                                break;
                            }
                        }
                    } else {
                        if (!targetObject.geometry.morphTargets) {
                            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this);
                            return;
                        }
                        for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
                            if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                                propertyIndex = i;
                                break;
                            }
                        }
                    }
                }
                bindingType = this.BindingType.ArrayElement;
                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
            } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                bindingType = this.BindingType.HasFromToArray;
                this.resolvedProperty = nodeProperty;
            } else if (Array.isArray(nodeProperty)) {
                bindingType = this.BindingType.EntireArray;
                this.resolvedProperty = nodeProperty;
            } else {
                this.propertyName = propertyName;
            }
            this.getValue = this.GetterByBindingType[bindingType];
            this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
        },
        unbind: function () {
            this.node = null;
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
        }
    });
    Object.assign(PropertyBinding.prototype, {
        _getValue_unbound: PropertyBinding.prototype.getValue,
        _setValue_unbound: PropertyBinding.prototype.setValue,
    });
    function AnimationObjectGroup() {
        this.uuid = _Math.generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        var indices = {};
        this._indicesByUUID = indices;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
            indices[arguments[i].uuid] = i;
        }
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        var scope = this;
        this.stats = {
            objects: {
                get total() {
                    return scope._objects.length;
                },
                get inUse() {
                    return this.total - scope.nCachedObjects_;
                }
            },
            get bindingsPerObject() {
                return scope._bindings.length;
            }
        };
    }
    Object.assign(AnimationObjectGroup.prototype, {
        isAnimationObjectGroup: true,
        add: function () {
            var objects = this._objects
                , nObjects = objects.length
                , nCachedObjects = this.nCachedObjects_
                , indicesByUUID = this._indicesByUUID
                , paths = this._paths
                , parsedPaths = this._parsedPaths
                , bindings = this._bindings
                , nBindings = bindings.length
                , knownObject = undefined;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i]
                    , uuid = object.uuid
                    , index = indicesByUUID[uuid];
                if (index === undefined) {
                    index = nObjects++;
                    indicesByUUID[uuid] = index;
                    objects.push(object);
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                    }
                } else if (index < nCachedObjects) {
                    knownObject = objects[index];
                    var firstActiveIndex = --nCachedObjects
                        , lastCachedObject = objects[firstActiveIndex];
                    indicesByUUID[lastCachedObject.uuid] = index;
                    objects[index] = lastCachedObject;
                    indicesByUUID[uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j]
                            , lastCached = bindingsForPath[firstActiveIndex]
                            , binding = bindingsForPath[index];
                        bindingsForPath[index] = lastCached;
                        if (binding === undefined) {
                            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                        }
                        bindingsForPath[firstActiveIndex] = binding;
                    }
                } else if (objects[index] !== knownObject) {
                    console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        remove: function () {
            var objects = this._objects
                , nCachedObjects = this.nCachedObjects_
                , indicesByUUID = this._indicesByUUID
                , bindings = this._bindings
                , nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i]
                    , uuid = object.uuid
                    , index = indicesByUUID[uuid];
                if (index !== undefined && index >= nCachedObjects) {
                    var lastCachedIndex = nCachedObjects++
                        , firstActiveObject = objects[lastCachedIndex];
                    indicesByUUID[firstActiveObject.uuid] = index;
                    objects[index] = firstActiveObject;
                    indicesByUUID[uuid] = lastCachedIndex;
                    objects[lastCachedIndex] = object;
                    for (var j = 0, m = nBindings; j !== m; ++j) {
                        var bindingsForPath = bindings[j]
                            , firstActive = bindingsForPath[lastCachedIndex]
                            , binding = bindingsForPath[index];
                        bindingsForPath[index] = firstActive;
                        bindingsForPath[lastCachedIndex] = binding;
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        uncache: function () {
            var objects = this._objects
                , nObjects = objects.length
                , nCachedObjects = this.nCachedObjects_
                , indicesByUUID = this._indicesByUUID
                , bindings = this._bindings
                , nBindings = bindings.length;
            for (var i = 0, n = arguments.length; i !== n; ++i) {
                var object = arguments[i]
                    , uuid = object.uuid
                    , index = indicesByUUID[uuid];
                if (index !== undefined) {
                    delete indicesByUUID[uuid];
                    if (index < nCachedObjects) {
                        var firstActiveIndex = --nCachedObjects
                            , lastCachedObject = objects[firstActiveIndex]
                            , lastIndex = --nObjects
                            , lastObject = objects[lastIndex];
                        indicesByUUID[lastCachedObject.uuid] = index;
                        objects[index] = lastCachedObject;
                        indicesByUUID[lastObject.uuid] = firstActiveIndex;
                        objects[firstActiveIndex] = lastObject;
                        objects.pop();
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j]
                                , lastCached = bindingsForPath[firstActiveIndex]
                                , last = bindingsForPath[lastIndex];
                            bindingsForPath[index] = lastCached;
                            bindingsForPath[firstActiveIndex] = last;
                            bindingsForPath.pop();
                        }
                    } else {
                        var lastIndex = --nObjects
                            , lastObject = objects[lastIndex];
                        indicesByUUID[lastObject.uuid] = index;
                        objects[index] = lastObject;
                        objects.pop();
                        for (var j = 0, m = nBindings; j !== m; ++j) {
                            var bindingsForPath = bindings[j];
                            bindingsForPath[index] = bindingsForPath[lastIndex];
                            bindingsForPath.pop();
                        }
                    }
                }
            }
            this.nCachedObjects_ = nCachedObjects;
        },
        subscribe_: function (path, parsedPath) {
            var indicesByPath = this._bindingsIndicesByPath
                , index = indicesByPath[path]
                , bindings = this._bindings;
            if (index !== undefined)
                return bindings[index];
            var paths = this._paths
                , parsedPaths = this._parsedPaths
                , objects = this._objects
                , nObjects = objects.length
                , nCachedObjects = this.nCachedObjects_
                , bindingsForPath = new Array(nObjects);
            index = bindings.length;
            indicesByPath[path] = index;
            paths.push(path);
            parsedPaths.push(parsedPath);
            bindings.push(bindingsForPath);
            for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                var object = objects[i];
                bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
            }
            return bindingsForPath;
        },
        unsubscribe_: function (path) {
            var indicesByPath = this._bindingsIndicesByPath
                , index = indicesByPath[path];
            if (index !== undefined) {
                var paths = this._paths
                    , parsedPaths = this._parsedPaths
                    , bindings = this._bindings
                    , lastBindingsIndex = bindings.length - 1
                    , lastBindings = bindings[lastBindingsIndex]
                    , lastBindingsPath = path[lastBindingsIndex];
                indicesByPath[lastBindingsPath] = index;
                bindings[index] = lastBindings;
                bindings.pop();
                parsedPaths[index] = parsedPaths[lastBindingsIndex];
                parsedPaths.pop();
                paths[index] = paths[lastBindingsIndex];
                paths.pop();
            }
        }
    });
    function AnimationAction(mixer, clip, localRoot) {
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot || null;
        var tracks = clip.tracks
            , nTracks = tracks.length
            , interpolants = new Array(nTracks);
        var interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
        for (var i = 0; i !== nTracks; ++i) {
            var interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants;
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null;
        this._byClipCacheIndex = null;
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity;
        this.paused = false;
        this.enabled = true;
        this.clampWhenFinished = false;
        this.zeroSlopeAtStart = true;
        this.zeroSlopeAtEnd = true;
    }
    Object.assign(AnimationAction.prototype, {
        play: function () {
            this._mixer._activateAction(this);
            return this;
        },
        stop: function () {
            this._mixer._deactivateAction(this);
            return this.reset();
        },
        reset: function () {
            this.paused = false;
            this.enabled = true;
            this.time = 0;
            this._loopCount = -1;
            this._startTime = null;
            return this.stopFading().stopWarping();
        },
        isRunning: function () {
            return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        },
        isScheduled: function () {
            return this._mixer._isActiveAction(this);
        },
        startAt: function (time) {
            this._startTime = time;
            return this;
        },
        setLoop: function (mode, repetitions) {
            this.loop = mode;
            this.repetitions = repetitions;
            return this;
        },
        setEffectiveWeight: function (weight) {
            this.weight = weight;
            this._effectiveWeight = this.enabled ? weight : 0;
            return this.stopFading();
        },
        getEffectiveWeight: function () {
            return this._effectiveWeight;
        },
        fadeIn: function (duration) {
            return this._scheduleFading(duration, 0, 1);
        },
        fadeOut: function (duration) {
            return this._scheduleFading(duration, 1, 0);
        },
        crossFadeFrom: function (fadeOutAction, duration, warp) {
            fadeOutAction.fadeOut(duration);
            this.fadeIn(duration);
            if (warp) {
                var fadeInDuration = this._clip.duration
                    , fadeOutDuration = fadeOutAction._clip.duration
                    , startEndRatio = fadeOutDuration / fadeInDuration
                    , endStartRatio = fadeInDuration / fadeOutDuration;
                fadeOutAction.warp(1.0, startEndRatio, duration);
                this.warp(endStartRatio, 1.0, duration);
            }
            return this;
        },
        crossFadeTo: function (fadeInAction, duration, warp) {
            return fadeInAction.crossFadeFrom(this, duration, warp);
        },
        stopFading: function () {
            var weightInterpolant = this._weightInterpolant;
            if (weightInterpolant !== null) {
                this._weightInterpolant = null;
                this._mixer._takeBackControlInterpolant(weightInterpolant);
            }
            return this;
        },
        setEffectiveTimeScale: function (timeScale) {
            this.timeScale = timeScale;
            this._effectiveTimeScale = this.paused ? 0 : timeScale;
            return this.stopWarping();
        },
        getEffectiveTimeScale: function () {
            return this._effectiveTimeScale;
        },
        setDuration: function (duration) {
            this.timeScale = this._clip.duration / duration;
            return this.stopWarping();
        },
        syncWith: function (action) {
            this.time = action.time;
            this.timeScale = action.timeScale;
            return this.stopWarping();
        },
        halt: function (duration) {
            return this.warp(this._effectiveTimeScale, 0, duration);
        },
        warp: function (startTimeScale, endTimeScale, duration) {
            var mixer = this._mixer
                , now = mixer.time
                , interpolant = this._timeScaleInterpolant
                , timeScale = this.timeScale;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._timeScaleInterpolant = interpolant;
            }
            var times = interpolant.parameterPositions
                , values = interpolant.sampleValues;
            times[0] = now;
            times[1] = now + duration;
            values[0] = startTimeScale / timeScale;
            values[1] = endTimeScale / timeScale;
            return this;
        },
        stopWarping: function () {
            var timeScaleInterpolant = this._timeScaleInterpolant;
            if (timeScaleInterpolant !== null) {
                this._timeScaleInterpolant = null;
                this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
            }
            return this;
        },
        getMixer: function () {
            return this._mixer;
        },
        getClip: function () {
            return this._clip;
        },
        getRoot: function () {
            return this._localRoot || this._mixer._root;
        },
        _update: function (time, deltaTime, timeDirection, accuIndex) {
            if (!this.enabled) {
                this._updateWeight(time);
                return;
            }
            var startTime = this._startTime;
            if (startTime !== null) {
                var timeRunning = (time - startTime) * timeDirection;
                if (timeRunning < 0 || timeDirection === 0) {
                    return;
                }
                this._startTime = null;
                deltaTime = timeDirection * timeRunning;
            }
            deltaTime *= this._updateTimeScale(time);
            var clipTime = this._updateTime(deltaTime);
            var weight = this._updateWeight(time);
            if (weight > 0) {
                var interpolants = this._interpolants;
                var propertyMixers = this._propertyBindings;
                for (var j = 0, m = interpolants.length; j !== m; ++j) {
                    interpolants[j].evaluate(clipTime);
                    propertyMixers[j].accumulate(accuIndex, weight);
                }
            }
        },
        _updateWeight: function (time) {
            var weight = 0;
            if (this.enabled) {
                weight = this.weight;
                var interpolant = this._weightInterpolant;
                if (interpolant !== null) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    weight *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopFading();
                        if (interpolantValue === 0) {
                            this.enabled = false;
                        }
                    }
                }
            }
            this._effectiveWeight = weight;
            return weight;
        },
        _updateTimeScale: function (time) {
            var timeScale = 0;
            if (!this.paused) {
                timeScale = this.timeScale;
                var interpolant = this._timeScaleInterpolant;
                if (interpolant !== null) {
                    var interpolantValue = interpolant.evaluate(time)[0];
                    timeScale *= interpolantValue;
                    if (time > interpolant.parameterPositions[1]) {
                        this.stopWarping();
                        if (timeScale === 0) {
                            this.paused = true;
                        } else {
                            this.timeScale = timeScale;
                        }
                    }
                }
            }
            this._effectiveTimeScale = timeScale;
            return timeScale;
        },
        _updateTime: function (deltaTime) {
            var time = this.time + deltaTime;
            if (deltaTime === 0)
                return time;
            var duration = this._clip.duration
                , loop = this.loop
                , loopCount = this._loopCount;
            if (loop === LoopOnce) {
                if (loopCount === -1) {
                    this._loopCount = 0;
                    this._setEndings(true, true, false);
                }
                handle_stop: {
                    if (time >= duration) {
                        time = duration;
                    } else if (time < 0) {
                        time = 0;
                    } else
                        break handle_stop;
                    if (this.clampWhenFinished)
                        this.paused = true;
                    else
                        this.enabled = false;
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: deltaTime < 0 ? -1 : 1
                    });
                }
            } else {
                var pingPong = (loop === LoopPingPong);
                if (loopCount === -1) {
                    if (deltaTime >= 0) {
                        loopCount = 0;
                        this._setEndings(true, this.repetitions === 0, pingPong);
                    } else {
                        this._setEndings(this.repetitions === 0, true, pingPong);
                    }
                }
                if (time >= duration || time < 0) {
                    var loopDelta = Math.floor(time / duration);
                    time -= duration * loopDelta;
                    loopCount += Math.abs(loopDelta);
                    var pending = this.repetitions - loopCount;
                    if (pending <= 0) {
                        if (this.clampWhenFinished)
                            this.paused = true;
                        else
                            this.enabled = false;
                        time = deltaTime > 0 ? duration : 0;
                        this._mixer.dispatchEvent({
                            type: 'finished',
                            action: this,
                            direction: deltaTime > 0 ? 1 : -1
                        });
                    } else {
                        if (pending === 1) {
                            var atStart = deltaTime < 0;
                            this._setEndings(atStart, !atStart, pingPong);
                        } else {
                            this._setEndings(false, false, pingPong);
                        }
                        this._loopCount = loopCount;
                        this._mixer.dispatchEvent({
                            type: 'loop',
                            action: this,
                            loopDelta: loopDelta
                        });
                    }
                }
                if (pingPong && (loopCount & 1) === 1) {
                    this.time = time;
                    return duration - time;
                }
            }
            this.time = time;
            return time;
        },
        _setEndings: function (atStart, atEnd, pingPong) {
            var settings = this._interpolantSettings;
            if (pingPong) {
                settings.endingStart = ZeroSlopeEnding;
                settings.endingEnd = ZeroSlopeEnding;
            } else {
                if (atStart) {
                    settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                    settings.endingStart = WrapAroundEnding;
                }
                if (atEnd) {
                    settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
                } else {
                    settings.endingEnd = WrapAroundEnding;
                }
            }
        },
        _scheduleFading: function (duration, weightNow, weightThen) {
            var mixer = this._mixer
                , now = mixer.time
                , interpolant = this._weightInterpolant;
            if (interpolant === null) {
                interpolant = mixer._lendControlInterpolant();
                this._weightInterpolant = interpolant;
            }
            var times = interpolant.parameterPositions
                , values = interpolant.sampleValues;
            times[0] = now;
            values[0] = weightNow;
            times[1] = now + duration;
            values[1] = weightThen;
            return this;
        }
    });
    function AnimationMixer(root) {
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1.0;
    }
    AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
        constructor: AnimationMixer,
        _bindAction: function (action, prototypeAction) {
            var root = action._localRoot || this._root
                , tracks = action._clip.tracks
                , nTracks = tracks.length
                , bindings = action._propertyBindings
                , interpolants = action._interpolants
                , rootUuid = root.uuid
                , bindingsByRoot = this._bindingsByRootAndName
                , bindingsByName = bindingsByRoot[rootUuid];
            if (bindingsByName === undefined) {
                bindingsByName = {};
                bindingsByRoot[rootUuid] = bindingsByName;
            }
            for (var i = 0; i !== nTracks; ++i) {
                var track = tracks[i]
                    , trackName = track.name
                    , binding = bindingsByName[trackName];
                if (binding !== undefined) {
                    bindings[i] = binding;
                } else {
                    binding = bindings[i];
                    if (binding !== undefined) {
                        if (binding._cacheIndex === null) {
                            ++binding.referenceCount;
                            this._addInactiveBinding(binding, rootUuid, trackName);
                        }
                        continue;
                    }
                    var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                    binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                    ++binding.referenceCount;
                    this._addInactiveBinding(binding, rootUuid, trackName);
                    bindings[i] = binding;
                }
                interpolants[i].resultBuffer = binding.buffer;
            }
        },
        _activateAction: function (action) {
            if (!this._isActiveAction(action)) {
                if (action._cacheIndex === null) {
                    var rootUuid = (action._localRoot || this._root).uuid
                        , clipUuid = action._clip.uuid
                        , actionsForClip = this._actionsByClip[clipUuid];
                    this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                    this._addInactiveAction(action, clipUuid, rootUuid);
                }
                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    if (binding.useCount++ === 0) {
                        this._lendBinding(binding);
                        binding.saveOriginalState();
                    }
                }
                this._lendAction(action);
            }
        },
        _deactivateAction: function (action) {
            if (this._isActiveAction(action)) {
                var bindings = action._propertyBindings;
                for (var i = 0, n = bindings.length; i !== n; ++i) {
                    var binding = bindings[i];
                    if (--binding.useCount === 0) {
                        binding.restoreOriginalState();
                        this._takeBackBinding(binding);
                    }
                }
                this._takeBackAction(action);
            }
        },
        _initMemoryManager: function () {
            this._actions = [];
            this._nActiveActions = 0;
            this._actionsByClip = {};
            this._bindings = [];
            this._nActiveBindings = 0;
            this._bindingsByRootAndName = {};
            this._controlInterpolants = [];
            this._nActiveControlInterpolants = 0;
            var scope = this;
            this.stats = {
                actions: {
                    get total() {
                        return scope._actions.length;
                    },
                    get inUse() {
                        return scope._nActiveActions;
                    }
                },
                bindings: {
                    get total() {
                        return scope._bindings.length;
                    },
                    get inUse() {
                        return scope._nActiveBindings;
                    }
                },
                controlInterpolants: {
                    get total() {
                        return scope._controlInterpolants.length;
                    },
                    get inUse() {
                        return scope._nActiveControlInterpolants;
                    }
                }
            };
        },
        _isActiveAction: function (action) {
            var index = action._cacheIndex;
            return index !== null && index < this._nActiveActions;
        },
        _addInactiveAction: function (action, clipUuid, rootUuid) {
            var actions = this._actions
                , actionsByClip = this._actionsByClip
                , actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip === undefined) {
                actionsForClip = {
                    knownActions: [action],
                    actionByRoot: {}
                };
                action._byClipCacheIndex = 0;
                actionsByClip[clipUuid] = actionsForClip;
            } else {
                var knownActions = actionsForClip.knownActions;
                action._byClipCacheIndex = knownActions.length;
                knownActions.push(action);
            }
            action._cacheIndex = actions.length;
            actions.push(action);
            actionsForClip.actionByRoot[rootUuid] = action;
        },
        _removeInactiveAction: function (action) {
            var actions = this._actions
                , lastInactiveAction = actions[actions.length - 1]
                , cacheIndex = action._cacheIndex;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            action._cacheIndex = null;
            var clipUuid = action._clip.uuid
                , actionsByClip = this._actionsByClip
                , actionsForClip = actionsByClip[clipUuid]
                , knownActionsForClip = actionsForClip.knownActions
                , lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1]
                , byClipCacheIndex = action._byClipCacheIndex;
            lastKnownAction._byClipCacheIndex = byClipCacheIndex;
            knownActionsForClip[byClipCacheIndex] = lastKnownAction;
            knownActionsForClip.pop();
            action._byClipCacheIndex = null;
            var actionByRoot = actionsForClip.actionByRoot
                , rootUuid = (action._localRoot || this._root).uuid;
            delete actionByRoot[rootUuid];
            if (knownActionsForClip.length === 0) {
                delete actionsByClip[clipUuid];
            }
            this._removeInactiveBindingsForAction(action);
        },
        _removeInactiveBindingsForAction: function (action) {
            var bindings = action._propertyBindings;
            for (var i = 0, n = bindings.length; i !== n; ++i) {
                var binding = bindings[i];
                if (--binding.referenceCount === 0) {
                    this._removeInactiveBinding(binding);
                }
            }
        },
        _lendAction: function (action) {
            var actions = this._actions
                , prevIndex = action._cacheIndex
                , lastActiveIndex = this._nActiveActions++
                , firstInactiveAction = actions[lastActiveIndex];
            action._cacheIndex = lastActiveIndex;
            actions[lastActiveIndex] = action;
            firstInactiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = firstInactiveAction;
        },
        _takeBackAction: function (action) {
            var actions = this._actions
                , prevIndex = action._cacheIndex
                , firstInactiveIndex = --this._nActiveActions
                , lastActiveAction = actions[firstInactiveIndex];
            action._cacheIndex = firstInactiveIndex;
            actions[firstInactiveIndex] = action;
            lastActiveAction._cacheIndex = prevIndex;
            actions[prevIndex] = lastActiveAction;
        },
        _addInactiveBinding: function (binding, rootUuid, trackName) {
            var bindingsByRoot = this._bindingsByRootAndName
                , bindingByName = bindingsByRoot[rootUuid]
                , bindings = this._bindings;
            if (bindingByName === undefined) {
                bindingByName = {};
                bindingsByRoot[rootUuid] = bindingByName;
            }
            bindingByName[trackName] = binding;
            binding._cacheIndex = bindings.length;
            bindings.push(binding);
        },
        _removeInactiveBinding: function (binding) {
            var bindings = this._bindings
                , propBinding = binding.binding
                , rootUuid = propBinding.rootNode.uuid
                , trackName = propBinding.path
                , bindingsByRoot = this._bindingsByRootAndName
                , bindingByName = bindingsByRoot[rootUuid]
                , lastInactiveBinding = bindings[bindings.length - 1]
                , cacheIndex = binding._cacheIndex;
            lastInactiveBinding._cacheIndex = cacheIndex;
            bindings[cacheIndex] = lastInactiveBinding;
            bindings.pop();
            delete bindingByName[trackName];
            remove_empty_map: {
                for (var _ in bindingByName)
                    break remove_empty_map;
                delete bindingsByRoot[rootUuid];
            }
        },
        _lendBinding: function (binding) {
            var bindings = this._bindings
                , prevIndex = binding._cacheIndex
                , lastActiveIndex = this._nActiveBindings++
                , firstInactiveBinding = bindings[lastActiveIndex];
            binding._cacheIndex = lastActiveIndex;
            bindings[lastActiveIndex] = binding;
            firstInactiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = firstInactiveBinding;
        },
        _takeBackBinding: function (binding) {
            var bindings = this._bindings
                , prevIndex = binding._cacheIndex
                , firstInactiveIndex = --this._nActiveBindings
                , lastActiveBinding = bindings[firstInactiveIndex];
            binding._cacheIndex = firstInactiveIndex;
            bindings[firstInactiveIndex] = binding;
            lastActiveBinding._cacheIndex = prevIndex;
            bindings[prevIndex] = lastActiveBinding;
        },
        _lendControlInterpolant: function () {
            var interpolants = this._controlInterpolants
                , lastActiveIndex = this._nActiveControlInterpolants++
                , interpolant = interpolants[lastActiveIndex];
            if (interpolant === undefined) {
                interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[lastActiveIndex] = interpolant;
            }
            return interpolant;
        },
        _takeBackControlInterpolant: function (interpolant) {
            var interpolants = this._controlInterpolants
                , prevIndex = interpolant.__cacheIndex
                , firstInactiveIndex = --this._nActiveControlInterpolants
                , lastActiveInterpolant = interpolants[firstInactiveIndex];
            interpolant.__cacheIndex = firstInactiveIndex;
            interpolants[firstInactiveIndex] = interpolant;
            lastActiveInterpolant.__cacheIndex = prevIndex;
            interpolants[prevIndex] = lastActiveInterpolant;
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function (clip, optionalRoot) {
            var root = optionalRoot || this._root
                , rootUuid = root.uuid
                , clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip
                , clipUuid = clipObject !== null ? clipObject.uuid : clip
                , actionsForClip = this._actionsByClip[clipUuid]
                , prototypeAction = null;
            if (actionsForClip !== undefined) {
                var existingAction = actionsForClip.actionByRoot[rootUuid];
                if (existingAction !== undefined) {
                    return existingAction;
                }
                prototypeAction = actionsForClip.knownActions[0];
                if (clipObject === null)
                    clipObject = prototypeAction._clip;
            }
            if (clipObject === null)
                return null;
            var newAction = new AnimationAction(this, clipObject, optionalRoot);
            this._bindAction(newAction, prototypeAction);
            this._addInactiveAction(newAction, clipUuid, rootUuid);
            return newAction;
        },
        existingAction: function (clip, optionalRoot) {
            var root = optionalRoot || this._root
                , rootUuid = root.uuid
                , clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip
                , clipUuid = clipObject ? clipObject.uuid : clip
                , actionsForClip = this._actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                return actionsForClip.actionByRoot[rootUuid] || null;
            }
            return null;
        },
        stopAllAction: function () {
            var actions = this._actions
                , nActions = this._nActiveActions
                , bindings = this._bindings
                , nBindings = this._nActiveBindings;
            this._nActiveActions = 0;
            this._nActiveBindings = 0;
            for (var i = 0; i !== nActions; ++i) {
                actions[i].reset();
            }
            for (var i = 0; i !== nBindings; ++i) {
                bindings[i].useCount = 0;
            }
            return this;
        },
        update: function (deltaTime) {
            deltaTime *= this.timeScale;
            var actions = this._actions
                , nActions = this._nActiveActions
                , time = this.time += deltaTime
                , timeDirection = Math.sign(deltaTime)
                , accuIndex = this._accuIndex ^= 1;
            for (var i = 0; i !== nActions; ++i) {
                var action = actions[i];
                action._update(time, deltaTime, timeDirection, accuIndex);
            }
            var bindings = this._bindings
                , nBindings = this._nActiveBindings;
            for (var i = 0; i !== nBindings; ++i) {
                bindings[i].apply(accuIndex);
            }
            return this;
        },
        getRoot: function () {
            return this._root;
        },
        uncacheClip: function (clip) {
            var actions = this._actions
                , clipUuid = clip.uuid
                , actionsByClip = this._actionsByClip
                , actionsForClip = actionsByClip[clipUuid];
            if (actionsForClip !== undefined) {
                var actionsToRemove = actionsForClip.knownActions;
                for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                    var action = actionsToRemove[i];
                    this._deactivateAction(action);
                    var cacheIndex = action._cacheIndex
                        , lastInactiveAction = actions[actions.length - 1];
                    action._cacheIndex = null;
                    action._byClipCacheIndex = null;
                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[cacheIndex] = lastInactiveAction;
                    actions.pop();
                    this._removeInactiveBindingsForAction(action);
                }
                delete actionsByClip[clipUuid];
            }
        },
        uncacheRoot: function (root) {
            var rootUuid = root.uuid
                , actionsByClip = this._actionsByClip;
            for (var clipUuid in actionsByClip) {
                var actionByRoot = actionsByClip[clipUuid].actionByRoot
                    , action = actionByRoot[rootUuid];
                if (action !== undefined) {
                    this._deactivateAction(action);
                    this._removeInactiveAction(action);
                }
            }
            var bindingsByRoot = this._bindingsByRootAndName
                , bindingByName = bindingsByRoot[rootUuid];
            if (bindingByName !== undefined) {
                for (var trackName in bindingByName) {
                    var binding = bindingByName[trackName];
                    binding.restoreOriginalState();
                    this._removeInactiveBinding(binding);
                }
            }
        },
        uncacheAction: function (clip, optionalRoot) {
            var action = this.existingAction(clip, optionalRoot);
            if (action !== null) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
    });
    function Uniform(value) {
        if (typeof value === 'string') {
            console.warn('THREE.Uniform: Type parameter is no longer needed.');
            value = arguments[1];
        }
        this.value = value;
    }
    Uniform.prototype.clone = function () {
        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
    }
        ;
    function InstancedBufferGeometry() {
        BufferGeometry.call(this);
        this.type = 'InstancedBufferGeometry';
        this.maxInstancedCount = undefined;
    }
    InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
        constructor: InstancedBufferGeometry,
        isInstancedBufferGeometry: true,
        copy: function (source) {
            BufferGeometry.prototype.copy.call(this, source);
            this.maxInstancedCount = source.maxInstancedCount;
            return this;
        },
        clone: function () {
            return new this.constructor().copy(this);
        }
    });
    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized === true;
    }
    Object.defineProperties(InterleavedBufferAttribute.prototype, {
        count: {
            get: function () {
                return this.data.count;
            }
        },
        array: {
            get: function () {
                return this.data.array;
            }
        }
    });
    Object.assign(InterleavedBufferAttribute.prototype, {
        isInterleavedBufferAttribute: true,
        setX: function (index, x) {
            this.data.array[index * this.data.stride + this.offset] = x;
            return this;
        },
        setY: function (index, y) {
            this.data.array[index * this.data.stride + this.offset + 1] = y;
            return this;
        },
        setZ: function (index, z) {
            this.data.array[index * this.data.stride + this.offset + 2] = z;
            return this;
        },
        setW: function (index, w) {
            this.data.array[index * this.data.stride + this.offset + 3] = w;
            return this;
        },
        getX: function (index) {
            return this.data.array[index * this.data.stride + this.offset];
        },
        getY: function (index) {
            return this.data.array[index * this.data.stride + this.offset + 1];
        },
        getZ: function (index) {
            return this.data.array[index * this.data.stride + this.offset + 2];
        },
        getW: function (index) {
            return this.data.array[index * this.data.stride + this.offset + 3];
        },
        setXY: function (index, x, y) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            return this;
        },
        setXYZ: function (index, x, y, z) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            return this;
        },
        setXYZW: function (index, x, y, z, w) {
            index = index * this.data.stride + this.offset;
            this.data.array[index + 0] = x;
            this.data.array[index + 1] = y;
            this.data.array[index + 2] = z;
            this.data.array[index + 3] = w;
            return this;
        }
    });
    function InterleavedBuffer(array, stride) {
        this.array = array;
        this.stride = stride;
        this.count = array !== undefined ? array.length / stride : 0;
        this.dynamic = false;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0;
    }
    Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
        set: function (value) {
            if (value === true)
                this.version++;
        }
    });
    Object.assign(InterleavedBuffer.prototype, {
        isInterleavedBuffer: true,
        onUploadCallback: function () { },
        setArray: function (array) {
            if (Array.isArray(array)) {
                throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
            }
            this.count = array !== undefined ? array.length / this.stride : 0;
            this.array = array;
            return this;
        },
        setDynamic: function (value) {
            this.dynamic = value;
            return this;
        },
        copy: function (source) {
            this.array = new source.array.constructor(source.array);
            this.count = source.count;
            this.stride = source.stride;
            this.dynamic = source.dynamic;
            return this;
        },
        copyAt: function (index1, attribute, index2) {
            index1 *= this.stride;
            index2 *= attribute.stride;
            for (var i = 0, l = this.stride; i < l; i++) {
                this.array[index1 + i] = attribute.array[index2 + i];
            }
            return this;
        },
        set: function (value, offset) {
            if (offset === undefined)
                offset = 0;
            this.array.set(value, offset);
            return this;
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        onUpload: function (callback) {
            this.onUploadCallback = callback;
            return this;
        }
    });
    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
        InterleavedBuffer.call(this, array, stride);
        this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
        constructor: InstancedInterleavedBuffer,
        isInstancedInterleavedBuffer: true,
        copy: function (source) {
            InterleavedBuffer.prototype.copy.call(this, source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        }
    });
    function InstancedBufferAttribute(array, itemSize, meshPerAttribute) {
        BufferAttribute.call(this, array, itemSize);
        this.meshPerAttribute = meshPerAttribute || 1;
    }
    InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
        constructor: InstancedBufferAttribute,
        isInstancedBufferAttribute: true,
        copy: function (source) {
            BufferAttribute.prototype.copy.call(this, source);
            this.meshPerAttribute = source.meshPerAttribute;
            return this;
        }
    });
    function Raycaster(origin, direction, near, far) {
        this.ray = new Ray(origin, direction);
        this.near = near || 0;
        this.far = far || Infinity;
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function () {
                    console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                    return this.Points;
                }
            }
        });
    }
    function ascSort(a, b) {
        return a.distance - b.distance;
    }
    function intersectObject(object, raycaster, intersects, recursive) {
        if (object.visible === false)
            return;
        object.raycast(raycaster, intersects);
        if (recursive === true) {
            var children = object.children;
            for (var i = 0, l = children.length; i < l; i++) {
                intersectObject(children[i], raycaster, intersects, true);
            }
        }
    }
    Object.assign(Raycaster.prototype, {
        linePrecision: 1,
        set: function (origin, direction) {
            this.ray.set(origin, direction);
        },
        setFromCamera: function (coords, camera) {
            if ((camera && camera.isPerspectiveCamera)) {
                this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            } else if ((camera && camera.isOrthographicCamera)) {
                this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
                this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            } else {
                console.error('THREE.Raycaster: Unsupported camera type.');
            }
        },
        intersectObject: function (object, recursive, optionalTarget) {
            var intersects = optionalTarget || [];
            intersectObject(object, this, intersects, recursive);
            intersects.sort(ascSort);
            return intersects;
        },
        intersectObjects: function (objects, recursive, optionalTarget) {
            var intersects = optionalTarget || [];
            if (Array.isArray(objects) === false) {
                console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
                return intersects;
            }
            for (var i = 0, l = objects.length; i < l; i++) {
                intersectObject(objects[i], this, intersects, recursive);
            }
            intersects.sort(ascSort);
            return intersects;
        }
    });
    function Clock(autoStart) {
        this.autoStart = (autoStart !== undefined) ? autoStart : true;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
    }
    Object.assign(Clock.prototype, {
        start: function () {
            this.startTime = (typeof performance === 'undefined' ? Date : performance).now();
            this.oldTime = this.startTime;
            this.elapsedTime = 0;
            this.running = true;
        },
        stop: function () {
            this.getElapsedTime();
            this.running = false;
            this.autoStart = false;
        },
        getElapsedTime: function () {
            this.getDelta();
            return this.elapsedTime;
        },
        getDelta: function () {
            var diff = 0;
            if (this.autoStart && !this.running) {
                this.start();
                return 0;
            }
            if (this.running) {
                var newTime = (typeof performance === 'undefined' ? Date : performance).now();
                diff = (newTime - this.oldTime) / 1000;
                this.oldTime = newTime;
                this.elapsedTime += diff;
            }
            return diff;
        }
    });
    function Spherical(radius, phi, theta) {
        this.radius = (radius !== undefined) ? radius : 1.0;
        this.phi = (phi !== undefined) ? phi : 0;
        this.theta = (theta !== undefined) ? theta : 0;
        return this;
    }
    Object.assign(Spherical.prototype, {
        set: function (radius, phi, theta) {
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
            return this;
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (other) {
            this.radius = other.radius;
            this.phi = other.phi;
            this.theta = other.theta;
            return this;
        },
        makeSafe: function () {
            var EPS = 0.000001;
            this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
            return this;
        },
        setFromVector3: function (vec3) {
            this.radius = vec3.length();
            if (this.radius === 0) {
                this.theta = 0;
                this.phi = 0;
            } else {
                this.theta = Math.atan2(vec3.x, vec3.z);
                this.phi = Math.acos(_Math.clamp(vec3.y / this.radius, -1, 1));
            }
            return this;
        }
    });
    function Cylindrical(radius, theta, y) {
        this.radius = (radius !== undefined) ? radius : 1.0;
        this.theta = (theta !== undefined) ? theta : 0;
        this.y = (y !== undefined) ? y : 0;
        return this;
    }
    Object.assign(Cylindrical.prototype, {
        set: function (radius, theta, y) {
            this.radius = radius;
            this.theta = theta;
            this.y = y;
            return this;
        },
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (other) {
            this.radius = other.radius;
            this.theta = other.theta;
            this.y = other.y;
            return this;
        },
        setFromVector3: function (vec3) {
            this.radius = Math.sqrt(vec3.x * vec3.x + vec3.z * vec3.z);
            this.theta = Math.atan2(vec3.x, vec3.z);
            this.y = vec3.y;
            return this;
        }
    });
    function Box2(min, max) {
        this.min = (min !== undefined) ? min : new Vector2(+Infinity, +Infinity);
        this.max = (max !== undefined) ? max : new Vector2(-Infinity, -Infinity);
    }
    Object.assign(Box2.prototype, {
        set: function (min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        },
        setFromPoints: function (points) {
            this.makeEmpty();
            for (var i = 0, il = points.length; i < il; i++) {
                this.expandByPoint(points[i]);
            }
            return this;
        },
        setFromCenterAndSize: function () {
            var v1 = new Vector2();
            return function setFromCenterAndSize(center, size) {
                var halfSize = v1.copy(size).multiplyScalar(0.5);
                this.min.copy(center).sub(halfSize);
                this.max.copy(center).add(halfSize);
                return this;
            }
                ;
        }(),
        clone: function () {
            return new this.constructor().copy(this);
        },
        copy: function (box) {
            this.min.copy(box.min);
            this.max.copy(box.max);
            return this;
        },
        makeEmpty: function () {
            this.min.x = this.min.y = +Infinity;
            this.max.x = this.max.y = -Infinity;
            return this;
        },
        isEmpty: function () {
            return (this.max.x < this.min.x) || (this.max.y < this.min.y);
        },
        getCenter: function (target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .getCenter() target is now required');
                target = new Vector2();
            }
            return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
        },
        getSize: function (target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .getSize() target is now required');
                target = new Vector2();
            }
            return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
        },
        expandByPoint: function (point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        },
        expandByVector: function (vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        },
        expandByScalar: function (scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        },
        containsPoint: function (point) {
            return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
        },
        containsBox: function (box) {
            return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
        },
        getParameter: function (point, target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .getParameter() target is now required');
                target = new Vector2();
            }
            return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
        },
        intersectsBox: function (box) {
            return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
        },
        clampPoint: function (point, target) {
            if (target === undefined) {
                console.warn('THREE.Box2: .clampPoint() target is now required');
                target = new Vector2();
            }
            return target.copy(point).clamp(this.min, this.max);
        },
        distanceToPoint: function () {
            var v1 = new Vector2();
            return function distanceToPoint(point) {
                var clampedPoint = v1.copy(point).clamp(this.min, this.max);
                return clampedPoint.sub(point).length();
            }
                ;
        }(),
        intersect: function (box) {
            this.min.max(box.min);
            this.max.min(box.max);
            return this;
        },
        union: function (box) {
            this.min.min(box.min);
            this.max.max(box.max);
            return this;
        },
        translate: function (offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        },
        equals: function (box) {
            return box.min.equals(this.min) && box.max.equals(this.max);
        }
    });
    function ImmediateRenderObject(material) {
        Object3D.call(this);
        this.material = material;
        this.render = function () { }
            ;
    }
    ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
    ImmediateRenderObject.prototype.isImmediateRenderObject = true;
    function VertexNormalsHelper(object, size, hex, linewidth) {
        this.object = object;
        this.size = (size !== undefined) ? size : 1;
        var color = (hex !== undefined) ? hex : 0xff0000;
        var width = (linewidth !== undefined) ? linewidth : 1;
        var nNormals = 0;
        var objGeometry = this.object.geometry;
        if (objGeometry && objGeometry.isGeometry) {
            nNormals = objGeometry.faces.length * 3;
        } else if (objGeometry && objGeometry.isBufferGeometry) {
            nNormals = objGeometry.attributes.normal.count;
        }
        var geometry = new BufferGeometry();
        var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
        geometry.addAttribute('position', positions);
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        }));
        this.matrixAutoUpdate = false;
        this.update();
    }
    VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
    VertexNormalsHelper.prototype.update = (function () {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var normalMatrix = new Matrix3();
        return function update() {
            var keys = ['a', 'b', 'c'];
            this.object.updateMatrixWorld(true);
            normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld;
            var position = this.geometry.attributes.position;
            var objGeometry = this.object.geometry;
            if (objGeometry && objGeometry.isGeometry) {
                var vertices = objGeometry.vertices;
                var faces = objGeometry.faces;
                var idx = 0;
                for (var i = 0, l = faces.length; i < l; i++) {
                    var face = faces[i];
                    for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
                        var vertex = vertices[face[keys[j]]];
                        var normal = face.vertexNormals[j];
                        v1.copy(vertex).applyMatrix4(matrixWorld);
                        v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                        position.setXYZ(idx, v1.x, v1.y, v1.z);
                        idx = idx + 1;
                        position.setXYZ(idx, v2.x, v2.y, v2.z);
                        idx = idx + 1;
                    }
                }
            } else if (objGeometry && objGeometry.isBufferGeometry) {
                var objPos = objGeometry.attributes.position;
                var objNorm = objGeometry.attributes.normal;
                var idx = 0;
                for (var j = 0, jl = objPos.count; j < jl; j++) {
                    v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
                    v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
                    v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                    position.setXYZ(idx, v1.x, v1.y, v1.z);
                    idx = idx + 1;
                    position.setXYZ(idx, v2.x, v2.y, v2.z);
                    idx = idx + 1;
                }
            }
            position.needsUpdate = true;
        }
            ;
    }());
    function SpotLightHelper(light, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        var geometry = new BufferGeometry();
        var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var i = 0, j = 1, l = 32; i < l; i++ ,
            j++) {
            var p1 = (i / l) * Math.PI * 2;
            var p2 = (j / l) * Math.PI * 2;
            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
        var material = new LineBasicMaterial({
            fog: false
        });
        this.cone = new LineSegments(geometry, material);
        this.add(this.cone);
        this.update();
    }
    SpotLightHelper.prototype = Object.create(Object3D.prototype);
    SpotLightHelper.prototype.constructor = SpotLightHelper;
    SpotLightHelper.prototype.dispose = function () {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
    }
        ;
    SpotLightHelper.prototype.update = function () {
        var vector = new Vector3();
        var vector2 = new Vector3();
        return function update() {
            this.light.updateMatrixWorld();
            var coneLength = this.light.distance ? this.light.distance : 1000;
            var coneWidth = coneLength * Math.tan(this.light.angle);
            this.cone.scale.set(coneWidth, coneWidth, coneLength);
            vector.setFromMatrixPosition(this.light.matrixWorld);
            vector2.setFromMatrixPosition(this.light.target.matrixWorld);
            this.cone.lookAt(vector2.sub(vector));
            if (this.color !== undefined) {
                this.cone.material.color.set(this.color);
            } else {
                this.cone.material.color.copy(this.light.color);
            }
        }
            ;
    }();
    function getBoneList(object) {
        var boneList = [];
        if (object && object.isBone) {
            boneList.push(object);
        }
        for (var i = 0; i < object.children.length; i++) {
            boneList.push.apply(boneList, getBoneList(object.children[i]));
        }
        return boneList;
    }
    function SkeletonHelper(object) {
        var bones = getBoneList(object);
        var geometry = new BufferGeometry();
        var vertices = [];
        var colors = [];
        var color1 = new Color(0, 0, 1);
        var color2 = new Color(0, 1, 0);
        for (var i = 0; i < bones.length; i++) {
            var bone = bones[i];
            if (bone.parent && bone.parent.isBone) {
                vertices.push(0, 0, 0);
                vertices.push(0, 0, 0);
                colors.push(color1.r, color1.g, color1.b);
                colors.push(color2.r, color2.g, color2.b);
            }
        }
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        LineSegments.call(this, geometry, material);
        this.root = object;
        this.bones = bones;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
    }
    SkeletonHelper.prototype = Object.create(LineSegments.prototype);
    SkeletonHelper.prototype.constructor = SkeletonHelper;
    SkeletonHelper.prototype.updateMatrixWorld = function () {
        var vector = new Vector3();
        var boneMatrix = new Matrix4();
        var matrixWorldInv = new Matrix4();
        return function updateMatrixWorld(force) {
            var bones = this.bones;
            var geometry = this.geometry;
            var position = geometry.getAttribute('position');
            matrixWorldInv.getInverse(this.root.matrixWorld);
            for (var i = 0, j = 0; i < bones.length; i++) {
                var bone = bones[i];
                if (bone.parent && bone.parent.isBone) {
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
                    vector.setFromMatrixPosition(boneMatrix);
                    position.setXYZ(j, vector.x, vector.y, vector.z);
                    boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
                    vector.setFromMatrixPosition(boneMatrix);
                    position.setXYZ(j + 1, vector.x, vector.y, vector.z);
                    j += 2;
                }
            }
            geometry.getAttribute('position').needsUpdate = true;
            Object3D.prototype.updateMatrixWorld.call(this, force);
        }
            ;
    }();
    function PointLightHelper(light, sphereSize, color) {
        this.light = light;
        this.light.updateMatrixWorld();
        this.color = color;
        var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
        var material = new MeshBasicMaterial({
            wireframe: true,
            fog: false
        });
        Mesh.call(this, geometry, material);
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
    }
    PointLightHelper.prototype = Object.create(Mesh.prototype);
    PointLightHelper.prototype.constructor = PointLightHelper;
    PointLightHelper.prototype.dispose = function () {
        this.geometry.dispose();
        this.material.dispose();
    }
        ;
    PointLightHelper.prototype.update = function () {
        if (this.color !== undefined) {
            this.material.color.set(this.color);
        } else {
            this.material.color.copy(this.light.color);
        }
    }
        ;
    function RectAreaLightHelper(light, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        var material = new LineBasicMaterial({
            fog: false
        });
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new BufferAttribute(new Float32Array(5 * 3), 3));
        this.line = new Line(geometry, material);
        this.add(this.line);
        this.update();
    }
    RectAreaLightHelper.prototype = Object.create(Object3D.prototype);
    RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
    RectAreaLightHelper.prototype.dispose = function () {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    }
        ;
    RectAreaLightHelper.prototype.update = function () {
        var hx = this.light.width * 0.5;
        var hy = this.light.height * 0.5;
        var position = this.line.geometry.attributes.position;
        var array = position.array;
        array[0] = hx;
        array[1] = -hy;
        array[2] = 0;
        array[3] = hx;
        array[4] = hy;
        array[5] = 0;
        array[6] = -hx;
        array[7] = hy;
        array[8] = 0;
        array[9] = -hx;
        array[10] = -hy;
        array[11] = 0;
        array[12] = hx;
        array[13] = -hy;
        array[14] = 0;
        position.needsUpdate = true;
        if (this.color !== undefined) {
            this.line.material.color.set(this.color);
        } else {
            this.line.material.color.copy(this.light.color);
        }
    }
        ;
    function HemisphereLightHelper(light, size, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        var geometry = new OctahedronBufferGeometry(size);
        geometry.rotateY(Math.PI * 0.5);
        this.material = new MeshBasicMaterial({
            wireframe: true,
            fog: false
        });
        if (this.color === undefined)
            this.material.vertexColors = VertexColors;
        var position = geometry.getAttribute('position');
        var colors = new Float32Array(position.count * 3);
        geometry.addAttribute('color', new BufferAttribute(colors, 3));
        this.add(new Mesh(geometry, this.material));
        this.update();
    }
    HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
    HemisphereLightHelper.prototype.dispose = function () {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    }
        ;
    HemisphereLightHelper.prototype.update = function () {
        var vector = new Vector3();
        var color1 = new Color();
        var color2 = new Color();
        return function update() {
            var mesh = this.children[0];
            if (this.color !== undefined) {
                this.material.color.set(this.color);
            } else {
                var colors = mesh.geometry.getAttribute('color');
                color1.copy(this.light.color);
                color2.copy(this.light.groundColor);
                for (var i = 0, l = colors.count; i < l; i++) {
                    var color = (i < (l / 2)) ? color1 : color2;
                    colors.setXYZ(i, color.r, color.g, color.b);
                }
                colors.needsUpdate = true;
            }
            mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        }
            ;
    }();
    function GridHelper(size, divisions, color1, color2) {
        size = size || 10;
        divisions = divisions || 10;
        color1 = new Color(color1 !== undefined ? color1 : 0x444444);
        color2 = new Color(color2 !== undefined ? color2 : 0x888888);
        var center = divisions / 2;
        var step = size / divisions;
        var halfSize = size / 2;
        var vertices = []
            , colors = [];
        for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++ ,
            k += step) {
            vertices.push(-halfSize, 0, k, halfSize, 0, k);
            vertices.push(k, 0, -halfSize, k, 0, halfSize);
            var color = i === center ? color1 : color2;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
            color.toArray(colors, j);
            j += 3;
        }
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    GridHelper.prototype = Object.create(LineSegments.prototype);
    GridHelper.prototype.constructor = GridHelper;
    function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
        radius = radius || 10;
        radials = radials || 16;
        circles = circles || 8;
        divisions = divisions || 64;
        color1 = new Color(color1 !== undefined ? color1 : 0x444444);
        color2 = new Color(color2 !== undefined ? color2 : 0x888888);
        var vertices = [];
        var colors = [];
        var x, z;
        var v, i, j, r, color;
        for (i = 0; i <= radials; i++) {
            v = (i / radials) * (Math.PI * 2);
            x = Math.sin(v) * radius;
            z = Math.cos(v) * radius;
            vertices.push(0, 0, 0);
            vertices.push(x, 0, z);
            color = (i & 1) ? color1 : color2;
            colors.push(color.r, color.g, color.b);
            colors.push(color.r, color.g, color.b);
        }
        for (i = 0; i <= circles; i++) {
            color = (i & 1) ? color1 : color2;
            r = radius - (radius / circles * i);
            for (j = 0; j < divisions; j++) {
                v = (j / divisions) * (Math.PI * 2);
                x = Math.sin(v) * r;
                z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
                v = ((j + 1) / divisions) * (Math.PI * 2);
                x = Math.sin(v) * r;
                z = Math.cos(v) * r;
                vertices.push(x, 0, z);
                colors.push(color.r, color.g, color.b);
            }
        }
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    PolarGridHelper.prototype = Object.create(LineSegments.prototype);
    PolarGridHelper.prototype.constructor = PolarGridHelper;
    function FaceNormalsHelper(object, size, hex, linewidth) {
        this.object = object;
        this.size = (size !== undefined) ? size : 1;
        var color = (hex !== undefined) ? hex : 0xffff00;
        var width = (linewidth !== undefined) ? linewidth : 1;
        var nNormals = 0;
        var objGeometry = this.object.geometry;
        if (objGeometry && objGeometry.isGeometry) {
            nNormals = objGeometry.faces.length;
        } else {
            console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
        }
        var geometry = new BufferGeometry();
        var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
        geometry.addAttribute('position', positions);
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color,
            linewidth: width
        }));
        this.matrixAutoUpdate = false;
        this.update();
    }
    FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
    FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
    FaceNormalsHelper.prototype.update = (function () {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var normalMatrix = new Matrix3();
        return function update() {
            this.object.updateMatrixWorld(true);
            normalMatrix.getNormalMatrix(this.object.matrixWorld);
            var matrixWorld = this.object.matrixWorld;
            var position = this.geometry.attributes.position;
            var objGeometry = this.object.geometry;
            var vertices = objGeometry.vertices;
            var faces = objGeometry.faces;
            var idx = 0;
            for (var i = 0, l = faces.length; i < l; i++) {
                var face = faces[i];
                var normal = face.normal;
                v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
                v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
                position.setXYZ(idx, v1.x, v1.y, v1.z);
                idx = idx + 1;
                position.setXYZ(idx, v2.x, v2.y, v2.z);
                idx = idx + 1;
            }
            position.needsUpdate = true;
        }
            ;
    }());
    function DirectionalLightHelper(light, size, color) {
        Object3D.call(this);
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        if (size === undefined)
            size = 1;
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
        var material = new LineBasicMaterial({
            fog: false
        });
        this.lightPlane = new Line(geometry, material);
        this.add(this.lightPlane);
        geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
        this.targetLine = new Line(geometry, material);
        this.add(this.targetLine);
        this.update();
    }
    DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
    DirectionalLightHelper.prototype.dispose = function () {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
    }
        ;
    DirectionalLightHelper.prototype.update = function () {
        var v1 = new Vector3();
        var v2 = new Vector3();
        var v3 = new Vector3();
        return function update() {
            v1.setFromMatrixPosition(this.light.matrixWorld);
            v2.setFromMatrixPosition(this.light.target.matrixWorld);
            v3.subVectors(v2, v1);
            this.lightPlane.lookAt(v3);
            if (this.color !== undefined) {
                this.lightPlane.material.color.set(this.color);
                this.targetLine.material.color.set(this.color);
            } else {
                this.lightPlane.material.color.copy(this.light.color);
                this.targetLine.material.color.copy(this.light.color);
            }
            this.targetLine.lookAt(v3);
            this.targetLine.scale.z = v3.length();
        }
            ;
    }();
    function CameraHelper(camera) {
        var geometry = new BufferGeometry();
        var material = new LineBasicMaterial({
            color: 0xffffff,
            vertexColors: FaceColors
        });
        var vertices = [];
        var colors = [];
        var pointMap = {};
        var colorFrustum = new Color(0xffaa00);
        var colorCone = new Color(0xff0000);
        var colorUp = new Color(0x00aaff);
        var colorTarget = new Color(0xffffff);
        var colorCross = new Color(0x333333);
        addLine('n1', 'n2', colorFrustum);
        addLine('n2', 'n4', colorFrustum);
        addLine('n4', 'n3', colorFrustum);
        addLine('n3', 'n1', colorFrustum);
        addLine('f1', 'f2', colorFrustum);
        addLine('f2', 'f4', colorFrustum);
        addLine('f4', 'f3', colorFrustum);
        addLine('f3', 'f1', colorFrustum);
        addLine('n1', 'f1', colorFrustum);
        addLine('n2', 'f2', colorFrustum);
        addLine('n3', 'f3', colorFrustum);
        addLine('n4', 'f4', colorFrustum);
        addLine('p', 'n1', colorCone);
        addLine('p', 'n2', colorCone);
        addLine('p', 'n3', colorCone);
        addLine('p', 'n4', colorCone);
        addLine('u1', 'u2', colorUp);
        addLine('u2', 'u3', colorUp);
        addLine('u3', 'u1', colorUp);
        addLine('c', 't', colorTarget);
        addLine('p', 'c', colorCross);
        addLine('cn1', 'cn2', colorCross);
        addLine('cn3', 'cn4', colorCross);
        addLine('cf1', 'cf2', colorCross);
        addLine('cf3', 'cf4', colorCross);
        function addLine(a, b, color) {
            addPoint(a, color);
            addPoint(b, color);
        }
        function addPoint(id, color) {
            vertices.push(0, 0, 0);
            colors.push(color.r, color.g, color.b);
            if (pointMap[id] === undefined) {
                pointMap[id] = [];
            }
            pointMap[id].push((vertices.length / 3) - 1);
        }
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
        LineSegments.call(this, geometry, material);
        this.camera = camera;
        if (this.camera.updateProjectionMatrix)
            this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
    }
    CameraHelper.prototype = Object.create(LineSegments.prototype);
    CameraHelper.prototype.constructor = CameraHelper;
    CameraHelper.prototype.update = function () {
        var geometry, pointMap;
        var vector = new Vector3();
        var camera = new Camera();
        function setPoint(point, x, y, z) {
            vector.set(x, y, z).unproject(camera);
            var points = pointMap[point];
            if (points !== undefined) {
                var position = geometry.getAttribute('position');
                for (var i = 0, l = points.length; i < l; i++) {
                    position.setXYZ(points[i], vector.x, vector.y, vector.z);
                }
            }
        }
        return function update() {
            geometry = this.geometry;
            pointMap = this.pointMap;
            var w = 1
                , h = 1;
            camera.projectionMatrix.copy(this.camera.projectionMatrix);
            setPoint('c', 0, 0, -1);
            setPoint('t', 0, 0, 1);
            setPoint('n1', -w, -h, -1);
            setPoint('n2', w, -h, -1);
            setPoint('n3', -w, h, -1);
            setPoint('n4', w, h, -1);
            setPoint('f1', -w, -h, 1);
            setPoint('f2', w, -h, 1);
            setPoint('f3', -w, h, 1);
            setPoint('f4', w, h, 1);
            setPoint('u1', w * 0.7, h * 1.1, -1);
            setPoint('u2', -w * 0.7, h * 1.1, -1);
            setPoint('u3', 0, h * 2, -1);
            setPoint('cf1', -w, 0, 1);
            setPoint('cf2', w, 0, 1);
            setPoint('cf3', 0, -h, 1);
            setPoint('cf4', 0, h, 1);
            setPoint('cn1', -w, 0, -1);
            setPoint('cn2', w, 0, -1);
            setPoint('cn3', 0, -h, -1);
            setPoint('cn4', 0, h, -1);
            geometry.getAttribute('position').needsUpdate = true;
        }
            ;
    }();
    function BoxHelper(object, color) {
        this.object = object;
        if (color === undefined)
            color = 0xffff00;
        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var positions = new Float32Array(8 * 3);
        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.addAttribute('position', new BufferAttribute(positions, 3));
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        }));
        this.matrixAutoUpdate = false;
        this.update();
    }
    BoxHelper.prototype = Object.create(LineSegments.prototype);
    BoxHelper.prototype.constructor = BoxHelper;
    BoxHelper.prototype.update = (function () {
        var box = new Box3();
        return function update(object) {
            if (object !== undefined) {
                console.warn('THREE.BoxHelper: .update() has no longer arguments.');
            }
            if (this.object !== undefined) {
                box.setFromObject(this.object);
            }
            if (box.isEmpty())
                return;
            var min = box.min;
            var max = box.max;
            var position = this.geometry.attributes.position;
            var array = position.array;
            array[0] = max.x;
            array[1] = max.y;
            array[2] = max.z;
            array[3] = min.x;
            array[4] = max.y;
            array[5] = max.z;
            array[6] = min.x;
            array[7] = min.y;
            array[8] = max.z;
            array[9] = max.x;
            array[10] = min.y;
            array[11] = max.z;
            array[12] = max.x;
            array[13] = max.y;
            array[14] = min.z;
            array[15] = min.x;
            array[16] = max.y;
            array[17] = min.z;
            array[18] = min.x;
            array[19] = min.y;
            array[20] = min.z;
            array[21] = max.x;
            array[22] = min.y;
            array[23] = min.z;
            position.needsUpdate = true;
            this.geometry.computeBoundingSphere();
        }
            ;
    }
    )();
    BoxHelper.prototype.setFromObject = function (object) {
        this.object = object;
        this.update();
        return this;
    }
        ;
    function Box3Helper(box, hex) {
        this.type = 'Box3Helper';
        this.box = box;
        var color = (hex !== undefined) ? hex : 0xffff00;
        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
        var geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
        LineSegments.call(this, geometry, new LineBasicMaterial({
            color: color
        }));
        this.geometry.computeBoundingSphere();
    }
    Box3Helper.prototype = Object.create(LineSegments.prototype);
    Box3Helper.prototype.constructor = Box3Helper;
    Box3Helper.prototype.updateMatrixWorld = function (force) {
        var box = this.box;
        if (box.isEmpty())
            return;
        box.getCenter(this.position);
        box.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        Object3D.prototype.updateMatrixWorld.call(this, force);
    }
        ;
    function PlaneHelper(plane, size, hex) {
        this.type = 'PlaneHelper';
        this.plane = plane;
        this.size = (size === undefined) ? 1 : size;
        var color = (hex !== undefined) ? hex : 0xffff00;
        var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
        geometry.computeBoundingSphere();
        Line.call(this, geometry, new LineBasicMaterial({
            color: color
        }));
        var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
        var geometry2 = new BufferGeometry();
        geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));
        geometry2.computeBoundingSphere();
        this.add(new Mesh(geometry2, new MeshBasicMaterial({
            color: color,
            opacity: 0.2,
            transparent: true,
            depthWrite: false
        })));
    }
    PlaneHelper.prototype = Object.create(Line.prototype);
    PlaneHelper.prototype.constructor = PlaneHelper;
    PlaneHelper.prototype.updateMatrixWorld = function (force) {
        var scale = -this.plane.constant;
        if (Math.abs(scale) < 1e-8)
            scale = 1e-8;
        this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
        this.children[0].material.side = (scale < 0) ? BackSide : FrontSide;
        this.lookAt(this.plane.normal);
        Object3D.prototype.updateMatrixWorld.call(this, force);
    }
        ;
    var lineGeometry, coneGeometry;
    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
        Object3D.call(this);
        if (color === undefined)
            color = 0xffff00;
        if (length === undefined)
            length = 1;
        if (headLength === undefined)
            headLength = 0.2 * length;
        if (headWidth === undefined)
            headWidth = 0.2 * headLength;
        if (lineGeometry === undefined) {
            lineGeometry = new BufferGeometry();
            lineGeometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
            coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
            coneGeometry.translate(0, -0.5, 0);
        }
        this.position.copy(origin);
        this.line = new Line(lineGeometry, new LineBasicMaterial({
            color: color
        }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({
            color: color
        }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
    }
    ArrowHelper.prototype = Object.create(Object3D.prototype);
    ArrowHelper.prototype.constructor = ArrowHelper;
    ArrowHelper.prototype.setDirection = (function () {
        var axis = new Vector3();
        var radians;
        return function setDirection(dir) {
            if (dir.y > 0.99999) {
                this.quaternion.set(0, 0, 0, 1);
            } else if (dir.y < -0.99999) {
                this.quaternion.set(1, 0, 0, 0);
            } else {
                axis.set(dir.z, 0, -dir.x).normalize();
                radians = Math.acos(dir.y);
                this.quaternion.setFromAxisAngle(axis, radians);
            }
        }
            ;
    }());
    ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
        if (headLength === undefined)
            headLength = 0.2 * length;
        if (headWidth === undefined)
            headWidth = 0.2 * headLength;
        this.line.scale.set(1, Math.max(0, length - headLength), 1);
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
    }
        ;
    ArrowHelper.prototype.setColor = function (color) {
        this.line.material.color.copy(color);
        this.cone.material.color.copy(color);
    }
        ;
    function AxesHelper(size) {
        size = size || 1;
        var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
        var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
        var geometry = new BufferGeometry();
        geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
        geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));
        var material = new LineBasicMaterial({
            vertexColors: VertexColors
        });
        LineSegments.call(this, geometry, material);
    }
    AxesHelper.prototype = Object.create(LineSegments.prototype);
    AxesHelper.prototype.constructor = AxesHelper;
    function Face4(a, b, c, d, normal, color, materialIndex) {
        console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
        return new Face3(a, b, c, normal, color, materialIndex);
    }
    var LineStrip = 0;
    var LinePieces = 1;
    function MeshFaceMaterial(materials) {
        console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
        return materials;
    }
    function MultiMaterial(materials) {
        if (materials === undefined)
            materials = [];
        console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
        materials.isMultiMaterial = true;
        materials.materials = materials;
        materials.clone = function () {
            return materials.slice();
        }
            ;
        return materials;
    }
    function PointCloud(geometry, material) {
        console.warn('THREE.PointCloud has been renamed to THREE.Points.');
        return new Points(geometry, material);
    }
    function Particle(material) {
        console.warn('THREE.Particle has been renamed to THREE.Sprite.');
        return new Sprite(material);
    }
    function ParticleSystem(geometry, material) {
        console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
        return new Points(geometry, material);
    }
    function PointCloudMaterial(parameters) {
        console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }
    function ParticleBasicMaterial(parameters) {
        console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }
    function ParticleSystemMaterial(parameters) {
        console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
        return new PointsMaterial(parameters);
    }
    function Vertex(x, y, z) {
        console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
        return new Vector3(x, y, z);
    }
    function DynamicBufferAttribute(array, itemSize) {
        console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
        return new BufferAttribute(array, itemSize).setDynamic(true);
    }
    function Int8Attribute(array, itemSize) {
        console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
        return new Int8BufferAttribute(array, itemSize);
    }
    function Uint8Attribute(array, itemSize) {
        console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
        return new Uint8BufferAttribute(array, itemSize);
    }
    function Uint8ClampedAttribute(array, itemSize) {
        console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
        return new Uint8ClampedBufferAttribute(array, itemSize);
    }
    function Int16Attribute(array, itemSize) {
        console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
        return new Int16BufferAttribute(array, itemSize);
    }
    function Uint16Attribute(array, itemSize) {
        console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
        return new Uint16BufferAttribute(array, itemSize);
    }
    function Int32Attribute(array, itemSize) {
        console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
        return new Int32BufferAttribute(array, itemSize);
    }
    function Uint32Attribute(array, itemSize) {
        console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
        return new Uint32BufferAttribute(array, itemSize);
    }
    function Float32Attribute(array, itemSize) {
        console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
        return new Float32BufferAttribute(array, itemSize);
    }
    function Float64Attribute(array, itemSize) {
        console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
        return new Float64BufferAttribute(array, itemSize);
    }
    Curve.create = function (construct, getPoint) {
        console.log('THREE.Curve.create() has been deprecated');
        construct.prototype = Object.create(Curve.prototype);
        construct.prototype.constructor = construct;
        construct.prototype.getPoint = getPoint;
        return construct;
    }
        ;
    Object.assign(CurvePath.prototype, {
        createPointsGeometry: function (divisions) {
            console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
            var pts = this.getPoints(divisions);
            return this.createGeometry(pts);
        },
        createSpacedPointsGeometry: function (divisions) {
            console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
            var pts = this.getSpacedPoints(divisions);
            return this.createGeometry(pts);
        },
        createGeometry: function (points) {
            console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
            var geometry = new Geometry();
            for (var i = 0, l = points.length; i < l; i++) {
                var point = points[i];
                geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
            }
            return geometry;
        }
    });
    Object.assign(Path.prototype, {
        fromPoints: function (points) {
            console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
            this.setFromPoints(points);
        }
    });
    function ClosedSplineCurve3(points) {
        console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
        this.closed = true;
    }
    ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
    function SplineCurve3(points) {
        console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
    }
    SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
    function Spline(points) {
        console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
        CatmullRomCurve3.call(this, points);
        this.type = 'catmullrom';
    }
    Spline.prototype = Object.create(CatmullRomCurve3.prototype);
    Object.assign(Spline.prototype, {
        initFromArray: function () {
            console.error('THREE.Spline: .initFromArray() has been removed.');
        },
        getControlPointsArray: function () {
            console.error('THREE.Spline: .getControlPointsArray() has been removed.');
        },
        reparametrizeByArcLength: function () {
            console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
        }
    });
    function AxisHelper(size) {
        console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
        return new AxesHelper(size);
    }
    function BoundingBoxHelper(object, color) {
        console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
        return new BoxHelper(object, color);
    }
    function EdgesHelper(object, hex) {
        console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
        return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
            color: hex !== undefined ? hex : 0xffffff
        }));
    }
    GridHelper.prototype.setColors = function () {
        console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
    }
        ;
    SkeletonHelper.prototype.update = function () {
        console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
    }
        ;
    function WireframeHelper(object, hex) {
        console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
        return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
            color: hex !== undefined ? hex : 0xffffff
        }));
    }
    Object.assign(Loader.prototype, {
        extractUrlBase: function (url) {
            console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
            return LoaderUtils.extractUrlBase(url);
        }
    });
    function XHRLoader(manager) {
        console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
        return new FileLoader(manager);
    }
    function BinaryTextureLoader(manager) {
        console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
        return new DataTextureLoader(manager);
    }
    Object.assign(Box2.prototype, {
        center: function (optionalTarget) {
            console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
            return this.getCenter(optionalTarget);
        },
        empty: function () {
            console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        },
        isIntersectionBox: function (box) {
            console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        size: function (optionalTarget) {
            console.warn('THREE.Box2: .size() has been renamed to .getSize().');
            return this.getSize(optionalTarget);
        }
    });
    Object.assign(Box3.prototype, {
        center: function (optionalTarget) {
            console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
            return this.getCenter(optionalTarget);
        },
        empty: function () {
            console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
            return this.isEmpty();
        },
        isIntersectionBox: function (box) {
            console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        isIntersectionSphere: function (sphere) {
            console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(sphere);
        },
        size: function (optionalTarget) {
            console.warn('THREE.Box3: .size() has been renamed to .getSize().');
            return this.getSize(optionalTarget);
        }
    });
    Line3.prototype.center = function (optionalTarget) {
        console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
        return this.getCenter(optionalTarget);
    }
        ;
    Object.assign(_Math, {
        random16: function () {
            console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
            return Math.random();
        },
        nearestPowerOfTwo: function (value) {
            console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
            return _Math.floorPowerOfTwo(value);
        },
        nextPowerOfTwo: function (value) {
            console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
            return _Math.ceilPowerOfTwo(value);
        }
    });
    Object.assign(Matrix3.prototype, {
        flattenToArrayOffset: function (array, offset) {
            console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
            return this.toArray(array, offset);
        },
        multiplyVector3: function (vector) {
            console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
            return vector.applyMatrix3(this);
        },
        multiplyVector3Array: function () {
            console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
        },
        applyToBuffer: function (buffer) {
            console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
            return this.applyToBufferAttribute(buffer);
        },
        applyToVector3Array: function () {
            console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
        }
    });
    Object.assign(Matrix4.prototype, {
        extractPosition: function (m) {
            console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
            return this.copyPosition(m);
        },
        flattenToArrayOffset: function (array, offset) {
            console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
            return this.toArray(array, offset);
        },
        getPosition: function () {
            var v1;
            return function getPosition() {
                if (v1 === undefined)
                    v1 = new Vector3();
                console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
                return v1.setFromMatrixColumn(this, 3);
            }
                ;
        }(),
        setRotationFromQuaternion: function (q) {
            console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
            return this.makeRotationFromQuaternion(q);
        },
        multiplyToArray: function () {
            console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
        },
        multiplyVector3: function (vector) {
            console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        multiplyVector4: function (vector) {
            console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        multiplyVector3Array: function () {
            console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
        },
        rotateAxis: function (v) {
            console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
            v.transformDirection(this);
        },
        crossVector: function (vector) {
            console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
            return vector.applyMatrix4(this);
        },
        translate: function () {
            console.error('THREE.Matrix4: .translate() has been removed.');
        },
        rotateX: function () {
            console.error('THREE.Matrix4: .rotateX() has been removed.');
        },
        rotateY: function () {
            console.error('THREE.Matrix4: .rotateY() has been removed.');
        },
        rotateZ: function () {
            console.error('THREE.Matrix4: .rotateZ() has been removed.');
        },
        rotateByAxis: function () {
            console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
        },
        applyToBuffer: function (buffer) {
            console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
            return this.applyToBufferAttribute(buffer);
        },
        applyToVector3Array: function () {
            console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
        },
        makeFrustum: function (left, right, bottom, top, near, far) {
            console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
            return this.makePerspective(left, right, top, bottom, near, far);
        }
    });
    Plane.prototype.isIntersectionLine = function (line) {
        console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
        return this.intersectsLine(line);
    }
        ;
    Quaternion.prototype.multiplyVector3 = function (vector) {
        console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
        return vector.applyQuaternion(this);
    }
        ;
    Object.assign(Ray.prototype, {
        isIntersectionBox: function (box) {
            console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
            return this.intersectsBox(box);
        },
        isIntersectionPlane: function (plane) {
            console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
            return this.intersectsPlane(plane);
        },
        isIntersectionSphere: function (sphere) {
            console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
            return this.intersectsSphere(sphere);
        }
    });
    Object.assign(Triangle.prototype, {
        area: function () {
            console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
            return this.getArea();
        },
        barycoordFromPoint: function (point, target) {
            console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
            return this.getBarycoord(point, target);
        },
        midpoint: function (target) {
            console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
            return this.getMidpoint(target);
        },
        normal: function (target) {
            console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
            return this.getNormal(target);
        },
        plane: function (target) {
            console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
            return this.getPlane(target);
        }
    });
    Object.assign(Triangle, {
        barycoordFromPoint: function (point, a, b, c, target) {
            console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
            return Triangle.getBarycoord(point, a, b, c, target);
        },
        normal: function (a, b, c, target) {
            console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
            return Triangle.getNormal(a, b, c, target);
        }
    });
    Object.assign(Shape.prototype, {
        extractAllPoints: function (divisions) {
            console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
            return this.extractPoints(divisions);
        },
        extrude: function (options) {
            console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
            return new ExtrudeGeometry(this, options);
        },
        makeGeometry: function (options) {
            console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
            return new ShapeGeometry(this, options);
        }
    });
    Object.assign(Vector2.prototype, {
        fromAttribute: function (attribute, index, offset) {
            console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        },
        distanceToManhattan: function (v) {
            console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
            return this.manhattanDistanceTo(v);
        },
        lengthManhattan: function () {
            console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
            return this.manhattanLength();
        }
    });
    Object.assign(Vector3.prototype, {
        setEulerFromRotationMatrix: function () {
            console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
        },
        setEulerFromQuaternion: function () {
            console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
        },
        getPositionFromMatrix: function (m) {
            console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
            return this.setFromMatrixPosition(m);
        },
        getScaleFromMatrix: function (m) {
            console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
            return this.setFromMatrixScale(m);
        },
        getColumnFromMatrix: function (index, matrix) {
            console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
            return this.setFromMatrixColumn(matrix, index);
        },
        applyProjection: function (m) {
            console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
            return this.applyMatrix4(m);
        },
        fromAttribute: function (attribute, index, offset) {
            console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        },
        distanceToManhattan: function (v) {
            console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
            return this.manhattanDistanceTo(v);
        },
        lengthManhattan: function () {
            console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
            return this.manhattanLength();
        }
    });
    Object.assign(Vector4.prototype, {
        fromAttribute: function (attribute, index, offset) {
            console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
            return this.fromBufferAttribute(attribute, index, offset);
        },
        lengthManhattan: function () {
            console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
            return this.manhattanLength();
        }
    });
    Object.assign(Geometry.prototype, {
        computeTangents: function () {
            console.error('THREE.Geometry: .computeTangents() has been removed.');
        },
        computeLineDistances: function () {
            console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');
        }
    });
    Object.assign(Object3D.prototype, {
        getChildByName: function (name) {
            console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
            return this.getObjectByName(name);
        },
        renderDepth: function () {
            console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
        },
        translate: function (distance, axis) {
            console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
            return this.translateOnAxis(axis, distance);
        },
        getWorldRotation: function () {
            console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
        }
    });
    Object.defineProperties(Object3D.prototype, {
        eulerOrder: {
            get: function () {
                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                return this.rotation.order;
            },
            set: function (value) {
                console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                this.rotation.order = value;
            }
        },
        useQuaternion: {
            get: function () {
                console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
            },
            set: function () {
                console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
            }
        }
    });
    Object.defineProperties(LOD.prototype, {
        objects: {
            get: function () {
                console.warn('THREE.LOD: .objects has been renamed to .levels.');
                return this.levels;
            }
        }
    });
    Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
        get: function () {
            console.warn('THREE.Skeleton: useVertexTexture has been removed.');
        },
        set: function () {
            console.warn('THREE.Skeleton: useVertexTexture has been removed.');
        }
    });
    Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
        get: function () {
            console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
            return this.arcLengthDivisions;
        },
        set: function (value) {
            console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
            this.arcLengthDivisions = value;
        }
    });
    PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");
        if (filmGauge !== undefined)
            this.filmGauge = filmGauge;
        this.setFocalLength(focalLength);
    }
        ;
    Object.defineProperties(Light.prototype, {
        onlyShadow: {
            set: function () {
                console.warn('THREE.Light: .onlyShadow has been removed.');
            }
        },
        shadowCameraFov: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
                this.shadow.camera.fov = value;
            }
        },
        shadowCameraLeft: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
                this.shadow.camera.left = value;
            }
        },
        shadowCameraRight: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
                this.shadow.camera.right = value;
            }
        },
        shadowCameraTop: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
                this.shadow.camera.top = value;
            }
        },
        shadowCameraBottom: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
                this.shadow.camera.bottom = value;
            }
        },
        shadowCameraNear: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
                this.shadow.camera.near = value;
            }
        },
        shadowCameraFar: {
            set: function (value) {
                console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
                this.shadow.camera.far = value;
            }
        },
        shadowCameraVisible: {
            set: function () {
                console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
            }
        },
        shadowBias: {
            set: function (value) {
                console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
                this.shadow.bias = value;
            }
        },
        shadowDarkness: {
            set: function () {
                console.warn('THREE.Light: .shadowDarkness has been removed.');
            }
        },
        shadowMapWidth: {
            set: function (value) {
                console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
                this.shadow.mapSize.width = value;
            }
        },
        shadowMapHeight: {
            set: function (value) {
                console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
                this.shadow.mapSize.height = value;
            }
        }
    });
    Object.defineProperties(BufferAttribute.prototype, {
        length: {
            get: function () {
                console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
                return this.array.length;
            }
        },
        copyIndicesArray: function () {
            console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
        }
    });
    Object.assign(BufferGeometry.prototype, {
        addIndex: function (index) {
            console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
            this.setIndex(index);
        },
        addDrawCall: function (start, count, indexOffset) {
            if (indexOffset !== undefined) {
                console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
            }
            console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
            this.addGroup(start, count);
        },
        clearDrawCalls: function () {
            console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
            this.clearGroups();
        },
        computeTangents: function () {
            console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
        },
        computeOffsets: function () {
            console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
        }
    });
    Object.defineProperties(BufferGeometry.prototype, {
        drawcalls: {
            get: function () {
                console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
                return this.groups;
            }
        },
        offsets: {
            get: function () {
                console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
                return this.groups;
            }
        }
    });
    Object.assign(ExtrudeBufferGeometry.prototype, {
        getArrays: function () {
            console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
        },
        addShapeList: function () {
            console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
        },
        addShape: function () {
            console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
        }
    });
    Object.defineProperties(Uniform.prototype, {
        dynamic: {
            set: function () {
                console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
            }
        },
        onUpdate: {
            value: function () {
                console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
                return this;
            }
        }
    });
    Object.defineProperties(Material.prototype, {
        wrapAround: {
            get: function () {
                console.warn('THREE.Material: .wrapAround has been removed.');
            },
            set: function () {
                console.warn('THREE.Material: .wrapAround has been removed.');
            }
        },
        wrapRGB: {
            get: function () {
                console.warn('THREE.Material: .wrapRGB has been removed.');
                return new Color();
            }
        },
        shading: {
            get: function () {
                console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
            },
            set: function (value) {
                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                this.flatShading = (value === FlatShading);
            }
        }
    });
    Object.defineProperties(MeshPhongMaterial.prototype, {
        metal: {
            get: function () {
                console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
                return false;
            },
            set: function () {
                console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
            }
        }
    });
    Object.defineProperties(ShaderMaterial.prototype, {
        derivatives: {
            get: function () {
                console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                return this.extensions.derivatives;
            },
            set: function (value) {
                console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                this.extensions.derivatives = value;
            }
        }
    });
    Object.assign(WebGLRenderer.prototype, {
        animate: function (callback) {
            console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
            this.setAnimationLoop(callback);
        },
        getCurrentRenderTarget: function () {
            console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
            return this.getRenderTarget();
        },
        getMaxAnisotropy: function () {
            console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
            return this.capabilities.getMaxAnisotropy();
        },
        getPrecision: function () {
            console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
            return this.capabilities.precision;
        },
        resetGLState: function () {
            console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
            return this.state.reset();
        },
        supportsFloatTextures: function () {
            console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
            return this.extensions.get('OES_texture_float');
        },
        supportsHalfFloatTextures: function () {
            console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
            return this.extensions.get('OES_texture_half_float');
        },
        supportsStandardDerivatives: function () {
            console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
            return this.extensions.get('OES_standard_derivatives');
        },
        supportsCompressedTextureS3TC: function () {
            console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_s3tc');
        },
        supportsCompressedTexturePVRTC: function () {
            console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
            return this.extensions.get('WEBGL_compressed_texture_pvrtc');
        },
        supportsBlendMinMax: function () {
            console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
            return this.extensions.get('EXT_blend_minmax');
        },
        supportsVertexTextures: function () {
            console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
            return this.capabilities.vertexTextures;
        },
        supportsInstancedArrays: function () {
            console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
            return this.extensions.get('ANGLE_instanced_arrays');
        },
        enableScissorTest: function (boolean) {
            console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
            this.setScissorTest(boolean);
        },
        initMaterial: function () {
            console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
        },
        addPrePlugin: function () {
            console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
        },
        addPostPlugin: function () {
            console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
        },
        updateShadowMap: function () {
            console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
        },
        setFaceCulling: function () {
            console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
        }
    });
    Object.defineProperties(WebGLRenderer.prototype, {
        shadowMapEnabled: {
            get: function () {
                return this.shadowMap.enabled;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
                this.shadowMap.enabled = value;
            }
        },
        shadowMapType: {
            get: function () {
                return this.shadowMap.type;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
                this.shadowMap.type = value;
            }
        },
        shadowMapCullFace: {
            get: function () {
                console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
                return undefined;
            },
            set: function () {
                console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
            }
        }
    });
    Object.defineProperties(WebGLShadowMap.prototype, {
        cullFace: {
            get: function () {
                console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
                return undefined;
            },
            set: function () {
                console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
            }
        },
        renderReverseSided: {
            get: function () {
                console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
                return undefined;
            },
            set: function () {
                console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
            }
        },
        renderSingleSided: {
            get: function () {
                console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
                return undefined;
            },
            set: function () {
                console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
            }
        }
    });
    Object.defineProperties(WebGLRenderTarget.prototype, {
        wrapS: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                return this.texture.wrapS;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                this.texture.wrapS = value;
            }
        },
        wrapT: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                return this.texture.wrapT;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                this.texture.wrapT = value;
            }
        },
        magFilter: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                return this.texture.magFilter;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                this.texture.magFilter = value;
            }
        },
        minFilter: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                return this.texture.minFilter;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                this.texture.minFilter = value;
            }
        },
        anisotropy: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                return this.texture.anisotropy;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                this.texture.anisotropy = value;
            }
        },
        offset: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                return this.texture.offset;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                this.texture.offset = value;
            }
        },
        repeat: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                return this.texture.repeat;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                this.texture.repeat = value;
            }
        },
        format: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                return this.texture.format;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                this.texture.format = value;
            }
        },
        type: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                return this.texture.type;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                this.texture.type = value;
            }
        },
        generateMipmaps: {
            get: function () {
                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                return this.texture.generateMipmaps;
            },
            set: function (value) {
                console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                this.texture.generateMipmaps = value;
            }
        }
    });
    Object.defineProperties(WebVRManager.prototype, {
        standing: {
            set: function () {
                console.warn('THREE.WebVRManager: .standing has been removed.');
            }
        }
    });
    Audio.prototype.load = function (file) {
        console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
        var scope = this;
        var audioLoader = new AudioLoader();
        audioLoader.load(file, function (buffer) {
            scope.setBuffer(buffer);
        });
        return this;
    }
        ;
    AudioAnalyser.prototype.getData = function () {
        console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
        return this.getFrequencyData();
    }
        ;
    CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
        console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
        return this.update(renderer, scene);
    }
        ;
    var GeometryUtils = {
        merge: function (geometry1, geometry2, materialIndexOffset) {
            console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
            var matrix;
            if (geometry2.isMesh) {
                geometry2.matrixAutoUpdate && geometry2.updateMatrix();
                matrix = geometry2.matrix;
                geometry2 = geometry2.geometry;
            }
            geometry1.merge(geometry2, matrix, materialIndexOffset);
        },
        center: function (geometry) {
            console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
            return geometry.center();
        }
    };
    var ImageUtils = {
        crossOrigin: undefined,
        loadTexture: function (url, mapping, onLoad, onError) {
            console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
            var loader = new TextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(url, onLoad, undefined, onError);
            if (mapping)
                texture.mapping = mapping;
            return texture;
        },
        loadTextureCube: function (urls, mapping, onLoad, onError) {
            console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
            var loader = new CubeTextureLoader();
            loader.setCrossOrigin(this.crossOrigin);
            var texture = loader.load(urls, onLoad, undefined, onError);
            if (mapping)
                texture.mapping = mapping;
            return texture;
        },
        loadCompressedTexture: function () {
            console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
        },
        loadCompressedTextureCube: function () {
            console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
        }
    };
    function Projector() {
        console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
        this.projectVector = function (vector, camera) {
            console.warn('THREE.Projector: .projectVector() is now vector.project().');
            vector.project(camera);
        }
            ;
        this.unprojectVector = function (vector, camera) {
            console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
            vector.unproject(camera);
        }
            ;
        this.pickingRay = function () {
            console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
        }
            ;
    }
    function CanvasRenderer() {
        console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
        this.domElement = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        this.clear = function () { }
            ;
        this.render = function () { }
            ;
        this.setClearColor = function () { }
            ;
        this.setSize = function () { }
            ;
    }
    var SceneUtils = {
        createMultiMaterialObject: function () {
            console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
        },
        detach: function () {
            console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
        },
        attach: function () {
            console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
        }
    };
    function LensFlare() {
        console.error('THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js');
    }
    exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
    exports.WebGLRenderTarget = WebGLRenderTarget;
    exports.WebGLRenderer = WebGLRenderer;
    exports.ShaderLib = ShaderLib;
    exports.UniformsLib = UniformsLib;
    exports.UniformsUtils = UniformsUtils;
    exports.ShaderChunk = ShaderChunk;
    exports.FogExp2 = FogExp2;
    exports.Fog = Fog;
    exports.Scene = Scene;
    exports.Sprite = Sprite;
    exports.LOD = LOD;
    exports.SkinnedMesh = SkinnedMesh;
    exports.Skeleton = Skeleton;
    exports.Bone = Bone;
    exports.Mesh = Mesh;
    exports.LineSegments = LineSegments;
    exports.LineLoop = LineLoop;
    exports.Line = Line;
    exports.Points = Points;
    exports.Group = Group;
    exports.VideoTexture = VideoTexture;
    exports.DataTexture = DataTexture;
    exports.CompressedTexture = CompressedTexture;
    exports.CubeTexture = CubeTexture;
    exports.CanvasTexture = CanvasTexture;
    exports.DepthTexture = DepthTexture;
    exports.Texture = Texture;
    exports.CompressedTextureLoader = CompressedTextureLoader;
    exports.DataTextureLoader = DataTextureLoader;
    exports.CubeTextureLoader = CubeTextureLoader;
    exports.TextureLoader = TextureLoader;
    exports.ObjectLoader = ObjectLoader;
    exports.MaterialLoader = MaterialLoader;
    exports.BufferGeometryLoader = BufferGeometryLoader;
    exports.DefaultLoadingManager = DefaultLoadingManager;
    exports.LoadingManager = LoadingManager;
    exports.JSONLoader = JSONLoader;
    exports.ImageLoader = ImageLoader;
    exports.ImageBitmapLoader = ImageBitmapLoader;
    exports.FontLoader = FontLoader;
    exports.FileLoader = FileLoader;
    exports.Loader = Loader;
    exports.LoaderUtils = LoaderUtils;
    exports.Cache = Cache;
    exports.AudioLoader = AudioLoader;
    exports.SpotLightShadow = SpotLightShadow;
    exports.SpotLight = SpotLight;
    exports.PointLight = PointLight;
    exports.RectAreaLight = RectAreaLight;
    exports.HemisphereLight = HemisphereLight;
    exports.DirectionalLightShadow = DirectionalLightShadow;
    exports.DirectionalLight = DirectionalLight;
    exports.AmbientLight = AmbientLight;
    exports.LightShadow = LightShadow;
    exports.Light = Light;
    exports.StereoCamera = StereoCamera;
    exports.PerspectiveCamera = PerspectiveCamera;
    exports.OrthographicCamera = OrthographicCamera;
    exports.CubeCamera = CubeCamera;
    exports.ArrayCamera = ArrayCamera;
    exports.Camera = Camera;
    exports.AudioListener = AudioListener;
    exports.PositionalAudio = PositionalAudio;
    exports.AudioContext = AudioContext;
    exports.AudioAnalyser = AudioAnalyser;
    exports.Audio = Audio;
    exports.VectorKeyframeTrack = VectorKeyframeTrack;
    exports.StringKeyframeTrack = StringKeyframeTrack;
    exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    exports.NumberKeyframeTrack = NumberKeyframeTrack;
    exports.ColorKeyframeTrack = ColorKeyframeTrack;
    exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
    exports.PropertyMixer = PropertyMixer;
    exports.PropertyBinding = PropertyBinding;
    exports.KeyframeTrack = KeyframeTrack;
    exports.AnimationUtils = AnimationUtils;
    exports.AnimationObjectGroup = AnimationObjectGroup;
    exports.AnimationMixer = AnimationMixer;
    exports.AnimationClip = AnimationClip;
    exports.Uniform = Uniform;
    exports.InstancedBufferGeometry = InstancedBufferGeometry;
    exports.BufferGeometry = BufferGeometry;
    exports.Geometry = Geometry;
    exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
    exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
    exports.InterleavedBuffer = InterleavedBuffer;
    exports.InstancedBufferAttribute = InstancedBufferAttribute;
    exports.Face3 = Face3;
    exports.Object3D = Object3D;
    exports.Raycaster = Raycaster;
    exports.Layers = Layers;
    exports.EventDispatcher = EventDispatcher;
    exports.Clock = Clock;
    exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
    exports.LinearInterpolant = LinearInterpolant;
    exports.DiscreteInterpolant = DiscreteInterpolant;
    exports.CubicInterpolant = CubicInterpolant;
    exports.Interpolant = Interpolant;
    exports.Triangle = Triangle;
    exports.Math = _Math;
    exports.Spherical = Spherical;
    exports.Cylindrical = Cylindrical;
    exports.Plane = Plane;
    exports.Frustum = Frustum;
    exports.Sphere = Sphere;
    exports.Ray = Ray;
    exports.Matrix4 = Matrix4;
    exports.Matrix3 = Matrix3;
    exports.Box3 = Box3;
    exports.Box2 = Box2;
    exports.Line3 = Line3;
    exports.Euler = Euler;
    exports.Vector4 = Vector4;
    exports.Vector3 = Vector3;
    exports.Vector2 = Vector2;
    exports.Quaternion = Quaternion;
    exports.Color = Color;
    exports.ImmediateRenderObject = ImmediateRenderObject;
    exports.VertexNormalsHelper = VertexNormalsHelper;
    exports.SpotLightHelper = SpotLightHelper;
    exports.SkeletonHelper = SkeletonHelper;
    exports.PointLightHelper = PointLightHelper;
    exports.RectAreaLightHelper = RectAreaLightHelper;
    exports.HemisphereLightHelper = HemisphereLightHelper;
    exports.GridHelper = GridHelper;
    exports.PolarGridHelper = PolarGridHelper;
    exports.FaceNormalsHelper = FaceNormalsHelper;
    exports.DirectionalLightHelper = DirectionalLightHelper;
    exports.CameraHelper = CameraHelper;
    exports.BoxHelper = BoxHelper;
    exports.Box3Helper = Box3Helper;
    exports.PlaneHelper = PlaneHelper;
    exports.ArrowHelper = ArrowHelper;
    exports.AxesHelper = AxesHelper;
    exports.Shape = Shape;
    exports.Path = Path;
    exports.ShapePath = ShapePath;
    exports.Font = Font;
    exports.CurvePath = CurvePath;
    exports.Curve = Curve;
    exports.ShapeUtils = ShapeUtils;
    exports.WebGLUtils = WebGLUtils;
    exports.WireframeGeometry = WireframeGeometry;
    exports.ParametricGeometry = ParametricGeometry;
    exports.ParametricBufferGeometry = ParametricBufferGeometry;
    exports.TetrahedronGeometry = TetrahedronGeometry;
    exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
    exports.OctahedronGeometry = OctahedronGeometry;
    exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
    exports.IcosahedronGeometry = IcosahedronGeometry;
    exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
    exports.DodecahedronGeometry = DodecahedronGeometry;
    exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
    exports.PolyhedronGeometry = PolyhedronGeometry;
    exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
    exports.TubeGeometry = TubeGeometry;
    exports.TubeBufferGeometry = TubeBufferGeometry;
    exports.TorusKnotGeometry = TorusKnotGeometry;
    exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
    exports.TorusGeometry = TorusGeometry;
    exports.TorusBufferGeometry = TorusBufferGeometry;
    exports.TextGeometry = TextGeometry;
    exports.TextBufferGeometry = TextBufferGeometry;
    exports.SphereGeometry = SphereGeometry;
    exports.SphereBufferGeometry = SphereBufferGeometry;
    exports.RingGeometry = RingGeometry;
    exports.RingBufferGeometry = RingBufferGeometry;
    exports.PlaneGeometry = PlaneGeometry;
    exports.PlaneBufferGeometry = PlaneBufferGeometry;
    exports.LatheGeometry = LatheGeometry;
    exports.LatheBufferGeometry = LatheBufferGeometry;
    exports.ShapeGeometry = ShapeGeometry;
    exports.ShapeBufferGeometry = ShapeBufferGeometry;
    exports.ExtrudeGeometry = ExtrudeGeometry;
    exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
    exports.EdgesGeometry = EdgesGeometry;
    exports.ConeGeometry = ConeGeometry;
    exports.ConeBufferGeometry = ConeBufferGeometry;
    exports.CylinderGeometry = CylinderGeometry;
    exports.CylinderBufferGeometry = CylinderBufferGeometry;
    exports.CircleGeometry = CircleGeometry;
    exports.CircleBufferGeometry = CircleBufferGeometry;
    exports.BoxGeometry = BoxGeometry;
    exports.BoxBufferGeometry = BoxBufferGeometry;
    exports.ShadowMaterial = ShadowMaterial;
    exports.SpriteMaterial = SpriteMaterial;
    exports.RawShaderMaterial = RawShaderMaterial;
    exports.ShaderMaterial = ShaderMaterial;
    exports.PointsMaterial = PointsMaterial;
    exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
    exports.MeshStandardMaterial = MeshStandardMaterial;
    exports.MeshPhongMaterial = MeshPhongMaterial;
    exports.MeshToonMaterial = MeshToonMaterial;
    exports.MeshNormalMaterial = MeshNormalMaterial;
    exports.MeshLambertMaterial = MeshLambertMaterial;
    exports.MeshDepthMaterial = MeshDepthMaterial;
    exports.MeshDistanceMaterial = MeshDistanceMaterial;
    exports.MeshBasicMaterial = MeshBasicMaterial;
    exports.LineDashedMaterial = LineDashedMaterial;
    exports.LineBasicMaterial = LineBasicMaterial;
    exports.Material = Material;
    exports.Float64BufferAttribute = Float64BufferAttribute;
    exports.Float32BufferAttribute = Float32BufferAttribute;
    exports.Uint32BufferAttribute = Uint32BufferAttribute;
    exports.Int32BufferAttribute = Int32BufferAttribute;
    exports.Uint16BufferAttribute = Uint16BufferAttribute;
    exports.Int16BufferAttribute = Int16BufferAttribute;
    exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
    exports.Uint8BufferAttribute = Uint8BufferAttribute;
    exports.Int8BufferAttribute = Int8BufferAttribute;
    exports.BufferAttribute = BufferAttribute;
    exports.ArcCurve = ArcCurve;
    exports.CatmullRomCurve3 = CatmullRomCurve3;
    exports.CubicBezierCurve = CubicBezierCurve;
    exports.CubicBezierCurve3 = CubicBezierCurve3;
    exports.EllipseCurve = EllipseCurve;
    exports.LineCurve = LineCurve;
    exports.LineCurve3 = LineCurve3;
    exports.QuadraticBezierCurve = QuadraticBezierCurve;
    exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
    exports.SplineCurve = SplineCurve;
    exports.REVISION = REVISION;
    exports.MOUSE = MOUSE;
    exports.CullFaceNone = CullFaceNone;
    exports.CullFaceBack = CullFaceBack;
    exports.CullFaceFront = CullFaceFront;
    exports.CullFaceFrontBack = CullFaceFrontBack;
    exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
    exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
    exports.BasicShadowMap = BasicShadowMap;
    exports.PCFShadowMap = PCFShadowMap;
    exports.PCFSoftShadowMap = PCFSoftShadowMap;
    exports.FrontSide = FrontSide;
    exports.BackSide = BackSide;
    exports.DoubleSide = DoubleSide;
    exports.FlatShading = FlatShading;
    exports.SmoothShading = SmoothShading;
    exports.NoColors = NoColors;
    exports.FaceColors = FaceColors;
    exports.VertexColors = VertexColors;
    exports.NoBlending = NoBlending;
    exports.NormalBlending = NormalBlending;
    exports.AdditiveBlending = AdditiveBlending;
    exports.SubtractiveBlending = SubtractiveBlending;
    exports.MultiplyBlending = MultiplyBlending;
    exports.CustomBlending = CustomBlending;
    exports.AddEquation = AddEquation;
    exports.SubtractEquation = SubtractEquation;
    exports.ReverseSubtractEquation = ReverseSubtractEquation;
    exports.MinEquation = MinEquation;
    exports.MaxEquation = MaxEquation;
    exports.ZeroFactor = ZeroFactor;
    exports.OneFactor = OneFactor;
    exports.SrcColorFactor = SrcColorFactor;
    exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
    exports.SrcAlphaFactor = SrcAlphaFactor;
    exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
    exports.DstAlphaFactor = DstAlphaFactor;
    exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
    exports.DstColorFactor = DstColorFactor;
    exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
    exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
    exports.NeverDepth = NeverDepth;
    exports.AlwaysDepth = AlwaysDepth;
    exports.LessDepth = LessDepth;
    exports.LessEqualDepth = LessEqualDepth;
    exports.EqualDepth = EqualDepth;
    exports.GreaterEqualDepth = GreaterEqualDepth;
    exports.GreaterDepth = GreaterDepth;
    exports.NotEqualDepth = NotEqualDepth;
    exports.MultiplyOperation = MultiplyOperation;
    exports.MixOperation = MixOperation;
    exports.AddOperation = AddOperation;
    exports.NoToneMapping = NoToneMapping;
    exports.LinearToneMapping = LinearToneMapping;
    exports.ReinhardToneMapping = ReinhardToneMapping;
    exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
    exports.CineonToneMapping = CineonToneMapping;
    exports.UVMapping = UVMapping;
    exports.CubeReflectionMapping = CubeReflectionMapping;
    exports.CubeRefractionMapping = CubeRefractionMapping;
    exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
    exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
    exports.SphericalReflectionMapping = SphericalReflectionMapping;
    exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
    exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
    exports.RepeatWrapping = RepeatWrapping;
    exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
    exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
    exports.NearestFilter = NearestFilter;
    exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    exports.LinearFilter = LinearFilter;
    exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    exports.UnsignedByteType = UnsignedByteType;
    exports.ByteType = ByteType;
    exports.ShortType = ShortType;
    exports.UnsignedShortType = UnsignedShortType;
    exports.IntType = IntType;
    exports.UnsignedIntType = UnsignedIntType;
    exports.FloatType = FloatType;
    exports.HalfFloatType = HalfFloatType;
    exports.UnsignedShort4444Type = UnsignedShort4444Type;
    exports.UnsignedShort5551Type = UnsignedShort5551Type;
    exports.UnsignedShort565Type = UnsignedShort565Type;
    exports.UnsignedInt248Type = UnsignedInt248Type;
    exports.AlphaFormat = AlphaFormat;
    exports.RGBFormat = RGBFormat;
    exports.RGBAFormat = RGBAFormat;
    exports.LuminanceFormat = LuminanceFormat;
    exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
    exports.RGBEFormat = RGBEFormat;
    exports.DepthFormat = DepthFormat;
    exports.DepthStencilFormat = DepthStencilFormat;
    exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
    exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
    exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
    exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
    exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
    exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
    exports.RGB_ETC1_Format = RGB_ETC1_Format;
    exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
    exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
    exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
    exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
    exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
    exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
    exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
    exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
    exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
    exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
    exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
    exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
    exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
    exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
    exports.LoopOnce = LoopOnce;
    exports.LoopRepeat = LoopRepeat;
    exports.LoopPingPong = LoopPingPong;
    exports.InterpolateDiscrete = InterpolateDiscrete;
    exports.InterpolateLinear = InterpolateLinear;
    exports.InterpolateSmooth = InterpolateSmooth;
    exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
    exports.ZeroSlopeEnding = ZeroSlopeEnding;
    exports.WrapAroundEnding = WrapAroundEnding;
    exports.TrianglesDrawMode = TrianglesDrawMode;
    exports.TriangleStripDrawMode = TriangleStripDrawMode;
    exports.TriangleFanDrawMode = TriangleFanDrawMode;
    exports.LinearEncoding = LinearEncoding;
    exports.sRGBEncoding = sRGBEncoding;
    exports.GammaEncoding = GammaEncoding;
    exports.RGBEEncoding = RGBEEncoding;
    exports.LogLuvEncoding = LogLuvEncoding;
    exports.RGBM7Encoding = RGBM7Encoding;
    exports.RGBM16Encoding = RGBM16Encoding;
    exports.RGBDEncoding = RGBDEncoding;
    exports.BasicDepthPacking = BasicDepthPacking;
    exports.RGBADepthPacking = RGBADepthPacking;
    exports.CubeGeometry = BoxGeometry;
    exports.Face4 = Face4;
    exports.LineStrip = LineStrip;
    exports.LinePieces = LinePieces;
    exports.MeshFaceMaterial = MeshFaceMaterial;
    exports.MultiMaterial = MultiMaterial;
    exports.PointCloud = PointCloud;
    exports.Particle = Particle;
    exports.ParticleSystem = ParticleSystem;
    exports.PointCloudMaterial = PointCloudMaterial;
    exports.ParticleBasicMaterial = ParticleBasicMaterial;
    exports.ParticleSystemMaterial = ParticleSystemMaterial;
    exports.Vertex = Vertex;
    exports.DynamicBufferAttribute = DynamicBufferAttribute;
    exports.Int8Attribute = Int8Attribute;
    exports.Uint8Attribute = Uint8Attribute;
    exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
    exports.Int16Attribute = Int16Attribute;
    exports.Uint16Attribute = Uint16Attribute;
    exports.Int32Attribute = Int32Attribute;
    exports.Uint32Attribute = Uint32Attribute;
    exports.Float32Attribute = Float32Attribute;
    exports.Float64Attribute = Float64Attribute;
    exports.ClosedSplineCurve3 = ClosedSplineCurve3;
    exports.SplineCurve3 = SplineCurve3;
    exports.Spline = Spline;
    exports.AxisHelper = AxisHelper;
    exports.BoundingBoxHelper = BoundingBoxHelper;
    exports.EdgesHelper = EdgesHelper;
    exports.WireframeHelper = WireframeHelper;
    exports.XHRLoader = XHRLoader;
    exports.BinaryTextureLoader = BinaryTextureLoader;
    exports.GeometryUtils = GeometryUtils;
    exports.ImageUtils = ImageUtils;
    exports.Projector = Projector;
    exports.CanvasRenderer = CanvasRenderer;
    exports.SceneUtils = SceneUtils;
    exports.LensFlare = LensFlare;
    Object.defineProperty(exports, '__esModule', {
        value: true
    });
}
)));
THREE.OBJLoader = (function () {
    var object_pattern = /^[og]\s*(.+)?/;
    var material_library_pattern = /^mtllib /;
    var material_use_pattern = /^usemtl /;
    function ParserState() {
        var state = {
            objects: [],
            object: {},
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            materialLibraries: [],
            startObject: function (name, fromDeclaration) {
                if (this.object && this.object.fromDeclaration === false) {
                    this.object.name = name;
                    this.object.fromDeclaration = (fromDeclaration !== false);
                    return;
                }
                var previousMaterial = (this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined);
                if (this.object && typeof this.object._finalize === 'function') {
                    this.object._finalize(true);
                }
                this.object = {
                    name: name || '',
                    fromDeclaration: (fromDeclaration !== false),
                    geometry: {
                        vertices: [],
                        normals: [],
                        colors: [],
                        uvs: []
                    },
                    materials: [],
                    smooth: true,
                    startMaterial: function (name, libraries) {
                        var previous = this._finalize(false);
                        if (previous && (previous.inherited || previous.groupCount <= 0)) {
                            this.materials.splice(previous.index, 1);
                        }
                        var material = {
                            index: this.materials.length,
                            name: name || '',
                            mtllib: (Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : ''),
                            smooth: (previous !== undefined ? previous.smooth : this.smooth),
                            groupStart: (previous !== undefined ? previous.groupEnd : 0),
                            groupEnd: -1,
                            groupCount: -1,
                            inherited: false,
                            clone: function (index) {
                                var cloned = {
                                    index: (typeof index === 'number' ? index : this.index),
                                    name: this.name,
                                    mtllib: this.mtllib,
                                    smooth: this.smooth,
                                    groupStart: 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: false
                                };
                                cloned.clone = this.clone.bind(cloned);
                                return cloned;
                            }
                        };
                        this.materials.push(material);
                        return material;
                    },
                    currentMaterial: function () {
                        if (this.materials.length > 0) {
                            return this.materials[this.materials.length - 1];
                        }
                        return undefined;
                    },
                    _finalize: function (end) {
                        var lastMultiMaterial = this.currentMaterial();
                        if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
                            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                            lastMultiMaterial.inherited = false;
                        }
                        if (end && this.materials.length > 1) {
                            for (var mi = this.materials.length - 1; mi >= 0; mi--) {
                                if (this.materials[mi].groupCount <= 0) {
                                    this.materials.splice(mi, 1);
                                }
                            }
                        }
                        if (end && this.materials.length === 0) {
                            this.materials.push({
                                name: '',
                                smooth: this.smooth
                            });
                        }
                        return lastMultiMaterial;
                    }
                };
                if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {
                    var declared = previousMaterial.clone(0);
                    declared.inherited = true;
                    this.object.materials.push(declared);
                }
                this.objects.push(this.object);
            },
            finalize: function () {
                if (this.object && typeof this.object._finalize === 'function') {
                    this.object._finalize(true);
                }
            },
            parseVertexIndex: function (value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;
            },
            parseNormalIndex: function (value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 3) * 3;
            },
            parseUVIndex: function (value, len) {
                var index = parseInt(value, 10);
                return (index >= 0 ? index - 1 : index + len / 2) * 2;
            },
            addVertex: function (a, b, c) {
                var src = this.vertices;
                var dst = this.object.geometry.vertices;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
                dst.push(src[b + 0], src[b + 1], src[b + 2]);
                dst.push(src[c + 0], src[c + 1], src[c + 2]);
            },
            addVertexLine: function (a) {
                var src = this.vertices;
                var dst = this.object.geometry.vertices;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
            },
            addNormal: function (a, b, c) {
                var src = this.normals;
                var dst = this.object.geometry.normals;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
                dst.push(src[b + 0], src[b + 1], src[b + 2]);
                dst.push(src[c + 0], src[c + 1], src[c + 2]);
            },
            addColor: function (a, b, c) {
                var src = this.colors;
                var dst = this.object.geometry.colors;
                dst.push(src[a + 0], src[a + 1], src[a + 2]);
                dst.push(src[b + 0], src[b + 1], src[b + 2]);
                dst.push(src[c + 0], src[c + 1], src[c + 2]);
            },
            addUV: function (a, b, c) {
                var src = this.uvs;
                var dst = this.object.geometry.uvs;
                dst.push(src[a + 0], src[a + 1]);
                dst.push(src[b + 0], src[b + 1]);
                dst.push(src[c + 0], src[c + 1]);
            },
            addUVLine: function (a) {
                var src = this.uvs;
                var dst = this.object.geometry.uvs;
                dst.push(src[a + 0], src[a + 1]);
            },
            addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {
                var vLen = this.vertices.length;
                var ia = this.parseVertexIndex(a, vLen);
                var ib = this.parseVertexIndex(b, vLen);
                var ic = this.parseVertexIndex(c, vLen);
                this.addVertex(ia, ib, ic);
                if (ua !== undefined) {
                    var uvLen = this.uvs.length;
                    ia = this.parseUVIndex(ua, uvLen);
                    ib = this.parseUVIndex(ub, uvLen);
                    ic = this.parseUVIndex(uc, uvLen);
                    this.addUV(ia, ib, ic);
                }
                if (na !== undefined) {
                    var nLen = this.normals.length;
                    ia = this.parseNormalIndex(na, nLen);
                    ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);
                    ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);
                    this.addNormal(ia, ib, ic);
                }
                if (this.colors.length > 0) {
                    this.addColor(ia, ib, ic);
                }
            },
            addLineGeometry: function (vertices, uvs) {
                this.object.geometry.type = 'Line';
                var vLen = this.vertices.length;
                var uvLen = this.uvs.length;
                for (var vi = 0, l = vertices.length; vi < l; vi++) {
                    this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
                }
                for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {
                    this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
                }
            }
        };
        state.startObject('', false);
        return state;
    }
    function OBJLoader(manager) {
        this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
        this.materials = null;
    }
    OBJLoader.prototype = {
        constructor: OBJLoader,
        load: function (url, onLoad, onProgress, onError) {
            var scope = this;
            var loader = new THREE.FileLoader(scope.manager);
            loader.setPath(this.path);
            loader.load(url, function (text) {
                onLoad(scope.parse(text));
            }, onProgress, onError);
        },
        setPath: function (value) {
            this.path = value;
        },
        setMaterials: function (materials) {
            this.materials = materials;
            return this;
        },
        parse: function (text) {
            console.time('OBJLoader');
            var state = new ParserState();
            if (text.indexOf('\r\n') !== -1) {
                text = text.replace(/\r\n/g, '\n');
            }
            if (text.indexOf('\\\n') !== -1) {
                text = text.replace(/\\\n/g, '');
            }
            var lines = text.split('\n');
            var line = ''
                , lineFirstChar = '';
            var lineLength = 0;
            var result = [];
            var trimLeft = (typeof ''.trimLeft === 'function');
            for (var i = 0, l = lines.length; i < l; i++) {
                line = lines[i];
                line = trimLeft ? line.trimLeft() : line.trim();
                lineLength = line.length;
                if (lineLength === 0)
                    continue;
                lineFirstChar = line.charAt(0);
                if (lineFirstChar === '#')
                    continue;
                if (lineFirstChar === 'v') {
                    var data = line.split(/\s+/);
                    switch (data[0]) {
                        case 'v':
                            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                            if (data.length === 8) {
                                state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
                            }
                            break;
                        case 'vn':
                            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
                            break;
                        case 'vt':
                            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
                            break;
                    }
                } else if (lineFirstChar === 'f') {
                    var lineData = line.substr(1).trim();
                    var vertexData = lineData.split(/\s+/);
                    var faceVertices = [];
                    for (var j = 0, jl = vertexData.length; j < jl; j++) {
                        var vertex = vertexData[j];
                        if (vertex.length > 0) {
                            var vertexParts = vertex.split('/');
                            faceVertices.push(vertexParts);
                        }
                    }
                    var v1 = faceVertices[0];
                    for (var j = 1, jl = faceVertices.length - 1; j < jl; j++) {
                        var v2 = faceVertices[j];
                        var v3 = faceVertices[j + 1];
                        state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
                    }
                } else if (lineFirstChar === 'l') {
                    var lineParts = line.substring(1).trim().split(" ");
                    var lineVertices = []
                        , lineUVs = [];
                    if (line.indexOf("/") === -1) {
                        lineVertices = lineParts;
                    } else {
                        for (var li = 0, llen = lineParts.length; li < llen; li++) {
                            var parts = lineParts[li].split("/");
                            if (parts[0] !== "")
                                lineVertices.push(parts[0]);
                            if (parts[1] !== "")
                                lineUVs.push(parts[1]);
                        }
                    }
                    state.addLineGeometry(lineVertices, lineUVs);
                } else if ((result = object_pattern.exec(line)) !== null) {
                    var name = (" " + result[0].substr(1).trim()).substr(1);
                    state.startObject(name);
                } else if (material_use_pattern.test(line)) {
                    state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
                } else if (material_library_pattern.test(line)) {
                    state.materialLibraries.push(line.substring(7).trim());
                } else if (lineFirstChar === 's') {
                    result = line.split(' ');
                    if (result.length > 1) {
                        var value = result[1].trim().toLowerCase();
                        state.object.smooth = (value !== '0' && value !== 'off');
                    } else {
                        state.object.smooth = true;
                    }
                    var material = state.object.currentMaterial();
                    if (material)
                        material.smooth = state.object.smooth;
                } else {
                    if (line === '\0')
                        continue;
                    throw new Error('THREE.OBJLoader: Unexpected line: "' + line + '"');
                }
            }
            state.finalize();
            var container = new THREE.Group();
            container.materialLibraries = [].concat(state.materialLibraries);
            for (var i = 0, l = state.objects.length; i < l; i++) {
                var object = state.objects[i];
                var geometry = object.geometry;
                var materials = object.materials;
                var isLine = (geometry.type === 'Line');
                if (geometry.vertices.length === 0)
                    continue;
                var buffergeometry = new THREE.BufferGeometry();
                buffergeometry.addAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));
                if (geometry.normals.length > 0) {
                    buffergeometry.addAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));
                } else {
                    buffergeometry.computeVertexNormals();
                }
                if (geometry.colors.length > 0) {
                    buffergeometry.addAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));
                }
                if (geometry.uvs.length > 0) {
                    buffergeometry.addAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));
                }
                var createdMaterials = [];
                for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
                    var sourceMaterial = materials[mi];
                    var material = undefined;
                    if (this.materials !== null) {
                        material = this.materials.create(sourceMaterial.name);
                        if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {
                            var materialLine = new THREE.LineBasicMaterial();
                            materialLine.copy(material);
                            material = materialLine;
                        }
                    }
                    if (!material) {
                        material = (!isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial());
                        material.name = sourceMaterial.name;
                    }
                    material.flatShading = sourceMaterial.smooth ? false : true;
                    createdMaterials.push(material);
                }
                var mesh;
                if (createdMaterials.length > 1) {
                    for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
                        var sourceMaterial = materials[mi];
                        buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);
                    }
                    mesh = (!isLine ? new THREE.Mesh(buffergeometry, createdMaterials) : new THREE.LineSegments(buffergeometry, createdMaterials));
                } else {
                    mesh = (!isLine ? new THREE.Mesh(buffergeometry, createdMaterials[0]) : new THREE.LineSegments(buffergeometry, createdMaterials[0]));
                }
                mesh.name = object.name;
                container.add(mesh);
            }
            console.timeEnd('OBJLoader');
            return container;
        }
    };
    return OBJLoader;
}
)();
THREE.EffectComposer = function (renderer, renderTarget) {
    this.renderer = renderer;
    if (renderTarget === undefined) {
        var parameters = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            stencilBuffer: false
        };
        var size = renderer.getDrawingBufferSize();
        renderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);
        renderTarget.texture.name = 'EffectComposer.rt1';
    }
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = 'EffectComposer.rt2';
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.passes = [];
    if (THREE.CopyShader === undefined) {
        console.error('THREE.EffectComposer relies on THREE.CopyShader');
    }
    if (THREE.ShaderPass === undefined) {
        console.error('THREE.EffectComposer relies on THREE.ShaderPass');
    }
    this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
}
    ;
Object.assign(THREE.EffectComposer.prototype, {
    swapBuffers: function () {
        var tmp = this.readBuffer;
        this.readBuffer = this.writeBuffer;
        this.writeBuffer = tmp;
    },
    addPass: function (pass) {
        this.passes.push(pass);
        var size = this.renderer.getDrawingBufferSize();
        pass.setSize(size.width, size.height);
    },
    insertPass: function (pass, index) {
        this.passes.splice(index, 0, pass);
    },
    render: function (delta) {
        var maskActive = false;
        var pass, i, il = this.passes.length;
        for (i = 0; i < il; i++) {
            pass = this.passes[i];
            if (pass.enabled === false)
                continue;
            pass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);
            if (pass.needsSwap) {
                if (maskActive) {
                    var context = this.renderer.context;
                    context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);
                    this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);
                    context.stencilFunc(context.EQUAL, 1, 0xffffffff);
                }
                this.swapBuffers();
            }
            if (THREE.MaskPass !== undefined) {
                if (pass instanceof THREE.MaskPass) {
                    maskActive = true;
                } else if (pass instanceof THREE.ClearMaskPass) {
                    maskActive = false;
                }
            }
        }
    },
    reset: function (renderTarget) {
        if (renderTarget === undefined) {
            var size = this.renderer.getDrawingBufferSize();
            renderTarget = this.renderTarget1.clone();
            renderTarget.setSize(size.width, size.height);
        }
        this.renderTarget1.dispose();
        this.renderTarget2.dispose();
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
    },
    setSize: function (width, height) {
        this.renderTarget1.setSize(width, height);
        this.renderTarget2.setSize(width, height);
        for (var i = 0; i < this.passes.length; i++) {
            this.passes[i].setSize(width, height);
        }
    }
});
THREE.Pass = function () {
    this.enabled = true;
    this.needsSwap = true;
    this.clear = false;
    this.renderToScreen = false;
}
    ;
Object.assign(THREE.Pass.prototype, {
    setSize: function (width, height) { },
    render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {
        console.error('THREE.Pass: .render() must be implemented in derived pass.');
    }
});
THREE.ShaderPass = function (shader, textureID) {
    THREE.Pass.call(this);
    this.textureID = (textureID !== undefined) ? textureID : "tDiffuse";
    if (shader instanceof THREE.ShaderMaterial) {
        this.uniforms = shader.uniforms;
        this.material = shader;
    } else if (shader) {
        this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
        this.material = new THREE.ShaderMaterial({
            defines: Object.assign({}, shader.defines),
            uniforms: this.uniforms,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
        });
    }
    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    this.scene = new THREE.Scene();
    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
    this.quad.frustumCulled = false;
    this.scene.add(this.quad);
}
    ;
THREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.ShaderPass,
    render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {
        if (this.uniforms[this.textureID]) {
            this.uniforms[this.textureID].value = readBuffer.texture;
        }
        this.quad.material = this.material;
        if (this.renderToScreen) {
            renderer.render(this.scene, this.camera);
        } else {
            renderer.render(this.scene, this.camera, writeBuffer, this.clear);
        }
    }
});
THREE.RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {
    THREE.Pass.call(this);
    this.scene = scene;
    this.camera = camera;
    this.overrideMaterial = overrideMaterial;
    this.clearColor = clearColor;
    this.clearAlpha = (clearAlpha !== undefined) ? clearAlpha : 0;
    this.clear = true;
    this.clearDepth = false;
    this.needsSwap = false;
}
    ;
THREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.RenderPass,
    render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {
        var oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        this.scene.overrideMaterial = this.overrideMaterial;
        var oldClearColor, oldClearAlpha;
        if (this.clearColor) {
            oldClearColor = renderer.getClearColor().getHex();
            oldClearAlpha = renderer.getClearAlpha();
            renderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        if (this.clearDepth) {
            renderer.clearDepth();
        }
        renderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);
        if (this.clearColor) {
            renderer.setClearColor(oldClearColor, oldClearAlpha);
        }
        this.scene.overrideMaterial = null;
        renderer.autoClear = oldAutoClear;
    }
});
THREE.CopyShader = {
    uniforms: {
        "tDiffuse": {
            type: "t",
            value: null
        },
        "opacity": {
            type: "f",
            value: 1.0
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
};
THREE.HorizontalBlurShader = {
    uniforms: {
        "tDiffuse": {
            type: "t",
            value: null
        },
        "h": {
            type: "f",
            value: 1.0 / 512.0
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float h;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")
};
THREE.VerticalBlurShader = {
    uniforms: {
        "tDiffuse": {
            type: "t",
            value: null
        },
        "v": {
            type: "f",
            value: 1.0 / 512.0
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float v;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")
};
THREE.LuminosityHighPassShader = {
    shaderID: "luminosityHighPass",
    uniforms: {
        "tDiffuse": {
            type: "t",
            value: null
        },
        "luminosityThreshold": {
            type: "f",
            value: 1.0
        },
        "smoothWidth": {
            type: "f",
            value: 1.0
        },
        "defaultColor": {
            type: "c",
            value: new THREE.Color(0x000000)
        },
        "defaultOpacity": {
            type: "f",
            value: 0.0
        }
    },
    vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
    fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float v = dot( texel.xyz, luma );", "vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "gl_FragColor = mix( outputColor, texel, alpha );", "}"].join("\n")
};
THREE.UnrealBloomPass = function (resolution, strength, radius, threshold) {
    THREE.Pass.call(this);
    this.strength = (strength !== undefined) ? strength : 1;
    this.radius = radius;
    this.threshold = threshold;
    this.resolution = (resolution !== undefined) ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);
    var pars = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat
    };
    this.renderTargetsHorizontal = [];
    this.renderTargetsVertical = [];
    this.nMips = 5;
    var resx = Math.round(this.resolution.x / 2);
    var resy = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);
    this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
    this.renderTargetBright.texture.generateMipmaps = false;
    for (var i = 0; i < this.nMips; i++) {
        var renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);
        renderTarget.texture.name = "UnrealBloomPass.h" + i;
        renderTarget.texture.generateMipmaps = false;
        this.renderTargetsHorizontal.push(renderTarget);
        var renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);
        renderTarget.texture.name = "UnrealBloomPass.v" + i;
        renderTarget.texture.generateMipmaps = false;
        this.renderTargetsVertical.push(renderTarget);
        resx = Math.round(resx / 2);
        resy = Math.round(resy / 2);
    }
    if (THREE.LuminosityHighPassShader === undefined)
        console.error("THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader");
    var highPassShader = THREE.LuminosityHighPassShader;
    this.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms);
    this.highPassUniforms["luminosityThreshold"].value = threshold;
    this.highPassUniforms["smoothWidth"].value = 0.01;
    this.materialHighPassFilter = new THREE.ShaderMaterial({
        uniforms: this.highPassUniforms,
        vertexShader: highPassShader.vertexShader,
        fragmentShader: highPassShader.fragmentShader,
        defines: {}
    });
    this.separableBlurMaterials = [];
    var kernelSizeArray = [3, 5, 7, 9, 11];
    var resx = Math.round(this.resolution.x / 2);
    var resy = Math.round(this.resolution.y / 2);
    for (var i = 0; i < this.nMips; i++) {
        this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
        this.separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
        resx = Math.round(resx / 2);
        resy = Math.round(resy / 2);
    }
    this.compositeMaterial = this.getCompositeMaterial(this.nMips);
    this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
    this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
    this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
    this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
    this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;
    this.compositeMaterial.uniforms["bloomStrength"].value = strength;
    this.compositeMaterial.uniforms["bloomRadius"].value = 0.1;
    this.compositeMaterial.needsUpdate = true;
    var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial.uniforms["bloomFactors"].value = bloomFactors;
    this.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];
    this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
    if (THREE.CopyShader === undefined) {
        console.error("THREE.BloomPass relies on THREE.CopyShader");
    }
    var copyShader = THREE.CopyShader;
    this.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);
    this.copyUniforms["opacity"].value = 1.0;
    this.materialCopy = new THREE.ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: copyShader.vertexShader,
        fragmentShader: copyShader.fragmentShader,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        depthWrite: false,
        transparent: true
    });
    this.enabled = true;
    this.needsSwap = false;
    this.oldClearColor = new THREE.Color();
    this.oldClearAlpha = 1;
    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    this.scene = new THREE.Scene();
    this.basic = new THREE.MeshBasicMaterial();
    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
    this.quad.frustumCulled = false;
    this.scene.add(this.quad);
}
    ;
THREE.UnrealBloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {
    constructor: THREE.UnrealBloomPass,
    dispose: function () {
        for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {
            this.renderTargetsHorizontal[i].dispose();
        }
        for (var i = 0; i < this.renderTargetsVertical.length; i++) {
            this.renderTargetsVertical[i].dispose();
        }
        this.renderTargetBright.dispose();
    },
    setSize: function (width, height) {
        var resx = Math.round(width / 2);
        var resy = Math.round(height / 2);
        this.renderTargetBright.setSize(resx, resy);
        for (var i = 0; i < this.nMips; i++) {
            this.renderTargetsHorizontal[i].setSize(resx, resy);
            this.renderTargetsVertical[i].setSize(resx, resy);
            this.separableBlurMaterials[i].uniforms["texSize"].value = new THREE.Vector2(resx, resy);
            resx = Math.round(resx / 2);
            resy = Math.round(resy / 2);
        }
    },
    render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {
        this.oldClearColor.copy(renderer.getClearColor());
        this.oldClearAlpha = renderer.getClearAlpha();
        var oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        renderer.setClearColor(new THREE.Color(0, 0, 0), 0);
        if (maskActive)
            renderer.context.disable(renderer.context.STENCIL_TEST);
        if (this.renderToScreen) {
            this.quad.material = this.basic;
            this.basic.map = readBuffer.texture;
            renderer.render(this.scene, this.camera, undefined, true);
        }
        this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
        this.highPassUniforms["luminosityThreshold"].value = this.threshold;
        this.quad.material = this.materialHighPassFilter;
        renderer.render(this.scene, this.camera, this.renderTargetBright, true);
        var inputRenderTarget = this.renderTargetBright;
        for (var i = 0; i < this.nMips; i++) {
            this.quad.material = this.separableBlurMaterials[i];
            this.separableBlurMaterials[i].uniforms["colorTexture"].value = inputRenderTarget.texture;
            this.separableBlurMaterials[i].uniforms["direction"].value = THREE.UnrealBloomPass.BlurDirectionX;
            renderer.render(this.scene, this.camera, this.renderTargetsHorizontal[i], true);
            this.separableBlurMaterials[i].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i].texture;
            this.separableBlurMaterials[i].uniforms["direction"].value = THREE.UnrealBloomPass.BlurDirectionY;
            renderer.render(this.scene, this.camera, this.renderTargetsVertical[i], true);
            inputRenderTarget = this.renderTargetsVertical[i];
        }
        this.quad.material = this.compositeMaterial;
        this.compositeMaterial.uniforms["bloomStrength"].value = this.strength;
        this.compositeMaterial.uniforms["bloomRadius"].value = this.radius;
        this.compositeMaterial.uniforms["bloomTintColors"].value = this.bloomTintColors;
        renderer.render(this.scene, this.camera, this.renderTargetsHorizontal[0], true);
        this.quad.material = this.materialCopy;
        this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;
        if (maskActive)
            renderer.context.enable(renderer.context.STENCIL_TEST);
        if (this.renderToScreen) {
            renderer.render(this.scene, this.camera, undefined, false);
        } else {
            renderer.render(this.scene, this.camera, readBuffer, false);
        }
        renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
        renderer.autoClear = oldAutoClear;
    },
    getSeperableBlurMaterial: function (kernelRadius) {
        return new THREE.ShaderMaterial({
            defines: {
                "KERNEL_RADIUS": kernelRadius,
                "SIGMA": kernelRadius
            },
            uniforms: {
                "colorTexture": {
                    value: null
                },
                "texSize": {
                    value: new THREE.Vector2(0.5, 0.5)
                },
                "direction": {
                    value: new THREE.Vector2(0.5, 0.5)
                }
            },
            vertexShader: "varying vec2 vUv;\n\
    void main() {\n\
     vUv = uv;\n\
     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
    }",
            fragmentShader: "#include <common>\
    varying vec2 vUv;\n\
    uniform sampler2D colorTexture;\n\
    uniform vec2 texSize;\
    uniform vec2 direction;\
    \
    float gaussianPdf(in float x, in float sigma) {\
     return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\
    }\
    void main() {\n\
     vec2 invSize = 1.0 / texSize;\
     float fSigma = float(SIGMA);\
     float weightSum = gaussianPdf(0.0, fSigma);\
     float alphaSum = 0.0;\
     vec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;\
     for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\
      float x = float(i);\
      float weight = gaussianPdf(x, fSigma);\
      vec2 uvOffset = direction * invSize * x;\
      vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\
      float weightAlpha = sample1.a * weight;\
      diffuseSum += sample1.rgb * weightAlpha;\
      alphaSum += weightAlpha;\
      weightSum += weight;\
      vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\
      weightAlpha = sample2.a * weight;\
      diffuseSum += sample2.rgb * weightAlpha;\
      alphaSum += weightAlpha;\
      weightSum += weight;\
     }\
     alphaSum /= weightSum;\
     diffuseSum /= alphaSum;\
     gl_FragColor = vec4(diffuseSum.rgb, alphaSum);\n\
    }"
        });
    },
    getCompositeMaterial: function (nMips) {
        return new THREE.ShaderMaterial({
            defines: {
                "NUM_MIPS": nMips
            },
            uniforms: {
                "blurTexture1": {
                    value: null
                },
                "blurTexture2": {
                    value: null
                },
                "blurTexture3": {
                    value: null
                },
                "blurTexture4": {
                    value: null
                },
                "blurTexture5": {
                    value: null
                },
                "dirtTexture": {
                    value: null
                },
                "bloomStrength": {
                    value: 1.0
                },
                "bloomFactors": {
                    value: null
                },
                "bloomTintColors": {
                    value: null
                },
                "bloomRadius": {
                    value: 0.0
                }
            },
            vertexShader: "varying vec2 vUv;\n\
    void main() {\n\
     vUv = uv;\n\
     gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\
    }",
            fragmentShader: "varying vec2 vUv;\
    uniform sampler2D blurTexture1;\
    uniform sampler2D blurTexture2;\
    uniform sampler2D blurTexture3;\
    uniform sampler2D blurTexture4;\
    uniform sampler2D blurTexture5;\
    uniform sampler2D dirtTexture;\
    uniform float bloomStrength;\
    uniform float bloomRadius;\
    uniform float bloomFactors[NUM_MIPS];\
    uniform vec3 bloomTintColors[NUM_MIPS];\
    \
    float lerpBloomFactor(const in float factor) { \
     float mirrorFactor = 1.2 - factor;\
     return mix(factor, mirrorFactor, bloomRadius);\
    }\
    \
    void main() {\
     gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \
              lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \
              lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \
              lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \
              lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\
    }"
        });
    }
});
THREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);
THREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);
!function (i) {
    "use strict";
    "function" == typeof define && define.amd ? define(["jquery"], i) : "undefined" != typeof exports ? module.exports = i(require("jquery")) : i(jQuery)
}(function (i) {
    "use strict";
    var e = window.Slick || {};
    (e = function () {
        var e = 0;
        return function (t, o) {
            var s, n = this;
            n.defaults = {
                accessibility: !0,
                adaptiveHeight: !1,
                appendArrows: i(t),
                appendDots: i(t),
                arrows: !0,
                asNavFor: null,
                prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                autoplay: !1,
                autoplaySpeed: 3e3,
                centerMode: !1,
                centerPadding: "50px",
                cssEase: "ease",
                customPaging: function (e, t) {
                    return i('<button type="button" />').text(t + 1)
                },
                dots: !1,
                dotsClass: "slick-dots",
                draggable: !0,
                easing: "linear",
                edgeFriction: .35,
                fade: !1,
                focusOnSelect: !1,
                focusOnChange: !1,
                infinite: !0,
                initialSlide: 0,
                lazyLoad: "ondemand",
                mobileFirst: !1,
                pauseOnHover: !0,
                pauseOnFocus: !0,
                pauseOnDotsHover: !1,
                respondTo: "window",
                responsive: null,
                rows: 1,
                rtl: !1,
                slide: "",
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: !0,
                swipeToSlide: !1,
                touchMove: !0,
                touchThreshold: 5,
                useCSS: !0,
                useTransform: !0,
                variableWidth: !1,
                vertical: !1,
                verticalSwiping: !1,
                waitForAnimate: !0,
                zIndex: 1e3
            },
                n.initials = {
                    animating: !1,
                    dragging: !1,
                    autoPlayTimer: null,
                    currentDirection: 0,
                    currentLeft: null,
                    currentSlide: 0,
                    direction: 1,
                    $dots: null,
                    listWidth: null,
                    listHeight: null,
                    loadIndex: 0,
                    $nextArrow: null,
                    $prevArrow: null,
                    scrolling: !1,
                    slideCount: null,
                    slideWidth: null,
                    $slideTrack: null,
                    $slides: null,
                    sliding: !1,
                    slideOffset: 0,
                    swipeLeft: null,
                    swiping: !1,
                    $list: null,
                    touchObject: {},
                    transformsEnabled: !1,
                    unslicked: !1
                },
                i.extend(n, n.initials),
                n.activeBreakpoint = null,
                n.animType = null,
                n.animProp = null,
                n.breakpoints = [],
                n.breakpointSettings = [],
                n.cssTransitions = !1,
                n.focussed = !1,
                n.interrupted = !1,
                n.hidden = "hidden",
                n.paused = !0,
                n.positionProp = null,
                n.respondTo = null,
                n.rowCount = 1,
                n.shouldClick = !0,
                n.$slider = i(t),
                n.$slidesCache = null,
                n.transformType = null,
                n.transitionType = null,
                n.visibilityChange = "visibilitychange",
                n.windowWidth = 0,
                n.windowTimer = null,
                s = i(t).data("slick") || {},
                n.options = i.extend({}, n.defaults, o, s),
                n.currentSlide = n.options.initialSlide,
                n.originalSettings = n.options,
                void 0 !== document.mozHidden ? (n.hidden = "mozHidden",
                    n.visibilityChange = "mozvisibilitychange") : void 0 !== document.webkitHidden && (n.hidden = "webkitHidden",
                        n.visibilityChange = "webkitvisibilitychange"),
                n.autoPlay = i.proxy(n.autoPlay, n),
                n.autoPlayClear = i.proxy(n.autoPlayClear, n),
                n.autoPlayIterator = i.proxy(n.autoPlayIterator, n),
                n.changeSlide = i.proxy(n.changeSlide, n),
                n.clickHandler = i.proxy(n.clickHandler, n),
                n.selectHandler = i.proxy(n.selectHandler, n),
                n.setPosition = i.proxy(n.setPosition, n),
                n.swipeHandler = i.proxy(n.swipeHandler, n),
                n.dragHandler = i.proxy(n.dragHandler, n),
                n.keyHandler = i.proxy(n.keyHandler, n),
                n.instanceUid = e++ ,
                n.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/,
                n.registerBreakpoints(),
                n.init(!0)
        }
    }()).prototype.activateADA = function () {
        this.$slideTrack.find(".slick-active").attr({
            "aria-hidden": "false"
        }).find("a, input, button, select").attr({
            tabindex: "0"
        })
    }
        ,
        e.prototype.addSlide = e.prototype.slickAdd = function (e, t, o) {
            var s = this;
            if ("boolean" == typeof t)
                o = t,
                    t = null;
            else if (t < 0 || t >= s.slideCount)
                return !1;
            s.unload(),
                "number" == typeof t ? 0 === t && 0 === s.$slides.length ? i(e).appendTo(s.$slideTrack) : o ? i(e).insertBefore(s.$slides.eq(t)) : i(e).insertAfter(s.$slides.eq(t)) : !0 === o ? i(e).prependTo(s.$slideTrack) : i(e).appendTo(s.$slideTrack),
                s.$slides = s.$slideTrack.children(this.options.slide),
                s.$slideTrack.children(this.options.slide).detach(),
                s.$slideTrack.append(s.$slides),
                s.$slides.each(function (e, t) {
                    i(t).attr("data-slick-index", e)
                }),
                s.$slidesCache = s.$slides,
                s.reinit()
        }
        ,
        e.prototype.animateHeight = function () {
            var i = this;
            if (1 === i.options.slidesToShow && !0 === i.options.adaptiveHeight && !1 === i.options.vertical) {
                var e = i.$slides.eq(i.currentSlide).outerHeight(!0);
                i.$list.animate({
                    height: e
                }, i.options.speed)
            }
        }
        ,
        e.prototype.animateSlide = function (e, t) {
            var o = {}
                , s = this;
            s.animateHeight(),
                !0 === s.options.rtl && !1 === s.options.vertical && (e = -e),
                !1 === s.transformsEnabled ? !1 === s.options.vertical ? s.$slideTrack.animate({
                    left: e
                }, s.options.speed, s.options.easing, t) : s.$slideTrack.animate({
                    top: e
                }, s.options.speed, s.options.easing, t) : !1 === s.cssTransitions ? (!0 === s.options.rtl && (s.currentLeft = -s.currentLeft),
                    i({
                        animStart: s.currentLeft
                    }).animate({
                        animStart: e
                    }, {
                            duration: s.options.speed,
                            easing: s.options.easing,
                            step: function (i) {
                                i = Math.ceil(i),
                                    !1 === s.options.vertical ? (o[s.animType] = "translate(" + i + "px, 0px)",
                                        s.$slideTrack.css(o)) : (o[s.animType] = "translate(0px," + i + "px)",
                                            s.$slideTrack.css(o))
                            },
                            complete: function () {
                                t && t.call()
                            }
                        })) : (s.applyTransition(),
                            e = Math.ceil(e),
                            !1 === s.options.vertical ? o[s.animType] = "translate3d(" + e + "px, 0px, 0px)" : o[s.animType] = "translate3d(0px," + e + "px, 0px)",
                            s.$slideTrack.css(o),
                            t && setTimeout(function () {
                                s.disableTransition(),
                                    t.call()
                            }, s.options.speed))
        }
        ,
        e.prototype.getNavTarget = function () {
            var e = this
                , t = e.options.asNavFor;
            return t && null !== t && (t = i(t).not(e.$slider)),
                t
        }
        ,
        e.prototype.asNavFor = function (e) {
            var t = this.getNavTarget();
            null !== t && "object" == typeof t && t.each(function () {
                var t = i(this).slick("getSlick");
                t.unslicked || t.slideHandler(e, !0)
            })
        }
        ,
        e.prototype.applyTransition = function (i) {
            var e = this
                , t = {};
            !1 === e.options.fade ? t[e.transitionType] = e.transformType + " " + e.options.speed + "ms " + e.options.cssEase : t[e.transitionType] = "opacity " + e.options.speed + "ms " + e.options.cssEase,
                !1 === e.options.fade ? e.$slideTrack.css(t) : e.$slides.eq(i).css(t)
        }
        ,
        e.prototype.autoPlay = function () {
            var i = this;
            i.autoPlayClear(),
                i.slideCount > i.options.slidesToShow && (i.autoPlayTimer = setInterval(i.autoPlayIterator, i.options.autoplaySpeed))
        }
        ,
        e.prototype.autoPlayClear = function () {
            var i = this;
            i.autoPlayTimer && clearInterval(i.autoPlayTimer)
        }
        ,
        e.prototype.autoPlayIterator = function () {
            var i = this
                , e = i.currentSlide + i.options.slidesToScroll;
            i.paused || i.interrupted || i.focussed || (!1 === i.options.infinite && (1 === i.direction && i.currentSlide + 1 === i.slideCount - 1 ? i.direction = 0 : 0 === i.direction && (e = i.currentSlide - i.options.slidesToScroll,
                i.currentSlide - 1 == 0 && (i.direction = 1))),
                i.slideHandler(e))
        }
        ,
        e.prototype.buildArrows = function () {
            var e = this;
            !0 === e.options.arrows && (e.$prevArrow = i(e.options.prevArrow).addClass("slick-arrow"),
                e.$nextArrow = i(e.options.nextArrow).addClass("slick-arrow"),
                e.slideCount > e.options.slidesToShow ? (e.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"),
                    e.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"),
                    e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.prependTo(e.options.appendArrows),
                    e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.appendTo(e.options.appendArrows),
                    !0 !== e.options.infinite && e.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : e.$prevArrow.add(e.$nextArrow).addClass("slick-hidden").attr({
                        "aria-disabled": "true",
                        tabindex: "-1"
                    }))
        }
        ,
        e.prototype.buildDots = function () {
            var e, t, o = this;
            if (!0 === o.options.dots) {
                for (o.$slider.addClass("slick-dotted"),
                    t = i("<ul />").addClass(o.options.dotsClass),
                    e = 0; e <= o.getDotCount(); e += 1)
                    t.append(i("<li />").append(o.options.customPaging.call(this, o, e)));
                o.$dots = t.appendTo(o.options.appendDots),
                    o.$dots.find("li").first().addClass("slick-active")
            }
        }
        ,
        e.prototype.buildOut = function () {
            var e = this;
            e.$slides = e.$slider.children(e.options.slide + ":not(.slick-cloned)").addClass("slick-slide"),
                e.slideCount = e.$slides.length,
                e.$slides.each(function (e, t) {
                    i(t).attr("data-slick-index", e).data("originalStyling", i(t).attr("style") || "")
                }),
                e.$slider.addClass("slick-slider"),
                e.$slideTrack = 0 === e.slideCount ? i('<div class="slick-track"/>').appendTo(e.$slider) : e.$slides.wrapAll('<div class="slick-track"/>').parent(),
                e.$list = e.$slideTrack.wrap('<div class="slick-list"/>').parent(),
                e.$slideTrack.css("opacity", 0),
                !0 !== e.options.centerMode && !0 !== e.options.swipeToSlide || (e.options.slidesToScroll = 1),
                i("img[data-lazy]", e.$slider).not("[src]").addClass("slick-loading"),
                e.setupInfinite(),
                e.buildArrows(),
                e.buildDots(),
                e.updateDots(),
                e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0),
                !0 === e.options.draggable && e.$list.addClass("draggable")
        }
        ,
        e.prototype.buildRows = function () {
            var i, e, t, o, s, n, r, l = this;
            if (o = document.createDocumentFragment(),
                n = l.$slider.children(),
                l.options.rows > 1) {
                for (r = l.options.slidesPerRow * l.options.rows,
                    s = Math.ceil(n.length / r),
                    i = 0; i < s; i++) {
                    var d = document.createElement("div");
                    for (e = 0; e < l.options.rows; e++) {
                        var a = document.createElement("div");
                        for (t = 0; t < l.options.slidesPerRow; t++) {
                            var c = i * r + (e * l.options.slidesPerRow + t);
                            n.get(c) && a.appendChild(n.get(c))
                        }
                        d.appendChild(a)
                    }
                    o.appendChild(d)
                }
                l.$slider.empty().append(o),
                    l.$slider.children().children().children().css({
                        width: 100 / l.options.slidesPerRow + "%",
                        display: "inline-block"
                    })
            }
        }
        ,
        e.prototype.checkResponsive = function (e, t) {
            var o, s, n, r = this, l = !1, d = r.$slider.width(), a = window.innerWidth || i(window).width();
            if ("window" === r.respondTo ? n = a : "slider" === r.respondTo ? n = d : "min" === r.respondTo && (n = Math.min(a, d)),
                r.options.responsive && r.options.responsive.length && null !== r.options.responsive) {
                s = null;
                for (o in r.breakpoints)
                    r.breakpoints.hasOwnProperty(o) && (!1 === r.originalSettings.mobileFirst ? n < r.breakpoints[o] && (s = r.breakpoints[o]) : n > r.breakpoints[o] && (s = r.breakpoints[o]));
                null !== s ? null !== r.activeBreakpoint ? (s !== r.activeBreakpoint || t) && (r.activeBreakpoint = s,
                    "unslick" === r.breakpointSettings[s] ? r.unslick(s) : (r.options = i.extend({}, r.originalSettings, r.breakpointSettings[s]),
                        !0 === e && (r.currentSlide = r.options.initialSlide),
                        r.refresh(e)),
                    l = s) : (r.activeBreakpoint = s,
                        "unslick" === r.breakpointSettings[s] ? r.unslick(s) : (r.options = i.extend({}, r.originalSettings, r.breakpointSettings[s]),
                            !0 === e && (r.currentSlide = r.options.initialSlide),
                            r.refresh(e)),
                        l = s) : null !== r.activeBreakpoint && (r.activeBreakpoint = null,
                            r.options = r.originalSettings,
                            !0 === e && (r.currentSlide = r.options.initialSlide),
                            r.refresh(e),
                            l = s),
                    e || !1 === l || r.$slider.trigger("breakpoint", [r, l])
            }
        }
        ,
        e.prototype.changeSlide = function (e, t) {
            var o, s, n, r = this, l = i(e.currentTarget);
            switch (l.is("a") && e.preventDefault(),
            l.is("li") || (l = l.closest("li")),
            n = r.slideCount % r.options.slidesToScroll != 0,
            o = n ? 0 : (r.slideCount - r.currentSlide) % r.options.slidesToScroll,
            e.data.message) {
                case "previous":
                    s = 0 === o ? r.options.slidesToScroll : r.options.slidesToShow - o,
                        r.slideCount > r.options.slidesToShow && r.slideHandler(r.currentSlide - s, !1, t);
                    break;
                case "next":
                    s = 0 === o ? r.options.slidesToScroll : o,
                        r.slideCount > r.options.slidesToShow && r.slideHandler(r.currentSlide + s, !1, t);
                    break;
                case "index":
                    var d = 0 === e.data.index ? 0 : e.data.index || l.index() * r.options.slidesToScroll;
                    r.slideHandler(r.checkNavigable(d), !1, t),
                        l.children().trigger("focus");
                    break;
                default:
                    return
            }
        }
        ,
        e.prototype.checkNavigable = function (i) {
            var e, t;
            if (e = this.getNavigableIndexes(),
                t = 0,
                i > e[e.length - 1])
                i = e[e.length - 1];
            else
                for (var o in e) {
                    if (i < e[o]) {
                        i = t;
                        break
                    }
                    t = e[o]
                }
            return i
        }
        ,
        e.prototype.cleanUpEvents = function () {
            var e = this;
            e.options.dots && null !== e.$dots && (i("li", e.$dots).off("click.slick", e.changeSlide).off("mouseenter.slick", i.proxy(e.interrupt, e, !0)).off("mouseleave.slick", i.proxy(e.interrupt, e, !1)),
                !0 === e.options.accessibility && e.$dots.off("keydown.slick", e.keyHandler)),
                e.$slider.off("focus.slick blur.slick"),
                !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.$prevArrow && e.$prevArrow.off("click.slick", e.changeSlide),
                    e.$nextArrow && e.$nextArrow.off("click.slick", e.changeSlide),
                    !0 === e.options.accessibility && (e.$prevArrow && e.$prevArrow.off("keydown.slick", e.keyHandler),
                        e.$nextArrow && e.$nextArrow.off("keydown.slick", e.keyHandler))),
                e.$list.off("touchstart.slick mousedown.slick", e.swipeHandler),
                e.$list.off("touchmove.slick mousemove.slick", e.swipeHandler),
                e.$list.off("touchend.slick mouseup.slick", e.swipeHandler),
                e.$list.off("touchcancel.slick mouseleave.slick", e.swipeHandler),
                e.$list.off("click.slick", e.clickHandler),
                i(document).off(e.visibilityChange, e.visibility),
                e.cleanUpSlideEvents(),
                !0 === e.options.accessibility && e.$list.off("keydown.slick", e.keyHandler),
                !0 === e.options.focusOnSelect && i(e.$slideTrack).children().off("click.slick", e.selectHandler),
                i(window).off("orientationchange.slick.slick-" + e.instanceUid, e.orientationChange),
                i(window).off("resize.slick.slick-" + e.instanceUid, e.resize),
                i("[draggable!=true]", e.$slideTrack).off("dragstart", e.preventDefault),
                i(window).off("load.slick.slick-" + e.instanceUid, e.setPosition)
        }
        ,
        e.prototype.cleanUpSlideEvents = function () {
            var e = this;
            e.$list.off("mouseenter.slick", i.proxy(e.interrupt, e, !0)),
                e.$list.off("mouseleave.slick", i.proxy(e.interrupt, e, !1))
        }
        ,
        e.prototype.cleanUpRows = function () {
            var i, e = this;
            e.options.rows > 1 && ((i = e.$slides.children().children()).removeAttr("style"),
                e.$slider.empty().append(i))
        }
        ,
        e.prototype.clickHandler = function (i) {
            !1 === this.shouldClick && (i.stopImmediatePropagation(),
                i.stopPropagation(),
                i.preventDefault())
        }
        ,
        e.prototype.destroy = function (e) {
            var t = this;
            t.autoPlayClear(),
                t.touchObject = {},
                t.cleanUpEvents(),
                i(".slick-cloned", t.$slider).detach(),
                t.$dots && t.$dots.remove(),
                t.$prevArrow && t.$prevArrow.length && (t.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""),
                    t.htmlExpr.test(t.options.prevArrow) && t.$prevArrow.remove()),
                t.$nextArrow && t.$nextArrow.length && (t.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""),
                    t.htmlExpr.test(t.options.nextArrow) && t.$nextArrow.remove()),
                t.$slides && (t.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function () {
                    i(this).attr("style", i(this).data("originalStyling"))
                }),
                    t.$slideTrack.children(this.options.slide).detach(),
                    t.$slideTrack.detach(),
                    t.$list.detach(),
                    t.$slider.append(t.$slides)),
                t.cleanUpRows(),
                t.$slider.removeClass("slick-slider"),
                t.$slider.removeClass("slick-initialized"),
                t.$slider.removeClass("slick-dotted"),
                t.unslicked = !0,
                e || t.$slider.trigger("destroy", [t])
        }
        ,
        e.prototype.disableTransition = function (i) {
            var e = this
                , t = {};
            t[e.transitionType] = "",
                !1 === e.options.fade ? e.$slideTrack.css(t) : e.$slides.eq(i).css(t)
        }
        ,
        e.prototype.fadeSlide = function (i, e) {
            var t = this;
            !1 === t.cssTransitions ? (t.$slides.eq(i).css({
                zIndex: t.options.zIndex
            }),
                t.$slides.eq(i).animate({
                    opacity: 1
                }, t.options.speed, t.options.easing, e)) : (t.applyTransition(i),
                    t.$slides.eq(i).css({
                        opacity: 1,
                        zIndex: t.options.zIndex
                    }),
                    e && setTimeout(function () {
                        t.disableTransition(i),
                            e.call()
                    }, t.options.speed))
        }
        ,
        e.prototype.fadeSlideOut = function (i) {
            var e = this;
            !1 === e.cssTransitions ? e.$slides.eq(i).animate({
                opacity: 0,
                zIndex: e.options.zIndex - 2
            }, e.options.speed, e.options.easing) : (e.applyTransition(i),
                e.$slides.eq(i).css({
                    opacity: 0,
                    zIndex: e.options.zIndex - 2
                }))
        }
        ,
        e.prototype.filterSlides = e.prototype.slickFilter = function (i) {
            var e = this;
            null !== i && (e.$slidesCache = e.$slides,
                e.unload(),
                e.$slideTrack.children(this.options.slide).detach(),
                e.$slidesCache.filter(i).appendTo(e.$slideTrack),
                e.reinit())
        }
        ,
        e.prototype.focusHandler = function () {
            var e = this;
            e.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*", function (t) {
                t.stopImmediatePropagation();
                var o = i(this);
                setTimeout(function () {
                    e.options.pauseOnFocus && (e.focussed = o.is(":focus"),
                        e.autoPlay())
                }, 0)
            })
        }
        ,
        e.prototype.getCurrent = e.prototype.slickCurrentSlide = function () {
            return this.currentSlide
        }
        ,
        e.prototype.getDotCount = function () {
            var i = this
                , e = 0
                , t = 0
                , o = 0;
            if (!0 === i.options.infinite)
                if (i.slideCount <= i.options.slidesToShow)
                    ++o;
                else
                    for (; e < i.slideCount;)
                        ++o,
                            e = t + i.options.slidesToScroll,
                            t += i.options.slidesToScroll <= i.options.slidesToShow ? i.options.slidesToScroll : i.options.slidesToShow;
            else if (!0 === i.options.centerMode)
                o = i.slideCount;
            else if (i.options.asNavFor)
                for (; e < i.slideCount;)
                    ++o,
                        e = t + i.options.slidesToScroll,
                        t += i.options.slidesToScroll <= i.options.slidesToShow ? i.options.slidesToScroll : i.options.slidesToShow;
            else
                o = 1 + Math.ceil((i.slideCount - i.options.slidesToShow) / i.options.slidesToScroll);
            return o - 1
        }
        ,
        e.prototype.getLeft = function (i) {
            var e, t, o, s, n = this, r = 0;
            return n.slideOffset = 0,
                t = n.$slides.first().outerHeight(!0),
                !0 === n.options.infinite ? (n.slideCount > n.options.slidesToShow && (n.slideOffset = n.slideWidth * n.options.slidesToShow * -1,
                    s = -1,
                    !0 === n.options.vertical && !0 === n.options.centerMode && (2 === n.options.slidesToShow ? s = -1.5 : 1 === n.options.slidesToShow && (s = -2)),
                    r = t * n.options.slidesToShow * s),
                    n.slideCount % n.options.slidesToScroll != 0 && i + n.options.slidesToScroll > n.slideCount && n.slideCount > n.options.slidesToShow && (i > n.slideCount ? (n.slideOffset = (n.options.slidesToShow - (i - n.slideCount)) * n.slideWidth * -1,
                        r = (n.options.slidesToShow - (i - n.slideCount)) * t * -1) : (n.slideOffset = n.slideCount % n.options.slidesToScroll * n.slideWidth * -1,
                            r = n.slideCount % n.options.slidesToScroll * t * -1))) : i + n.options.slidesToShow > n.slideCount && (n.slideOffset = (i + n.options.slidesToShow - n.slideCount) * n.slideWidth,
                                r = (i + n.options.slidesToShow - n.slideCount) * t),
                n.slideCount <= n.options.slidesToShow && (n.slideOffset = 0,
                    r = 0),
                !0 === n.options.centerMode && n.slideCount <= n.options.slidesToShow ? n.slideOffset = n.slideWidth * Math.floor(n.options.slidesToShow) / 2 - n.slideWidth * n.slideCount / 2 : !0 === n.options.centerMode && !0 === n.options.infinite ? n.slideOffset += n.slideWidth * Math.floor(n.options.slidesToShow / 2) - n.slideWidth : !0 === n.options.centerMode && (n.slideOffset = 0,
                    n.slideOffset += n.slideWidth * Math.floor(n.options.slidesToShow / 2)),
                e = !1 === n.options.vertical ? i * n.slideWidth * -1 + n.slideOffset : i * t * -1 + r,
                !0 === n.options.variableWidth && (o = n.slideCount <= n.options.slidesToShow || !1 === n.options.infinite ? n.$slideTrack.children(".slick-slide").eq(i) : n.$slideTrack.children(".slick-slide").eq(i + n.options.slidesToShow),
                    e = !0 === n.options.rtl ? o[0] ? -1 * (n.$slideTrack.width() - o[0].offsetLeft - o.width()) : 0 : o[0] ? -1 * o[0].offsetLeft : 0,
                    !0 === n.options.centerMode && (o = n.slideCount <= n.options.slidesToShow || !1 === n.options.infinite ? n.$slideTrack.children(".slick-slide").eq(i) : n.$slideTrack.children(".slick-slide").eq(i + n.options.slidesToShow + 1),
                        e = !0 === n.options.rtl ? o[0] ? -1 * (n.$slideTrack.width() - o[0].offsetLeft - o.width()) : 0 : o[0] ? -1 * o[0].offsetLeft : 0,
                        e += (n.$list.width() - o.outerWidth()) / 2)),
                e
        }
        ,
        e.prototype.getOption = e.prototype.slickGetOption = function (i) {
            return this.options[i]
        }
        ,
        e.prototype.getNavigableIndexes = function () {
            var i, e = this, t = 0, o = 0, s = [];
            for (!1 === e.options.infinite ? i = e.slideCount : (t = -1 * e.options.slidesToScroll,
                o = -1 * e.options.slidesToScroll,
                i = 2 * e.slideCount); t < i;)
                s.push(t),
                    t = o + e.options.slidesToScroll,
                    o += e.options.slidesToScroll <= e.options.slidesToShow ? e.options.slidesToScroll : e.options.slidesToShow;
            return s
        }
        ,
        e.prototype.getSlick = function () {
            return this
        }
        ,
        e.prototype.getSlideCount = function () {
            var e, t, o = this;
            return t = !0 === o.options.centerMode ? o.slideWidth * Math.floor(o.options.slidesToShow / 2) : 0,
                !0 === o.options.swipeToSlide ? (o.$slideTrack.find(".slick-slide").each(function (s, n) {
                    if (n.offsetLeft - t + i(n).outerWidth() / 2 > -1 * o.swipeLeft)
                        return e = n,
                            !1
                }),
                    Math.abs(i(e).attr("data-slick-index") - o.currentSlide) || 1) : o.options.slidesToScroll
        }
        ,
        e.prototype.goTo = e.prototype.slickGoTo = function (i, e) {
            this.changeSlide({
                data: {
                    message: "index",
                    index: parseInt(i)
                }
            }, e)
        }
        ,
        e.prototype.init = function (e) {
            var t = this;
            i(t.$slider).hasClass("slick-initialized") || (i(t.$slider).addClass("slick-initialized"),
                t.buildRows(),
                t.buildOut(),
                t.setProps(),
                t.startLoad(),
                t.loadSlider(),
                t.initializeEvents(),
                t.updateArrows(),
                t.updateDots(),
                t.checkResponsive(!0),
                t.focusHandler()),
                e && t.$slider.trigger("init", [t]),
                !0 === t.options.accessibility && t.initADA(),
                t.options.autoplay && (t.paused = !1,
                    t.autoPlay())
        }
        ,
        e.prototype.initADA = function () {
            var e = this
                , t = Math.ceil(e.slideCount / e.options.slidesToShow)
                , o = e.getNavigableIndexes().filter(function (i) {
                    return i >= 0 && i < e.slideCount
                });
            e.$slides.add(e.$slideTrack.find(".slick-cloned")).attr({
                "aria-hidden": "true",
                tabindex: "-1"
            }).find("a, input, button, select").attr({
                tabindex: "-1"
            }),
                null !== e.$dots && (e.$slides.not(e.$slideTrack.find(".slick-cloned")).each(function (t) {
                    var s = o.indexOf(t);
                    i(this).attr({
                        role: "tabpanel",
                        id: "slick-slide" + e.instanceUid + t,
                        tabindex: -1
                    }),
                        -1 !== s && i(this).attr({
                            "aria-describedby": "slick-slide-control" + e.instanceUid + s
                        })
                }),
                    e.$dots.attr("role", "tablist").find("li").each(function (s) {
                        var n = o[s];
                        i(this).attr({
                            role: "presentation"
                        }),
                            i(this).find("button").first().attr({
                                role: "tab",
                                id: "slick-slide-control" + e.instanceUid + s,
                                "aria-controls": "slick-slide" + e.instanceUid + n,
                                "aria-label": s + 1 + " of " + t,
                                "aria-selected": null,
                                tabindex: "-1"
                            })
                    }).eq(e.currentSlide).find("button").attr({
                        "aria-selected": "true",
                        tabindex: "0"
                    }).end());
            for (var s = e.currentSlide, n = s + e.options.slidesToShow; s < n; s++)
                e.$slides.eq(s).attr("tabindex", 0);
            e.activateADA()
        }
        ,
        e.prototype.initArrowEvents = function () {
            var i = this;
            !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.off("click.slick").on("click.slick", {
                message: "previous"
            }, i.changeSlide),
                i.$nextArrow.off("click.slick").on("click.slick", {
                    message: "next"
                }, i.changeSlide),
                !0 === i.options.accessibility && (i.$prevArrow.on("keydown.slick", i.keyHandler),
                    i.$nextArrow.on("keydown.slick", i.keyHandler)))
        }
        ,
        e.prototype.initDotEvents = function () {
            var e = this;
            !0 === e.options.dots && (i("li", e.$dots).on("click.slick", {
                message: "index"
            }, e.changeSlide),
                !0 === e.options.accessibility && e.$dots.on("keydown.slick", e.keyHandler)),
                !0 === e.options.dots && !0 === e.options.pauseOnDotsHover && i("li", e.$dots).on("mouseenter.slick", i.proxy(e.interrupt, e, !0)).on("mouseleave.slick", i.proxy(e.interrupt, e, !1))
        }
        ,
        e.prototype.initSlideEvents = function () {
            var e = this;
            e.options.pauseOnHover && (e.$list.on("mouseenter.slick", i.proxy(e.interrupt, e, !0)),
                e.$list.on("mouseleave.slick", i.proxy(e.interrupt, e, !1)))
        }
        ,
        e.prototype.initializeEvents = function () {
            var e = this;
            e.initArrowEvents(),
                e.initDotEvents(),
                e.initSlideEvents(),
                e.$list.on("touchstart.slick mousedown.slick", {
                    action: "start"
                }, e.swipeHandler),
                e.$list.on("touchmove.slick mousemove.slick", {
                    action: "move"
                }, e.swipeHandler),
                e.$list.on("touchend.slick mouseup.slick", {
                    action: "end"
                }, e.swipeHandler),
                e.$list.on("touchcancel.slick mouseleave.slick", {
                    action: "end"
                }, e.swipeHandler),
                e.$list.on("click.slick", e.clickHandler),
                i(document).on(e.visibilityChange, i.proxy(e.visibility, e)),
                !0 === e.options.accessibility && e.$list.on("keydown.slick", e.keyHandler),
                !0 === e.options.focusOnSelect && i(e.$slideTrack).children().on("click.slick", e.selectHandler),
                i(window).on("orientationchange.slick.slick-" + e.instanceUid, i.proxy(e.orientationChange, e)),
                i(window).on("resize.slick.slick-" + e.instanceUid, i.proxy(e.resize, e)),
                i("[draggable!=true]", e.$slideTrack).on("dragstart", e.preventDefault),
                i(window).on("load.slick.slick-" + e.instanceUid, e.setPosition),
                i(e.setPosition)
        }
        ,
        e.prototype.initUI = function () {
            var i = this;
            !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.show(),
                i.$nextArrow.show()),
                !0 === i.options.dots && i.slideCount > i.options.slidesToShow && i.$dots.show()
        }
        ,
        e.prototype.keyHandler = function (i) {
            var e = this;
            i.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === i.keyCode && !0 === e.options.accessibility ? e.changeSlide({
                data: {
                    message: !0 === e.options.rtl ? "next" : "previous"
                }
            }) : 39 === i.keyCode && !0 === e.options.accessibility && e.changeSlide({
                data: {
                    message: !0 === e.options.rtl ? "previous" : "next"
                }
            }))
        }
        ,
        e.prototype.lazyLoad = function () {
            function e(e) {
                i("img[data-lazy]", e).each(function () {
                    var e = i(this)
                        , t = i(this).attr("data-lazy")
                        , o = i(this).attr("data-srcset")
                        , s = i(this).attr("data-sizes") || n.$slider.attr("data-sizes")
                        , r = document.createElement("img");
                    r.onload = function () {
                        e.animate({
                            opacity: 0
                        }, 100, function () {
                            o && (e.attr("srcset", o),
                                s && e.attr("sizes", s)),
                                e.attr("src", t).animate({
                                    opacity: 1
                                }, 200, function () {
                                    e.removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading")
                                }),
                                n.$slider.trigger("lazyLoaded", [n, e, t])
                        })
                    }
                        ,
                        r.onerror = function () {
                            e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"),
                                n.$slider.trigger("lazyLoadError", [n, e, t])
                        }
                        ,
                        r.src = t
                })
            }
            var t, o, s, n = this;
            if (!0 === n.options.centerMode ? !0 === n.options.infinite ? s = (o = n.currentSlide + (n.options.slidesToShow / 2 + 1)) + n.options.slidesToShow + 2 : (o = Math.max(0, n.currentSlide - (n.options.slidesToShow / 2 + 1)),
                s = n.options.slidesToShow / 2 + 1 + 2 + n.currentSlide) : (o = n.options.infinite ? n.options.slidesToShow + n.currentSlide : n.currentSlide,
                    s = Math.ceil(o + n.options.slidesToShow),
                    !0 === n.options.fade && (o > 0 && o-- ,
                        s <= n.slideCount && s++)),
                t = n.$slider.find(".slick-slide").slice(o, s),
                "anticipated" === n.options.lazyLoad)
                for (var r = o - 1, l = s, d = n.$slider.find(".slick-slide"), a = 0; a < n.options.slidesToScroll; a++)
                    r < 0 && (r = n.slideCount - 1),
                        t = (t = t.add(d.eq(r))).add(d.eq(l)),
                        r-- ,
                        l++;
            e(t),
                n.slideCount <= n.options.slidesToShow ? e(n.$slider.find(".slick-slide")) : n.currentSlide >= n.slideCount - n.options.slidesToShow ? e(n.$slider.find(".slick-cloned").slice(0, n.options.slidesToShow)) : 0 === n.currentSlide && e(n.$slider.find(".slick-cloned").slice(-1 * n.options.slidesToShow))
        }
        ,
        e.prototype.loadSlider = function () {
            var i = this;
            i.setPosition(),
                i.$slideTrack.css({
                    opacity: 1
                }),
                i.$slider.removeClass("slick-loading"),
                i.initUI(),
                "progressive" === i.options.lazyLoad && i.progressiveLazyLoad()
        }
        ,
        e.prototype.next = e.prototype.slickNext = function () {
            this.changeSlide({
                data: {
                    message: "next"
                }
            })
        }
        ,
        e.prototype.orientationChange = function () {
            var i = this;
            i.checkResponsive(),
                i.setPosition()
        }
        ,
        e.prototype.pause = e.prototype.slickPause = function () {
            var i = this;
            i.autoPlayClear(),
                i.paused = !0
        }
        ,
        e.prototype.play = e.prototype.slickPlay = function () {
            var i = this;
            i.autoPlay(),
                i.options.autoplay = !0,
                i.paused = !1,
                i.focussed = !1,
                i.interrupted = !1
        }
        ,
        e.prototype.postSlide = function (e) {
            var t = this;
            t.unslicked || (t.$slider.trigger("afterChange", [t, e]),
                t.animating = !1,
                t.slideCount > t.options.slidesToShow && t.setPosition(),
                t.swipeLeft = null,
                t.options.autoplay && t.autoPlay(),
                !0 === t.options.accessibility && (t.initADA(),
                    t.options.focusOnChange && i(t.$slides.get(t.currentSlide)).attr("tabindex", 0).focus()))
        }
        ,
        e.prototype.prev = e.prototype.slickPrev = function () {
            this.changeSlide({
                data: {
                    message: "previous"
                }
            })
        }
        ,
        e.prototype.preventDefault = function (i) {
            i.preventDefault()
        }
        ,
        e.prototype.progressiveLazyLoad = function (e) {
            e = e || 1;
            var t, o, s, n, r, l = this, d = i("img[data-lazy]", l.$slider);
            d.length ? (t = d.first(),
                o = t.attr("data-lazy"),
                s = t.attr("data-srcset"),
                n = t.attr("data-sizes") || l.$slider.attr("data-sizes"),
                (r = document.createElement("img")).onload = function () {
                    s && (t.attr("srcset", s),
                        n && t.attr("sizes", n)),
                        t.attr("src", o).removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading"),
                        !0 === l.options.adaptiveHeight && l.setPosition(),
                        l.$slider.trigger("lazyLoaded", [l, t, o]),
                        l.progressiveLazyLoad()
                }
                ,
                r.onerror = function () {
                    e < 3 ? setTimeout(function () {
                        l.progressiveLazyLoad(e + 1)
                    }, 500) : (t.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"),
                        l.$slider.trigger("lazyLoadError", [l, t, o]),
                        l.progressiveLazyLoad())
                }
                ,
                r.src = o) : l.$slider.trigger("allImagesLoaded", [l])
        }
        ,
        e.prototype.refresh = function (e) {
            var t, o, s = this;
            o = s.slideCount - s.options.slidesToShow,
                !s.options.infinite && s.currentSlide > o && (s.currentSlide = o),
                s.slideCount <= s.options.slidesToShow && (s.currentSlide = 0),
                t = s.currentSlide,
                s.destroy(!0),
                i.extend(s, s.initials, {
                    currentSlide: t
                }),
                s.init(),
                e || s.changeSlide({
                    data: {
                        message: "index",
                        index: t
                    }
                }, !1)
        }
        ,
        e.prototype.registerBreakpoints = function () {
            var e, t, o, s = this, n = s.options.responsive || null;
            if ("array" === i.type(n) && n.length) {
                s.respondTo = s.options.respondTo || "window";
                for (e in n)
                    if (o = s.breakpoints.length - 1,
                        n.hasOwnProperty(e)) {
                        for (t = n[e].breakpoint; o >= 0;)
                            s.breakpoints[o] && s.breakpoints[o] === t && s.breakpoints.splice(o, 1),
                                o--;
                        s.breakpoints.push(t),
                            s.breakpointSettings[t] = n[e].settings
                    }
                s.breakpoints.sort(function (i, e) {
                    return s.options.mobileFirst ? i - e : e - i
                })
            }
        }
        ,
        e.prototype.reinit = function () {
            var e = this;
            e.$slides = e.$slideTrack.children(e.options.slide).addClass("slick-slide"),
                e.slideCount = e.$slides.length,
                e.currentSlide >= e.slideCount && 0 !== e.currentSlide && (e.currentSlide = e.currentSlide - e.options.slidesToScroll),
                e.slideCount <= e.options.slidesToShow && (e.currentSlide = 0),
                e.registerBreakpoints(),
                e.setProps(),
                e.setupInfinite(),
                e.buildArrows(),
                e.updateArrows(),
                e.initArrowEvents(),
                e.buildDots(),
                e.updateDots(),
                e.initDotEvents(),
                e.cleanUpSlideEvents(),
                e.initSlideEvents(),
                e.checkResponsive(!1, !0),
                !0 === e.options.focusOnSelect && i(e.$slideTrack).children().on("click.slick", e.selectHandler),
                e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0),
                e.setPosition(),
                e.focusHandler(),
                e.paused = !e.options.autoplay,
                e.autoPlay(),
                e.$slider.trigger("reInit", [e])
        }
        ,
        e.prototype.resize = function () {
            var e = this;
            i(window).width() !== e.windowWidth && (clearTimeout(e.windowDelay),
                e.windowDelay = window.setTimeout(function () {
                    e.windowWidth = i(window).width(),
                        e.checkResponsive(),
                        e.unslicked || e.setPosition()
                }, 50))
        }
        ,
        e.prototype.removeSlide = e.prototype.slickRemove = function (i, e, t) {
            var o = this;
            if (i = "boolean" == typeof i ? !0 === (e = i) ? 0 : o.slideCount - 1 : !0 === e ? --i : i,
                o.slideCount < 1 || i < 0 || i > o.slideCount - 1)
                return !1;
            o.unload(),
                !0 === t ? o.$slideTrack.children().remove() : o.$slideTrack.children(this.options.slide).eq(i).remove(),
                o.$slides = o.$slideTrack.children(this.options.slide),
                o.$slideTrack.children(this.options.slide).detach(),
                o.$slideTrack.append(o.$slides),
                o.$slidesCache = o.$slides,
                o.reinit()
        }
        ,
        e.prototype.setCSS = function (i) {
            var e, t, o = this, s = {};
            !0 === o.options.rtl && (i = -i),
                e = "left" == o.positionProp ? Math.ceil(i) + "px" : "0px",
                t = "top" == o.positionProp ? Math.ceil(i) + "px" : "0px",
                s[o.positionProp] = i,
                !1 === o.transformsEnabled ? o.$slideTrack.css(s) : (s = {},
                    !1 === o.cssTransitions ? (s[o.animType] = "translate(" + e + ", " + t + ")",
                        o.$slideTrack.css(s)) : (s[o.animType] = "translate3d(" + e + ", " + t + ", 0px)",
                            o.$slideTrack.css(s)))
        }
        ,
        e.prototype.setDimensions = function () {
            var i = this;
            !1 === i.options.vertical ? !0 === i.options.centerMode && i.$list.css({
                padding: "0px " + i.options.centerPadding
            }) : (i.$list.height(i.$slides.first().outerHeight(!0) * i.options.slidesToShow),
                !0 === i.options.centerMode && i.$list.css({
                    padding: i.options.centerPadding + " 0px"
                })),
                i.listWidth = i.$list.width(),
                i.listHeight = i.$list.height(),
                !1 === i.options.vertical && !1 === i.options.variableWidth ? (i.slideWidth = Math.ceil(i.listWidth / i.options.slidesToShow),
                    i.$slideTrack.width(Math.ceil(i.slideWidth * i.$slideTrack.children(".slick-slide").length))) : !0 === i.options.variableWidth ? i.$slideTrack.width(5e3 * i.slideCount) : (i.slideWidth = Math.ceil(i.listWidth),
                        i.$slideTrack.height(Math.ceil(i.$slides.first().outerHeight(!0) * i.$slideTrack.children(".slick-slide").length)));
            var e = i.$slides.first().outerWidth(!0) - i.$slides.first().width();
            !1 === i.options.variableWidth && i.$slideTrack.children(".slick-slide").width(i.slideWidth - e)
        }
        ,
        e.prototype.setFade = function () {
            var e, t = this;
            t.$slides.each(function (o, s) {
                e = t.slideWidth * o * -1,
                    !0 === t.options.rtl ? i(s).css({
                        position: "relative",
                        right: e,
                        top: 0,
                        zIndex: t.options.zIndex - 2,
                        opacity: 0
                    }) : i(s).css({
                        position: "relative",
                        left: e,
                        top: 0,
                        zIndex: t.options.zIndex - 2,
                        opacity: 0
                    })
            }),
                t.$slides.eq(t.currentSlide).css({
                    zIndex: t.options.zIndex - 1,
                    opacity: 1
                })
        }
        ,
        e.prototype.setHeight = function () {
            var i = this;
            if (1 === i.options.slidesToShow && !0 === i.options.adaptiveHeight && !1 === i.options.vertical) {
                var e = i.$slides.eq(i.currentSlide).outerHeight(!0);
                i.$list.css("height", e)
            }
        }
        ,
        e.prototype.setOption = e.prototype.slickSetOption = function () {
            var e, t, o, s, n, r = this, l = !1;
            if ("object" === i.type(arguments[0]) ? (o = arguments[0],
                l = arguments[1],
                n = "multiple") : "string" === i.type(arguments[0]) && (o = arguments[0],
                    s = arguments[1],
                    l = arguments[2],
                    "responsive" === arguments[0] && "array" === i.type(arguments[1]) ? n = "responsive" : void 0 !== arguments[1] && (n = "single")),
                "single" === n)
                r.options[o] = s;
            else if ("multiple" === n)
                i.each(o, function (i, e) {
                    r.options[i] = e
                });
            else if ("responsive" === n)
                for (t in s)
                    if ("array" !== i.type(r.options.responsive))
                        r.options.responsive = [s[t]];
                    else {
                        for (e = r.options.responsive.length - 1; e >= 0;)
                            r.options.responsive[e].breakpoint === s[t].breakpoint && r.options.responsive.splice(e, 1),
                                e--;
                        r.options.responsive.push(s[t])
                    }
            l && (r.unload(),
                r.reinit())
        }
        ,
        e.prototype.setPosition = function () {
            var i = this;
            i.setDimensions(),
                i.setHeight(),
                !1 === i.options.fade ? i.setCSS(i.getLeft(i.currentSlide)) : i.setFade(),
                i.$slider.trigger("setPosition", [i])
        }
        ,
        e.prototype.setProps = function () {
            var i = this
                , e = document.body.style;
            i.positionProp = !0 === i.options.vertical ? "top" : "left",
                "top" === i.positionProp ? i.$slider.addClass("slick-vertical") : i.$slider.removeClass("slick-vertical"),
                void 0 === e.WebkitTransition && void 0 === e.MozTransition && void 0 === e.msTransition || !0 === i.options.useCSS && (i.cssTransitions = !0),
                i.options.fade && ("number" == typeof i.options.zIndex ? i.options.zIndex < 3 && (i.options.zIndex = 3) : i.options.zIndex = i.defaults.zIndex),
                void 0 !== e.OTransform && (i.animType = "OTransform",
                    i.transformType = "-o-transform",
                    i.transitionType = "OTransition",
                    void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (i.animType = !1)),
                void 0 !== e.MozTransform && (i.animType = "MozTransform",
                    i.transformType = "-moz-transform",
                    i.transitionType = "MozTransition",
                    void 0 === e.perspectiveProperty && void 0 === e.MozPerspective && (i.animType = !1)),
                void 0 !== e.webkitTransform && (i.animType = "webkitTransform",
                    i.transformType = "-webkit-transform",
                    i.transitionType = "webkitTransition",
                    void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (i.animType = !1)),
                void 0 !== e.msTransform && (i.animType = "msTransform",
                    i.transformType = "-ms-transform",
                    i.transitionType = "msTransition",
                    void 0 === e.msTransform && (i.animType = !1)),
                void 0 !== e.transform && !1 !== i.animType && (i.animType = "transform",
                    i.transformType = "transform",
                    i.transitionType = "transition"),
                i.transformsEnabled = i.options.useTransform && null !== i.animType && !1 !== i.animType
        }
        ,
        e.prototype.setSlideClasses = function (i) {
            var e, t, o, s, n = this;
            if (t = n.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"),
                n.$slides.eq(i).addClass("slick-current"),
                !0 === n.options.centerMode) {
                var r = n.options.slidesToShow % 2 == 0 ? 1 : 0;
                e = Math.floor(n.options.slidesToShow / 2),
                    !0 === n.options.infinite && (i >= e && i <= n.slideCount - 1 - e ? n.$slides.slice(i - e + r, i + e + 1).addClass("slick-active").attr("aria-hidden", "false") : (o = n.options.slidesToShow + i,
                        t.slice(o - e + 1 + r, o + e + 2).addClass("slick-active").attr("aria-hidden", "false")),
                        0 === i ? t.eq(t.length - 1 - n.options.slidesToShow).addClass("slick-center") : i === n.slideCount - 1 && t.eq(n.options.slidesToShow).addClass("slick-center")),
                    n.$slides.eq(i).addClass("slick-center")
            } else
                i >= 0 && i <= n.slideCount - n.options.slidesToShow ? n.$slides.slice(i, i + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : t.length <= n.options.slidesToShow ? t.addClass("slick-active").attr("aria-hidden", "false") : (s = n.slideCount % n.options.slidesToShow,
                    o = !0 === n.options.infinite ? n.options.slidesToShow + i : i,
                    n.options.slidesToShow == n.options.slidesToScroll && n.slideCount - i < n.options.slidesToShow ? t.slice(o - (n.options.slidesToShow - s), o + s).addClass("slick-active").attr("aria-hidden", "false") : t.slice(o, o + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false"));
            "ondemand" !== n.options.lazyLoad && "anticipated" !== n.options.lazyLoad || n.lazyLoad()
        }
        ,
        e.prototype.setupInfinite = function () {
            var e, t, o, s = this;
            if (!0 === s.options.fade && (s.options.centerMode = !1),
                !0 === s.options.infinite && !1 === s.options.fade && (t = null,
                    s.slideCount > s.options.slidesToShow)) {
                for (o = !0 === s.options.centerMode ? s.options.slidesToShow + 1 : s.options.slidesToShow,
                    e = s.slideCount; e > s.slideCount - o; e -= 1)
                    t = e - 1,
                        i(s.$slides[t]).clone(!0).attr("id", "").attr("data-slick-index", t - s.slideCount).prependTo(s.$slideTrack).addClass("slick-cloned");
                for (e = 0; e < o + s.slideCount; e += 1)
                    t = e,
                        i(s.$slides[t]).clone(!0).attr("id", "").attr("data-slick-index", t + s.slideCount).appendTo(s.$slideTrack).addClass("slick-cloned");
                s.$slideTrack.find(".slick-cloned").find("[id]").each(function () {
                    i(this).attr("id", "")
                })
            }
        }
        ,
        e.prototype.interrupt = function (i) {
            var e = this;
            i || e.autoPlay(),
                e.interrupted = i
        }
        ,
        e.prototype.selectHandler = function (e) {
            var t = this
                , o = i(e.target).is(".slick-slide") ? i(e.target) : i(e.target).parents(".slick-slide")
                , s = parseInt(o.attr("data-slick-index"));
            s || (s = 0),
                t.slideCount <= t.options.slidesToShow ? t.slideHandler(s, !1, !0) : t.slideHandler(s)
        }
        ,
        e.prototype.slideHandler = function (i, e, t) {
            var o, s, n, r, l, d = null, a = this;
            if (e = e || !1,
                !(!0 === a.animating && !0 === a.options.waitForAnimate || !0 === a.options.fade && a.currentSlide === i))
                if (!1 === e && a.asNavFor(i),
                    o = i,
                    d = a.getLeft(o),
                    r = a.getLeft(a.currentSlide),
                    a.currentLeft = null === a.swipeLeft ? r : a.swipeLeft,
                    !1 === a.options.infinite && !1 === a.options.centerMode && (i < 0 || i > a.getDotCount() * a.options.slidesToScroll))
                    !1 === a.options.fade && (o = a.currentSlide,
                        !0 !== t ? a.animateSlide(r, function () {
                            a.postSlide(o)
                        }) : a.postSlide(o));
                else if (!1 === a.options.infinite && !0 === a.options.centerMode && (i < 0 || i > a.slideCount - a.options.slidesToScroll))
                    !1 === a.options.fade && (o = a.currentSlide,
                        !0 !== t ? a.animateSlide(r, function () {
                            a.postSlide(o)
                        }) : a.postSlide(o));
                else {
                    if (a.options.autoplay && clearInterval(a.autoPlayTimer),
                        s = o < 0 ? a.slideCount % a.options.slidesToScroll != 0 ? a.slideCount - a.slideCount % a.options.slidesToScroll : a.slideCount + o : o >= a.slideCount ? a.slideCount % a.options.slidesToScroll != 0 ? 0 : o - a.slideCount : o,
                        a.animating = !0,
                        a.$slider.trigger("beforeChange", [a, a.currentSlide, s]),
                        n = a.currentSlide,
                        a.currentSlide = s,
                        a.setSlideClasses(a.currentSlide),
                        a.options.asNavFor && (l = (l = a.getNavTarget()).slick("getSlick")).slideCount <= l.options.slidesToShow && l.setSlideClasses(a.currentSlide),
                        a.updateDots(),
                        a.updateArrows(),
                        !0 === a.options.fade)
                        return !0 !== t ? (a.fadeSlideOut(n),
                            a.fadeSlide(s, function () {
                                a.postSlide(s)
                            })) : a.postSlide(s),
                            void a.animateHeight();
                    !0 !== t ? a.animateSlide(d, function () {
                        a.postSlide(s)
                    }) : a.postSlide(s)
                }
        }
        ,
        e.prototype.startLoad = function () {
            var i = this;
            !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.hide(),
                i.$nextArrow.hide()),
                !0 === i.options.dots && i.slideCount > i.options.slidesToShow && i.$dots.hide(),
                i.$slider.addClass("slick-loading")
        }
        ,
        e.prototype.swipeDirection = function () {
            var i, e, t, o, s = this;
            return i = s.touchObject.startX - s.touchObject.curX,
                e = s.touchObject.startY - s.touchObject.curY,
                t = Math.atan2(e, i),
                (o = Math.round(180 * t / Math.PI)) < 0 && (o = 360 - Math.abs(o)),
                o <= 45 && o >= 0 ? !1 === s.options.rtl ? "left" : "right" : o <= 360 && o >= 315 ? !1 === s.options.rtl ? "left" : "right" : o >= 135 && o <= 225 ? !1 === s.options.rtl ? "right" : "left" : !0 === s.options.verticalSwiping ? o >= 35 && o <= 135 ? "down" : "up" : "vertical"
        }
        ,
        e.prototype.swipeEnd = function (i) {
            var e, t, o = this;
            if (o.dragging = !1,
                o.swiping = !1,
                o.scrolling)
                return o.scrolling = !1,
                    !1;
            if (o.interrupted = !1,
                o.shouldClick = !(o.touchObject.swipeLength > 10),
                void 0 === o.touchObject.curX)
                return !1;
            if (!0 === o.touchObject.edgeHit && o.$slider.trigger("edge", [o, o.swipeDirection()]),
                o.touchObject.swipeLength >= o.touchObject.minSwipe) {
                switch (t = o.swipeDirection()) {
                    case "left":
                    case "down":
                        e = o.options.swipeToSlide ? o.checkNavigable(o.currentSlide + o.getSlideCount()) : o.currentSlide + o.getSlideCount(),
                            o.currentDirection = 0;
                        break;
                    case "right":
                    case "up":
                        e = o.options.swipeToSlide ? o.checkNavigable(o.currentSlide - o.getSlideCount()) : o.currentSlide - o.getSlideCount(),
                            o.currentDirection = 1
                }
                "vertical" != t && (o.slideHandler(e),
                    o.touchObject = {},
                    o.$slider.trigger("swipe", [o, t]))
            } else
                o.touchObject.startX !== o.touchObject.curX && (o.slideHandler(o.currentSlide),
                    o.touchObject = {})
        }
        ,
        e.prototype.swipeHandler = function (i) {
            var e = this;
            if (!(!1 === e.options.swipe || "ontouchend" in document && !1 === e.options.swipe || !1 === e.options.draggable && -1 !== i.type.indexOf("mouse")))
                switch (e.touchObject.fingerCount = i.originalEvent && void 0 !== i.originalEvent.touches ? i.originalEvent.touches.length : 1,
                e.touchObject.minSwipe = e.listWidth / e.options.touchThreshold,
                !0 === e.options.verticalSwiping && (e.touchObject.minSwipe = e.listHeight / e.options.touchThreshold),
                i.data.action) {
                    case "start":
                        e.swipeStart(i);
                        break;
                    case "move":
                        e.swipeMove(i);
                        break;
                    case "end":
                        e.swipeEnd(i)
                }
        }
        ,
        e.prototype.swipeMove = function (i) {
            var e, t, o, s, n, r, l = this;
            return n = void 0 !== i.originalEvent ? i.originalEvent.touches : null,
                !(!l.dragging || l.scrolling || n && 1 !== n.length) && (e = l.getLeft(l.currentSlide),
                    l.touchObject.curX = void 0 !== n ? n[0].pageX : i.clientX,
                    l.touchObject.curY = void 0 !== n ? n[0].pageY : i.clientY,
                    l.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(l.touchObject.curX - l.touchObject.startX, 2))),
                    r = Math.round(Math.sqrt(Math.pow(l.touchObject.curY - l.touchObject.startY, 2))),
                    !l.options.verticalSwiping && !l.swiping && r > 4 ? (l.scrolling = !0,
                        !1) : (!0 === l.options.verticalSwiping && (l.touchObject.swipeLength = r),
                            t = l.swipeDirection(),
                            void 0 !== i.originalEvent && l.touchObject.swipeLength > 4 && (l.swiping = !0,
                                i.preventDefault()),
                            s = (!1 === l.options.rtl ? 1 : -1) * (l.touchObject.curX > l.touchObject.startX ? 1 : -1),
                            !0 === l.options.verticalSwiping && (s = l.touchObject.curY > l.touchObject.startY ? 1 : -1),
                            o = l.touchObject.swipeLength,
                            l.touchObject.edgeHit = !1,
                            !1 === l.options.infinite && (0 === l.currentSlide && "right" === t || l.currentSlide >= l.getDotCount() && "left" === t) && (o = l.touchObject.swipeLength * l.options.edgeFriction,
                                l.touchObject.edgeHit = !0),
                            !1 === l.options.vertical ? l.swipeLeft = e + o * s : l.swipeLeft = e + o * (l.$list.height() / l.listWidth) * s,
                            !0 === l.options.verticalSwiping && (l.swipeLeft = e + o * s),
                            !0 !== l.options.fade && !1 !== l.options.touchMove && (!0 === l.animating ? (l.swipeLeft = null,
                                !1) : void l.setCSS(l.swipeLeft))))
        }
        ,
        e.prototype.swipeStart = function (i) {
            var e, t = this;
            if (t.interrupted = !0,
                1 !== t.touchObject.fingerCount || t.slideCount <= t.options.slidesToShow)
                return t.touchObject = {},
                    !1;
            void 0 !== i.originalEvent && void 0 !== i.originalEvent.touches && (e = i.originalEvent.touches[0]),
                t.touchObject.startX = t.touchObject.curX = void 0 !== e ? e.pageX : i.clientX,
                t.touchObject.startY = t.touchObject.curY = void 0 !== e ? e.pageY : i.clientY,
                t.dragging = !0
        }
        ,
        e.prototype.unfilterSlides = e.prototype.slickUnfilter = function () {
            var i = this;
            null !== i.$slidesCache && (i.unload(),
                i.$slideTrack.children(this.options.slide).detach(),
                i.$slidesCache.appendTo(i.$slideTrack),
                i.reinit())
        }
        ,
        e.prototype.unload = function () {
            var e = this;
            i(".slick-cloned", e.$slider).remove(),
                e.$dots && e.$dots.remove(),
                e.$prevArrow && e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.remove(),
                e.$nextArrow && e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.remove(),
                e.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "")
        }
        ,
        e.prototype.unslick = function (i) {
            var e = this;
            e.$slider.trigger("unslick", [e, i]),
                e.destroy()
        }
        ,
        e.prototype.updateArrows = function () {
            var i = this;
            Math.floor(i.options.slidesToShow / 2),
                !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && !i.options.infinite && (i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"),
                    i.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"),
                    0 === i.currentSlide ? (i.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"),
                        i.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : i.currentSlide >= i.slideCount - i.options.slidesToShow && !1 === i.options.centerMode ? (i.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"),
                            i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : i.currentSlide >= i.slideCount - 1 && !0 === i.options.centerMode && (i.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"),
                                i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")))
        }
        ,
        e.prototype.updateDots = function () {
            var i = this;
            null !== i.$dots && (i.$dots.find("li").removeClass("slick-active").end(),
                i.$dots.find("li").eq(Math.floor(i.currentSlide / i.options.slidesToScroll)).addClass("slick-active"))
        }
        ,
        e.prototype.visibility = function () {
            var i = this;
            i.options.autoplay && (document[i.hidden] ? i.interrupted = !0 : i.interrupted = !1)
        }
        ,
        i.fn.slick = function () {
            var i, t, o = this, s = arguments[0], n = Array.prototype.slice.call(arguments, 1), r = o.length;
            for (i = 0; i < r; i++)
                if ("object" == typeof s || void 0 === s ? o[i].slick = new e(o[i], s) : t = o[i].slick[s].apply(o[i].slick, n),
                    void 0 !== t)
                    return t;
            return o
        }
});
(function ($) {
    $.fn.textsize = function (options) {
        var settings = $.extend({
            maximum: 1920,
            minimum: 0,
            maxFont: 9999,
            minFont: 30,
            fontRatio: 35
        }, options)
            , changes = function (el) {
                var $el = $(el)
                    , elw = $el.width()
                    , width = elw > settings.maximum ? settings.maximum : elw < settings.minimum ? settings.minimum : elw
                    , fontBase = width / settings.fontRatio
                    , fontSize = fontBase > settings.maxFont ? settings.maxFont : fontBase < settings.minFont ? settings.minFont : fontBase;
                $el.css('font-size', fontSize + 'px');
            };
        return this.each(function () {
            var that = this;
            $(window).resize(function () {
                changes(that);
            });
            changes(this);
        });
    }
        ;
}(jQuery));
function viewport() {
    var e = window
        , a = 'inner';
    if (!('innerWidth' in window)) {
        a = 'client';
        e = document.documentElement || document.body;
    }
    return {
        width: e[a + 'Width']
    };
}
; var eyeVisible = false
    , ambientSound = null;
var noformat = {
    windowW: null,
    windowH: $(window).height(),
    scroll: null,
    handheldScrollInterval: null,
    resizeTimeout: null,
    initOnce: function () {
        if ($('body').hasClass('single-projects')) {
            $('.single-intro').preloadingSite({
                truePercentage: false,
                beforeComplete: function () { },
                onComplete: function () {
                    $('.intro-video-spinner span i').addClass('activated');
                }
            });
        } else {
            $('body').preloadingSite({
                truePercentage: false,
                forceSequentialLoad: false,
                beforeComplete: function () {
                    eyeVisible = true;
                },
                onComplete: function () { }
            });
        }
        $('.first-time-overlay').remove();
        this.pageInit($('#main'));
        $('header nav').find('.history-btn').removeClass('active');
        var currUrl = window.location;
        $('header nav .main li a[href="' + currUrl + '"]').addClass('active');
        $('.single-intro .discover-btn').css('opacity', '1');
    },
    init: function () {
        if (noformat.home.introSlideshowInterval != null) {
            clearInterval(noformat.home.introSlideshowInterval);
            noformat.home.introSlideshowInterval = null;
        }
        this.resize();
        if (!$('html').hasClass('desktop')) {
            $(document).unbind('touchmove');
            $('body').unbind('touchmove touchstart touchend');
        }
        if ($('.history-swap-box-in').length) {
            this.pageInit($('.history-swap-box-in'));
        }
        if (!$('html').hasClass('desktop')) {
            if (($('html').hasClass('mobile') && $('body').hasClass('home')) || ($('html').hasClass('tablet') && ($('body').hasClass('home') || $('body').hasClass('page-template-page-about')))) {
                document.getElementsByTagName('html')[0].style.setProperty('overflow-y', 'hidden', 'important');
            } else {
                document.getElementsByTagName('html')[0].style.setProperty('overflow-y', 'visible', 'important');
            }
        }
    },
    pageInit: function (element) {
        var currClasses = element.attr('class').split(' ');
        for (var i = 0; i < currClasses.length; i++) {
            switch (currClasses[i]) {
                case 'home':
                    $('.history-swap-box-in').length ? this.home.init($('.history-swap-box-in')) : this.home.init($('#main'));
                    break;
                case 'about':
                    $('.history-swap-box-in').length ? this.about.init($('.history-swap-box-in')) : this.about.init($('#main'));
                    break;
                case 'single':
                    $('.history-swap-box-in').length ? this.single.init($('.history-swap-box-in')) : this.single.init($('#main'));
                    break;
                case 'contact':
                    $('.history-swap-box-in').length ? this.contact.init($('.history-swap-box-in')) : this.contact.init($('#main'));
                    break;
                case 'work':
                    $('.history-swap-box-in').length ? this.work.init($('.history-swap-box-in')) : this.work.init($('#main'));
                    break;
                default:
                    break;
            }
            ;
        }
        ;
    },
    transformSetter: function (x, y) {
        return {
            '-webkit-transform': 'translateX(' + x + ') translateY(' + y + ') translateZ(0px)',
            '-moz-transform': 'translateX(' + x + ') translateY(' + y + ') translateZ(0px)',
            'transform': 'translateX(' + x + ') translateY(' + y + ') translateZ(0px)'
        }
    },
    home: {
        introSlideshowInterval: null,
        parallaxCalculations: function () {
            console.log('');
            $('.parallax .layer').each(function () {
                var curr = $(this);
                curr.css({
                    'left': '',
                    'top': '',
                    'width': '',
                    'height': ''
                });
                var currW = $('html').hasClass('portrait') ? curr.data('portrait-width') : curr.data('width')
                    , currH = $('html').hasClass('portrait') ? curr.data('portrait-height') : curr.data('height')
                    , currL = $('html').hasClass('portrait') ? curr.data('portrait-left') : curr.data('left')
                    , currT = $('html').hasClass('portrait') ? curr.data('portrait-top') : curr.data('top')
                    , newH = currH * noformat.windowH / 1080
                    , newW = newH * currW / currH
                    , newT = currT * noformat.windowH / 1080
                    , newL = newT * currL / currT;
                curr.css({
                    'left': newL,
                    'top': newT,
                    'width': newW,
                    'height': newH
                });
                var currTransform = Math.abs($(window).height() - currH) > $(window).height() * 2 / 3 ? Math.abs($(window).height() - currH) : Math.abs($(window).height() - currH) * 0.3
                    , currDelay = newT * 0.75 > 250 ? Math.abs(newT) * 1.2 : 550
                    , currSpeed = currDelay > 250 ? 900 - Math.abs(newT) * 0.5 : 900;
                if (currTransform < 25)
                    currTransform = 25;
                var currTransform = curr.hasClass('always-top') ? -70 : currTransform
                    , transformFromUp = curr.hasClass('always-top') ? '-70%' : currTransform + '%'
                    , transformFromDown = curr.hasClass('always-bottom') || curr.hasClass('always-top') ? currTransform + '%' : -currTransform + '%';
                curr.children('span').css(noformat.transformSetter('0px', currTransform + '%'));
                curr.children('span').data('transformFromUp', transformFromUp);
                curr.children('span').data('transformFromDown', transformFromDown);
                curr.children('span').data('transformDelayFromUp', currDelay);
                curr.children('span').data('transformDelayFromDown', currDelay);
                curr.children('span').data('transformSpeedFromUp', currSpeed);
                curr.children('span').data('transformSpeedFromDown', currSpeed);
                if (curr.parents('section').hasClass('active')) {
                    curr.children('span').css(noformat.transformSetter('0px', '0px')).css({
                        '-webkit-transition': '-webkit-transform ' + curr.data('transformSpeedFromDown') + 'ms ' + curr.data('transformDelayFromDown') + 'ms ease-in-out',
                        '-moz-transition': '-moz-transform ' + curr.data('transformSpeedFromDown') + 'ms ' + curr.data('transformDelayFromDown') + 'ms ease-in-out',
                        'transition': 'transform ' + curr.data('transformSpeedFromDown') + 'ms ' + curr.data('transformDelayFromDown') + 'ms ease-in-out'
                    });
                }
            });
        },
        cloneItems: function (element) {
            $('.sections-holder section').each(function () {
                var colorScheme = $(this).data('color-scheme') == 'dark' ? 'light' : '';
                $(this).find('article').addClass(colorScheme);
            });
        },
        init: function (element) {
            var firstWordsArray = ['Fantastic', 'Beautiful', 'Inspiring', 'Lovely', 'Strong', 'Clever', 'Playful', 'Brilliant', 'Strong', 'Elegant', 'Remarkable', 'Spectacular', 'Sensational', 'Astonishing', 'Sophisticated', 'Innovative']
                , secondWordsArray = ['apps', 'websites', 'systems', 'brands', 'reports', 'art', 'design', 'decks', 'logos', 'UI', 'campaigns']
                , words = null;
            var getRandomWord = function () {
                return [firstWordsArray[Math.floor(Math.random() * firstWordsArray.length)], secondWordsArray[Math.floor(Math.random() * secondWordsArray.length)]];
            };
            function introSlideshow() {
                if ($('html').hasClass('desktop')) { }
                noformat.home.introSlideshowInterval = setInterval(function () {
                    words = getRandomWord();
                    $('.intro .first').html(words[0]);
                    $('.intro .last').html(words[1]);
                }, 200);
            }
            introSlideshow();
            if (!$('html').hasClass('desktop')) {
                $(document).bind('touchmove', function (e) {
                    e.preventDefault();
                });
            }
            var weAreSeen = false
                , clientsSeen = false;
            element.find('.sections-holder').fullpage({
                scrollingSpeed: 700,
                scrollingDelay: 500,
                onLeave: function (index, nextIndex, direction) {
                    $('body').addClass('scrolling');
                    if (nextIndex != 1) {
                        eyeVisible = false;
                        if (noformat.home.introSlideshowInterval != null) {
                            if ($('html').hasClass('desktop')) { }
                            clearInterval(noformat.home.introSlideshowInterval);
                            noformat.home.introSlideshowInterval = null;
                        }
                    } else {
                        introSlideshow();
                    }
                    $('header .nav-trigger').css({
                        '-webkit-transition': 'all 900ms 500ms ease-in-out',
                        '-moz-transition': 'all 900ms 500ms ease-in-out',
                        'transition': 'all 900ms 500ms ease-in-out'
                    });
                    if (direction == 'down') {
                        $('.sections-holder section').eq(nextIndex - 1).removeClass('went-down').find('.layer').each(function () {
                            var curr = $(this).children('span');
                            curr.css(noformat.transformSetter('0px', '0px')).css({
                                '-webkit-transition': 'transform ' + curr.data('transformSpeedFromDown') + 'ms ' + curr.data('transformDelayFromDown') + 'ms ease-in-out',
                                '-moz-transition': 'transform ' + curr.data('transformSpeedFromDown') + 'ms ' + curr.data('transformDelayFromDown') + 'ms ease-in-out',
                                'transition': 'transform ' + curr.data('transformSpeedFromDown') + 'ms ' + curr.data('transformDelayFromDown') + 'ms ease-in-out'
                            });
                        });
                        for (var i = index - 1; i < nextIndex - 1; i++) {
                            $('.sections-holder section').eq(i).addClass('went-up').removeClass('went-down').find('.parallax').parallax('disable');
                            $('.sections-holder section').eq(i).find('.layer').each(function () {
                                var curr = $(this).children('span');
                                curr.css(noformat.transformSetter('0px', curr.data('transformFromDown'))).css({
                                    '-webkit-transition': '-webkit-transform 700ms 250ms ease-in-out',
                                    '-moz-transition': '-moz-transform 700ms 250ms ease-in-out',
                                    'transition': 'transform 700ms 250ms ease-in-out'
                                });
                            });
                        }
                        ;
                    } else {
                        $('.sections-holder section').eq(nextIndex - 1).removeClass('went-up').find('.layer').each(function () {
                            var curr = $(this).children('span');
                            curr.css(noformat.transformSetter('0px', '0px')).css({
                                '-webkit-transition': '-webkit-transform ' + curr.data('transformSpeedFromUp') + 'ms 700ms ease-in-out',
                                '-moz-transition': '-moz-transform ' + curr.data('transformSpeedFromUp') + 'ms 700ms ease-in-out',
                                'transition': 'transform ' + curr.data('transformSpeedFromUp') + 'ms 700ms ease-in-out'
                            });
                        });
                        for (var i = nextIndex; i <= index - 1; i++) {
                            $('.sections-holder section').eq(i).addClass('went-down').removeClass('went-up').find('.parallax').parallax('disable');
                            $('.sections-holder section').eq(i).find('.layer').each(function () {
                                var curr = $(this).children('span');
                                curr.css(noformat.transformSetter('0px', curr.data('transformFromUp'))).css({
                                    '-webkit-transition': 'transform ' + curr.data('transformSpeedFromUp') + 'ms 250ms ease-in-out',
                                    '-moz-transition': 'transform ' + curr.data('transformSpeedFromUp') + 'ms 250ms ease-in-out',
                                    'transition': 'transform ' + curr.data('transformSpeedFromUp') + 'ms 250ms ease-in-out'
                                });
                            });
                        }
                        ;
                    }
                },
                afterLoad: function (index) {
                    $('body').removeClass('scrolling');
                    $('header .nav-trigger').css({
                        '-webkit-transition': '',
                        '-moz-transition': '',
                        'transition': ''
                    });
                    if (index == 1) {
                        eyeVisible = true;
                    }
                    $('section.active').find('.parallax').parallax('enable');
                    if (index == 2 && !weAreSeen) {
                        var weAreArray = ['strategists-list', 'designers-list', 'developers-list', 'inventors-list', 'artists-list', 'storytellers-list'];
                        for (var i = 0; i < 4; i++) {
                            var curr = weAreArray[Math.floor(Math.random() * weAreArray.length)];
                            $('.we-are .text em[data-list="' + curr + '"]').addClass('blink');
                            weAreArray.splice($.inArray(curr, weAreArray), 1);
                        }
                        $('.we-are .text .blink').each(function (i) {
                            var el = $(this);
                            setTimeout(function () {
                                el.addClass('hovered');
                                setTimeout(function () {
                                    el.removeClass('hovered');
                                }, 550)
                            }, i * 350);
                        })
                        weAreSeen = true;
                    } else if (index == 8 && !clientsSeen) {
                        var clientsArray = [0, 1, 2, 3, 4, 5];
                        for (var i = 0; i < 4; i++) {
                            var curr = clientsArray[Math.floor(Math.random() * clientsArray.length)];
                            console.log(curr)
                            $('.clients-intro .text em').eq(curr).addClass('blink');
                            clientsArray.splice($.inArray(curr, clientsArray), 1);
                        }
                        $('.clients-intro .text .blink').each(function (i) {
                            var el = $(this);
                            setTimeout(function () {
                                el.addClass('hovered');
                                setTimeout(function () {
                                    el.removeClass('hovered');
                                }, 550)
                            }, i * 350);
                        })
                        clientsSeen = true;
                    }
                }
            });
            this.cloneItems(element);
            $('.parallax').each(function (i) {
                $(this).parallax();
                $(this).parallax('disable');
            });
            this.parallaxCalculations();
            if (noformat.handheldScrollInterval != null) {
                $('header').removeClass('header-up').removeClass('sticky-header');
                clearInterval(noformat.handheldScrollInterval);
                noformat.handheldScrollInterval = null;
            }
        },
        resize: function () {
            this.parallaxCalculations();
        }
    },
    about: {
        init: function (element) {
            var weMakeSeen = false;
            if ($('html').hasClass('mobile')) {
                noformat.mobileTabletHeader();
            }
            if ($('html').hasClass('mobile') && !$('body').hasClass('page-template-page-about')) {
                element.find('section').not('.footer').each(function () {
                    $(this).css('min-height', noformat.windowH);
                });
            }
            if (!$('html').hasClass('desktop') && !$('html').hasClass('mobile')) {
                $(document).bind('touchmove', function (e) {
                    e.preventDefault();
                });
            }
            $('.testimonials-slider').slick({
                fade: true,
                arrows: false,
                dots: true,
                autoplay: true,
                autoplaySpeed: 7000,
            });
            if (!$('html').hasClass('mobile')) {
                $('.testimonials-slider').slick('slickPause');
                element.find('.sections-holder').fullpage({
                    scrollingSpeed: 700,
                    scrollingDelay: 500,
                    onLeave: function (index, nextIndex, direction) {
                        $('body').addClass('scrolling');
                        $('.we-design ul, .we-are ul').trigger('mousemove');
                        if (direction == 'down') {
                            $('.sections-holder section').eq(nextIndex - 1).removeClass('went-down');
                            for (var i = index - 1; i < nextIndex - 1; i++) {
                                $('.sections-holder section').eq(i).addClass('went-up').removeClass('went-down');
                            }
                            ;
                        } else {
                            $('.sections-holder section').eq(nextIndex - 1).removeClass('went-up');
                            for (var i = nextIndex; i <= index - 1; i++) {
                                $('.sections-holder section').eq(i).addClass('went-down').removeClass('went-up');
                            }
                            ;
                        }
                        $('.sections-holder section').eq(nextIndex - 1).hasClass('testimonials') ? $('.testimonials-slider').slick('slickPlay') : $('.testimonials-slider').slick('slickPause');
                    },
                    afterLoad: function (index) {
                        $('body').removeClass('scrolling');
                        $('header .nav-trigger').css({
                            '-webkit-transition': '',
                            '-moz-transition': '',
                            'transition': ''
                        });
                    }
                });
            }
        }
    },
    single: {
        singleElementsOffsets: [],
        players: null,
        isPlayerLoaded: false,
        playerLoadedInterval: null,
        isContentLoaded: false,
        contentLoadedInterval: null,
        videoOffsets: [],
        introVideoReady: false,
        contentReady: false,
        isManuallyPaused: [],
        resizeTimeout: null,
        calculations: function () {
            $('.single-holder .single-intro').css({
                'height': noformat.windowH * 0.85
            });
            $('.single-holder .images-list li').each(function () {
                var curr = $(this);
                if ($('html').hasClass('desktop')) {
                    $(window).width() > 660 ? curr.css({
                        'height': noformat.windowW * 1080 / 1920
                    }) : curr.css({
                        'height': curr.is(':empty') ? noformat.windowH * 830 / 1920 : 'auto'
                    });
                } else {
                    curr.css({
                        'height': noformat.windowW * 1080 / 1920
                    });
                }
            })
            $('.text-holder .img-holder').each(function () {
                var curr = $(this);
                var currW = curr.find('img').attr('width')
                    , currH = curr.find('img').attr('height')
                    , newW = curr.parents('.text-holder').width()
                    , newH = Math.floor(currH * newW / currW) - 1;
                console.log('');
                curr.find('div').css({
                    'height': newH
                })
            });
            var offset = $('.single-intro .video-holder').outerHeight();
            if (noformat.windowW >= noformat.windowH * 0.85 * 16 / 9) {
                $('.single-intro .video-wrapper, .single-holder .images-list .video-wrapper').css({
                    'width': '',
                    'marginLeft': ''
                })
                $('.single-intro .video-holder').css(noformat.transformSetter('0px', -(offset - noformat.windowH * 0.85) / 2 + 'px'));
            } else {
                $('.single-intro .video-holder').css(noformat.transformSetter('0px', '0px'));
                $('.single-intro .video-wrapper').css({
                    'width': noformat.windowH * 0.85 * 16 / 9,
                    'marginLeft': (noformat.windowW - noformat.windowH * 0.85 * 16 / 9) / 2
                })
                if ($('html').hasClass('desktop')) {
                    $('.single-holder .images-list .video-wrapper').css({
                        'width': noformat.windowH * 0.85 * 16 / 9,
                        'marginLeft': (noformat.windowW - noformat.windowH * 0.85 * 16 / 9) / 2
                    })
                }
            }
            noformat.single.videoOffsets = [];
            $('.video-wrapper').each(function () {
                var curr = $(this)
                    , offset = noformat.scroll == null ? 0 : noformat.scroll.vars.current
                    , textHolderOffset = curr.parents('.text-holder').length ? 300 : 0;
                noformat.single.videoOffsets.push({
                    'top': curr.offset().top + offset - textHolderOffset,
                    'height': curr.outerHeight()
                });
            });
            noformat.single.singleElementsOffsets = [];
            $('.animated').each(function () {
                var curr = $(this)
                    , scrollOffset = noformat.scroll == null ? 0 : noformat.scroll.vars.current;
                noformat.single.singleElementsOffsets.push({
                    'top': curr.offset().top + scrollOffset - 150,
                    'height': curr.outerHeight()
                });
            });
            if (noformat.scroll != null) {
                noformat.scroll.resize();
                noformat.scroll.calc({
                    deltaX: 0,
                    deltaY: 0
                });
            }
        },
        init: function (element) {
            if (!$('html').hasClass('desktop')) {
                noformat.mobileTabletHeader();
            }
            if (!$('.single-intro').find('.video-holder').length)
                $('.single-intro .bgr-holder').css('display', 'block')
            noformat.single.players = vimeovideo.setup();
            if ($('html').hasClass('desktop')) {
                noformat.single.isManuallyPaused = [];
                for (var i = 0; i < noformat.single.players.length; i++) {
                    noformat.single.players[i].on('ready', function (event) {
                        var curr = $(this)
                            , currIndex = curr.parent().index('.video-wrapper');
                        if (!event.detail.vimeovideo.isMuted())
                            event.detail.vimeovideo.toggleMute();
                        if (curr.parents('.single-intro').length) {
                            $('.single-intro .vimeovideo-play-large').css({
                                'opacity': '0',
                                'visibility': 'hidden'
                            })
                            noformat.single.introVideoReady = true;
                            if (noformat.single.contentReady) {
                                event.detail.vimeovideo.play();
                            }
                        }
                        ; if (currIndex == noformat.single.players.length - 1) {
                            console.log('');
                            noformat.single.resize();
                        }
                    });
                    noformat.single.isManuallyPaused.push(false);
                }
            }
            if (noformat.single.players) {
                noformat.single.players[0].on('timeupdate', function () {
                    if (noformat.single.players[0].getCurrentTime() > 0.1) {
                        $('.single-intro .vimeovideo-play-large').css({
                            'opacity': '',
                            'visibility': ''
                        })
                        if ($('.intro-video-spinner-holder').length)
                            $('.intro-video-spinner-holder').fadeOut(300, function () {
                                $(this).remove();
                            })
                    }
                });
            }
            var offset = $('.single-intro .video-holder').outerHeight();
            if (noformat.windowW >= noformat.windowH * 0.85 * 16 / 9) {
                $('.single-intro .video-wrapper, .single-holder .images-list .video-wrapper').css({
                    'width': '',
                    'marginLeft': ''
                })
                $('.single-intro .video-holder').css(noformat.transformSetter('0px', -(offset - noformat.windowH * 0.85) / 2 + 'px'));
            } else {
                $('.single-intro .video-holder').css(noformat.transformSetter('0px', '0px'));
                $('.single-intro .video-wrapper').css({
                    'width': noformat.windowH * 0.85 * 16 / 9,
                    'marginLeft': (noformat.windowW - noformat.windowH * 0.85 * 16 / 9) / 2
                })
                if ($('html').hasClass('desktop')) {
                    $('.single-holder .images-list .video-wrapper').css({
                        'width': noformat.windowH * 0.85 * 16 / 9,
                        'marginLeft': (noformat.windowW - noformat.windowH * 0.85 * 16 / 9) / 2
                    })
                }
            }
            $('.top-btn').click(function (e) {
                e.preventDefault();
                $('html').hasClass('desktop') ? noformat.scroll.scrollTo(0) : $('html, body').stop().animate({
                    scrollTop: 0
                }, 2000)
                $('header').removeClass('header-up');
            });
            $('.text-holder').children().each(function () {
                var curr = $(this);
                if (curr.css('text-align') == 'right') {
                    curr.css({
                        'float': 'right',
                        'textAlign': 'left'
                    });
                }
                if (curr.is('.project-tags')) {
                    if ($('html').hasClass('mobile')) {
                        var previous = curr.prevAll().last()
                            , clonedTags = curr.clone(true, true);
                        curr.remove();
                        clonedTags.insertAfter(previous);
                        clonedTags.css('float', 'right').prevAll().last().css({
                            'float': 'left',
                            'clear': 'both'
                        });
                    } else {
                        var previous = curr.prevAll().first();
                        if (previous.css('float') == 'right') {
                            var clonedTags = curr.clone(true, true);
                            curr.remove();
                            previous.css({
                                'float': 'right',
                                'clear': 'right',
                                'marginBottom': '0px'
                            });
                            clonedTags.insertBefore(previous).css({
                                'float': 'left',
                                'clear': 'both'
                            });
                        } else {
                            curr.css('float', 'right').prevAll().first().css({
                                'float': 'left',
                                'clear': 'both',
                                'marginBottom': '0px'
                            });
                        }
                    }
                }
                if (curr.children().length == 1 && (curr.children().is('img') || curr.children().is('video'))) {
                    curr.css('width', '100%');
                    if (curr.children().is('img')) {
                        var currW = curr.children('img').attr('width')
                            , currH = curr.children('img').attr('height')
                            , newW = curr.parents('.text-holder').width()
                            , newH = Math.floor(currH * newW / currW) - 1;
                        console.log('')
                        curr.css('margin-bottom', '0px').children().wrap('<div class="img-holder"><div /></div>');
                        curr.find('.img-holder div').css({
                            'height': newH,
                            'background': '#eeeeee'
                        })
                    }
                }
                if (curr.is('p'))
                    curr.filter(function () {
                        return $.trim(this.innerHTML) == ""
                    }).remove();
                curr.addClass('animated');
            });
            this.calculations();
            var raf;
            if (typeof raf == 'undefined')
                scrollingAnimation();
            function scrollingAnimation() {
                if ($('html').hasClass('desktop') && !$('body').hasClass('page-template-page-work') && noformat.scroll != null && Math.abs(noformat.scroll.vars.current - noformat.scroll.vars.target) >= 1) {
                    if (noformat.scroll.vars.current < noformat.windowH) {
                        if ($('.single-intro .video-wrapper').length) {
                            $('.single-intro .video-wrapper').css(noformat.transformSetter('0px', noformat.scroll.vars.current + 'px'));
                            $('.single-intro .vimeovideo-play-large').css(noformat.transformSetter('-50%', -noformat.scroll.vars.current + 'px'));
                            $('.single-intro .vimeovideo-controls').css(noformat.transformSetter('0px', -noformat.scroll.vars.current + 'px'));
                        } else {
                            $('.single-intro .bgr-holder').css(noformat.transformSetter('0px', noformat.scroll.vars.current + 'px'));
                        }
                        var opacity = noformat.scroll.vars.current / noformat.windowH * 2;
                        $('.single-intro article').css(noformat.transformSetter('-50%', -noformat.scroll.vars.current * 0.25 + 'px')).css('opacity', 1 - opacity);
                    }
                    if (noformat.scroll.vars.current > 100) {
                        $('header').addClass('sticky-header');
                        noformat.scroll.vars.current < noformat.scroll.vars.target && !$('header').hasClass('opened') ? $('header').css('margin-top', '-80px') : $('header').css('margin-top', '0px');
                    } else {
                        $('header').removeClass('sticky-header');
                    }
                    $('.video-wrapper').each(function (i) {
                        var curr = $(this);
                        if (noformat.scroll.vars.current >= noformat.single.videoOffsets[i].top - noformat.windowH && noformat.scroll.vars.current < noformat.single.videoOffsets[i].top + noformat.single.videoOffsets[i].height) {
                            if (noformat.single.players[i].isPaused() && !noformat.single.isManuallyPaused[i])
                                noformat.single.players[i].play();
                        } else if (!noformat.single.players[i].isPaused()) {
                            noformat.single.players[i].pause();
                        }
                    });
                    $('.animated').each(function (i) {
                        var curr = $(this);
                        noformat.single.singleElementsOffsets[i].top - noformat.scroll.vars.current < noformat.windowH ? curr.addClass('inview') : curr.removeClass('inview');
                    });
                    if (!$('body').hasClass('scrolling'))
                        $('body').addClass('scrolling');
                } else {
                    if ($('body').hasClass('scrolling'))
                        $('body').removeClass('scrolling');
                }
                raf = requestAnimationFrame(scrollingAnimation);
            }
            ;
        },
        resize: function () {
            if (noformat.single.resizeTimeout != null) {
                clearTimeout(noformat.single.resizeTimeout);
                noformat.single.resizeTimeout = null;
            }
            noformat.single.resizeTimeout = setTimeout(function () {
                noformat.single.calculations();
            }, 500);
        }
    },
    contact: {
        init: function (element) {
            if ($('html').hasClass('mobile'))
                noformat.mobileTabletHeader();
        }
    },
    work: {
        grid: null,
        calculations: function () {
            $('.work-grid .item').each(function () {
                var currW = $(this).width();
                $(this).css('height', currW * 0.6)
            });
            this.grid.isotope('layout');
            this.grid.on('layoutComplete', function (event, filteredItems) {
                if (noformat.scroll != null) {
                    noformat.scroll.resize();
                    noformat.scroll.calc({
                        deltaX: 0,
                        deltaY: 0
                    });
                }
            });
            if ($('html').hasClass('mobile')) {
                var visibleItems = 0;
                for (var i = 0; i < 4; i++) {
                    var currOffset = i == 3 ? 2 : 1;
                    visibleItems += $('.filters li').eq(i).outerWidth() / currOffset;
                }
                var currMargin = (noformat.windowW - visibleItems) / 9;
                $('.filters li').css({
                    'margin': '0px ' + currMargin + 'px'
                })
                var filtersW = 0;
                $('.filters li').each(function () {
                    filtersW += $(this).outerWidth(true) + 3;
                })
                $('.filters').css('width', filtersW);
            }
        },
        init: function (element) {
            if (!$('html').hasClass('desktop')) {
                noformat.mobileTabletHeader();
            }
            this.grid = $('.work-grid .grid').isotope({
                itemSelector: '.item',
            });
            $('.filters').on('click', 'a', function (e) {
                e.preventDefault();
                var curr = $(this);
                if (!curr.hasClass('is-checked')) {
                    var filterValue = curr.attr('data-filter');
                    noformat.work.grid.isotope({
                        filter: filterValue
                    });
                    curr.parents('ul').find('a').removeClass('is-checked');
                    curr.addClass('is-checked');
                }
            });
            this.resize();
        },
        resize: function () {
            this.calculations();
        }
    },
    mobileTabletHeader: function () {
        var distanceFromTop = $(window).scrollTop(), didScroll, lastScrollTop = 0, delta = 2, navbarHeight = $('header').outerHeight();
        if (noformat.handheldScrollInterval != null) {
            clearInterval(noformat.handheldScrollInterval);
            noformat.handheldScrollInterval = null;
        }
        noformat.handheldScrollInterval = setInterval(function () {
            if (didScroll && !$('header').hasClass('opened')) {
                hasScrolled();
                didScroll = false;
            }
        }, 10);
        function hasScrolled() {
            var st = $(this).scrollTop();
            if (Math.abs(lastScrollTop - st) <= delta)
                return;
            if (st > lastScrollTop && st > navbarHeight) {
                $('header').addClass('header-up');
            } else {
                if (st + $(window).height() < $(document).height()) {
                    $('header').removeClass('header-up');
                }
            }
            lastScrollTop = st;
        }
        ; $('header').removeClass('header-up sticky-header');
        $(window).on('scroll', function (e) {
            if (($('html').hasClass('mobile') && !$('body').hasClass('home')) || ($('html').hasClass('tablet') && !$('body').hasClass('home') && !$('body').hasClass('page-template-page-about'))) {
                distanceFromTop = $(window).scrollTop();
                distanceFromTop > 0 ? $('header').addClass('sticky-header') : $('header').removeClass('sticky-header');
                didScroll = true;
            }
        });
    },
    resize: function () {
        if (this.windowW != $(window).width() || $('html').hasClass('desktop')) {
            if (noformat.resizeTimeout != null) {
                clearTimeout(noformat.resizeTimeout);
                noformat.resizeTimeout = null;
            }
            this.windowW = viewport().width;
            this.windowH = $(window).height();
            noformat.resizeTimeout = setTimeout(function () {
                if ($(window).height() < 750) {
                    $('html').addClass('lower-height');
                } else if ($(window).height() < 900) {
                    $('html').addClass('low-height');
                } else {
                    $('html').removeClass('low-height').removeClass('lower-height');
                }
                if ($('body').hasClass('single')) {
                    noformat.single.resize();
                } else if ($('body').hasClass('home')) {
                    noformat.home.resize();
                } else if ($('body').hasClass('page-template-page-work')) {
                    noformat.work.resize();
                }
                clearTimeout(noformat.resizeTimeout);
                noformat.resizeTimeout = null;
            }, 500);
        }
    }
};
$('body').on('click', '.nav-trigger', function (e) {
    e.preventDefault();
    var closingTimeout = null;
    if (!$('header').hasClass('opened')) {
        if (closingTimeout != null)
            clearTimeout(closingTimeout);
        $('header').css({
            '-webkit-transform': 'none',
            '-moz-transform': 'none',
            'transform': 'none',
            '-webkit-transition': 'none',
            '-moz-transition': 'none',
            'transition': 'none'
        })
    } else {
        closingTimeout = setTimeout(function () {
            $('header').css({
                '-webkit-transform': '',
                '-moz-transform': '',
                'transform': '',
                '-webkit-transition': '',
                '-moz-transition': '',
                'transition': ''
            })
            clearTimeout(closingTimeout)
        }, 500)
    }
    $('header').hasClass('opened') ? $(this).text('menu.') : $(this).text('close.');
    $('header').toggleClass('opened');
    $('header').hasClass('opened') ? $('.nav-overlay').stop().fadeIn(500) : $('.nav-overlay').stop().fadeOut(500);
});
$('.nav-overlay').click(function (e) {
    if ($('header').hasClass('opened'))
        $('.nav-trigger').trigger('click');
});
$(window).resize(function () {
    noformat.resize();
});
var mouseX = 0, mouseY = 0, mouseX1 = 0, mouseY1 = 0, innerEyeRenderer = null, iinnerEyeRenderer = null, outerEyeRenderer = null, reqAnim;
function eyeInit() {
    var sceneBG = new THREE.Scene()
        , innerEyeScene = new THREE.Scene()
        , iinnerEyeScene = new THREE.Scene()
        , outerEyeScene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 3000);
    camera.position.z = 78;
    camera.target = new THREE.Vector3(0, 0, 0);
    outerEyeRenderer = new THREE.WebGLRenderer({
        alpha: true
    });
    outerEyeRenderer.setClearColor(0x000000, 0.0);
    outerEyeRenderer.autoClear = false;
    outerEyeRenderer.setSize(window.innerWidth, window.innerHeight);
    innerEyeRenderer = new THREE.WebGLRenderer({
        alpha: true
    });
    innerEyeRenderer.setClearColor(0x000000, 0.0);
    innerEyeRenderer.autoClear = false;
    innerEyeRenderer.setSize(window.innerWidth, window.innerHeight);

    iinnerEyeRenderer = new THREE.WebGLRenderer({
        alpha: true
    });
    iinnerEyeRenderer.setClearColor(0x000000, 0.0);
    iinnerEyeRenderer.autoClear = false;
    iinnerEyeRenderer.setSize(window.innerWidth, window.innerHeight);

    document.getElementById('outer-eye').appendChild(outerEyeRenderer.domElement);
    document.getElementById('inner-eye').appendChild(innerEyeRenderer.domElement);
    document.getElementById('iinner-eye').appendChild(iinnerEyeRenderer.domElement);
    var clock = new THREE.Clock();
    var ambi = new THREE.AmbientLight(0xffffff);
    innerEyeScene.add(ambi);
    iinnerEyeScene.add(ambi);
    outerEyeScene.add(ambi);
    window.addEventListener('mousemove', onMouseMove, false);
    window.addEventListener('resize', onResize, false);
    window.addEventListener('deviceorientation', onDeviceOrientation, false);
    function onMouseMove(e) {
        mouseX = (e.clientX - window.innerWidth / 2) * 0.001;
        mouseY = (e.clientY - window.innerHeight / 2) * 0.001;
        mouseX1 = (e.clientX - window.innerWidth / 2) * 0.0005;
        mouseY1 = (e.clientY - window.innerHeight / 2) * 0.0005;
    }
    function onResize() {
        var width = window.innerWidth;
        var height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        outerEyeRenderer.setSize(width, height);
        innerEyeRenderer.setSize(width, height);
        iinnerEyeRenderer.setSize(width, height);
    }
    var orientationStatus = 0
        , startingPoint = {
            x: 0,
            y: 0
        };
    function onDeviceOrientation(e) {
        if ($('html').hasClass('tablet') && $('html').hasClass('landscape')) {
            var x = (e.beta || 0) / 90
                , y = (e.gamma || 0) / 90;
            mouseY = y * 0.2;
            mouseY1 = y * 0.2;
            mouseX = x * 0.2;
            mouseX1 = x * 0.2;
            console.log(e.beta)
        } else {
            var y = (e.beta || 0) / 90
                , x = (e.gamma || 0) / 90;
            mouseY = y * 0.2;
            mouseY1 = y * 0.2;
            mouseX = x * 0.2;
            mouseX1 = x * 0.2;
        }
    }
    ; var textureEnvRefl_A = new THREE.ImageUtils.loadTexture(themeUrl + '/assets/img/refl.jpg')
        , textureEnvDiff_A = new THREE.ImageUtils.loadTexture(themeUrl + '/assets/img/diff1.jpg')
        , textureEyeColor_A = new THREE.ImageUtils.loadTexture(themeUrl + '/assets/img/eye-pattern.jpg')
        , textureEyeNormal_A = new THREE.ImageUtils.loadTexture(themeUrl + '/assets/img/eye-normals.png')
        , textureEyeNormal_A1 = new THREE.ImageUtils.loadTexture(themeUrl + '/assets/img/eye-normals1.png')
        , texturelog = new THREE.ImageUtils.loadTexture(themeUrl + '/assets/logo.png')
        , textureEyeColor_A1 = new THREE.ImageUtils.loadTexture(themeUrl + '/assets/img/eye-pattern1.jpg')
        , textureEyeRefract_C = new THREE.ImageUtils.loadTexture(themeUrl + '/assets/img/refract.png');
    textureEyeColor_A.wrapS = textureEyeNormal_A.wrapS = textureEyeColor_A1.wrapS = textureEyeNormal_A1.wrapS = THREE.RepeatWrapping;
    textureEyeColor_A.minFilter = textureEyeColor_A.magFilter = textureEyeNormal_A.minFilter = textureEyeNormal_A.magFilter = textureEyeColor_A1.minFilter = textureEyeColor_A1.magFilter = textureEyeNormal_A1.minFilter = textureEyeNormal_A1.magFilter = THREE.LinearFilter;
    var innerEyeUniforms = {
        texEyeCol: {
            type: "t",
            value: textureEyeColor_A
        },
        texEyeNrm: {
            type: "t",
            value: textureEyeNormal_A
        },
        texEnvRfl: {
            type: "t",
            value: textureEnvRefl_A
        },
        texEnvDif: {
            type: "t",
            value: textureEnvDiff_A
        },
        texEnvRfr: {
            type: "t",
            value: textureEyeRefract_C
        },
        pupil_size: {
            type: "f",
            value: 0.2
        },
        iris_tex_start: {
            type: "f",
            value: 0.02
        },
        iris_tex_end: {
            type: "f",
            value: 0.13
        },
        iris_border: {
            type: "f",
            value: 0.0
        },
        iris_size: {
            type: "f",
            value: 0.64
        },
        iris_edge_fade: {
            type: "f",
            value: 0.2
        },
        iris_inset_depth: {
            type: "f",
            value: 0.0
        },
        sclera_tex_scale: {
            type: "f",
            value: 2
        },
        sclera_tex_offset: {
            type: "f",
            value: -10
        },
        ior: {
            type: "f",
            value: 2
        },
        refract_edge_softness: {
            type: "f",
            value: 0.1
        },
        iris_texture_curvature: {
            type: "f",
            value: -1
        },
        arg_iris_shading_curvature: {
            type: "f",
            value: -1.0
        },
        tex_U_offset: {
            type: "f",
            value: 0.0
        },
        cornea_bump_amount: {
            type: "f",
            value: 0.0
        },
        cornea_bump_radius_mult: {
            type: "f",
            value: 0.9
        },
        iris_normal_offset: {
            type: "f",
            value: 0.001
        },
        cornea_density: {
            type: "f",
            value: 0.001
        },
        bump_texture: {
            type: "f",
            value: 2.0
        },
        catshape: {
            type: "i",
            value: false
        },
        cybshape: {
            type: "f",
            value: false
        },
        col_texture: {
            type: "i",
            value: true
        },
        outer: {
            type: "i",
            value: false
        },
        alpha_intensity: {
            type: "f",
            value: 0.4
        },
    };
    var iinnerEyeUniforms = {
        texEyeCol: {
            type: "t",
            value: textureEyeColor_A
        },
        texEyeNrm: {
            type: "t",
            value: textureEyeNormal_A
        },
        texEnvRfl: {
            type: "t",
            value: textureEnvRefl_A
        },
        texEnvDif: {
            type: "t",
            value: textureEnvDiff_A
        },
        texEnvRfr: {
            type: "t",
            value: textureEyeRefract_C
        },
        pupil_size: {
            type: "f",
            value: 0.2
        },
        iris_tex_start: {
            type: "f",
            value: 0.02
        },
        iris_tex_end: {
            type: "f",
            value: 0.13
        },
        iris_border: {
            type: "f",
            value: 0.0
        },
        iris_size: {
            type: "f",
            value: 0.64
        },
        iris_edge_fade: {
            type: "f",
            value: 0.2
        },
        iris_inset_depth: {
            type: "f",
            value: 0.0
        },
        sclera_tex_scale: {
            type: "f",
            value: 2
        },
        sclera_tex_offset: {
            type: "f",
            value: -10
        },
        ior: {
            type: "f",
            value: 2
        },
        refract_edge_softness: {
            type: "f",
            value: 0.1
        },
        iris_texture_curvature: {
            type: "f",
            value: -1
        },
        arg_iris_shading_curvature: {
            type: "f",
            value: -1.0
        },
        tex_U_offset: {
            type: "f",
            value: 0.0
        },
        cornea_bump_amount: {
            type: "f",
            value: 0.0
        },
        cornea_bump_radius_mult: {
            type: "f",
            value: 0.9
        },
        iris_normal_offset: {
            type: "f",
            value: 0.001
        },
        cornea_density: {
            type: "f",
            value: 0.001
        },
        bump_texture: {
            type: "f",
            value: 2.0
        },
        catshape: {
            type: "i",
            value: false
        },
        cybshape: {
            type: "f",
            value: false
        },
        col_texture: {
            type: "i",
            value: true
        },
        outer: {
            type: "i",
            value: false
        },
        alpha_intensity: {
            type: "f",
            value: 0.4
        },
    };
    var outerEyeUniforms = {
        texEyeCol: {
            type: "t",
            value: textureEyeColor_A1
        },
        texEyeNrm: {
            type: "t",
            value: textureEyeNormal_A1
        },
        texEnvRfl: {
            type: "t",
            value: textureEnvRefl_A
        },
        texEnvDif: {
            type: "t",
            value: textureEnvDiff_A
        },
        texEnvRfr: {
            type: "t",
            value: textureEyeRefract_C
        },
        pupil_size: {
            type: "f",
            value: 0.2
        },
        iris_tex_start: {
            type: "f",
            value: 0.02
        },
        iris_tex_end: {
            type: "f",
            value: 0.13
        },
        iris_border: {
            type: "f",
            value: 0.001
        },
        iris_size: {
            type: "f",
            value: 0.64
        },
        iris_edge_fade: {
            type: "f",
            value: 0.2
        },
        iris_inset_depth: {
            type: "f",
            value: 0.0
        },
        sclera_tex_scale: {
            type: "f",
            value: 0
        },
        sclera_tex_offset: {
            type: "f",
            value: 0.04
        },
        ior: {
            type: "f",
            value: 2
        },
        refract_edge_softness: {
            type: "f",
            value: 0.1
        },
        iris_texture_curvature: {
            type: "f",
            value: -1
        },
        arg_iris_shading_curvature: {
            type: "f",
            value: -1.0
        },
        tex_U_offset: {
            type: "f",
            value: 0.0
        },
        cornea_bump_amount: {
            type: "f",
            value: 0.0
        },
        cornea_bump_radius_mult: {
            type: "f",
            value: 0.9
        },
        iris_normal_offset: {
            type: "f",
            value: 0.001
        },
        cornea_density: {
            type: "f",
            value: 0.001
        },
        bump_texture: {
            type: "f",
            value: 0.3
        },
        catshape: {
            type: "i",
            value: false
        },
        cybshape: {
            type: "f",
            value: false
        },
        col_texture: {
            type: "i",
            value: true
        },
        outer: {
            type: "i",
            value: true
        },
        alpha_intensity: {
            type: "f",
            value: 0.0
        },
    };
    var objectLoader = new THREE.OBJLoader()
        , halfSpheresObj = null
        , sphereGeomety = new THREE.SphereGeometry(32, 64, 64);
    objectLoader.load(themeUrl + './assets/logo1.png', function (object) {
        halfSpheresObj = object.children[0].geometry;
    }, function (xhr) { }, function (error) { });
    var outerEyeMaterial = new THREE.ShaderMaterial({
        uniforms: outerEyeUniforms,
        vertexShader: document.getElementById('eyeVertexShader').textContent,
        fragmentShader: document.getElementById('eyeFragmentShader').textContent,
        transparent: true,
        side: THREE.doubleSide
    })
        , outerEye = new THREE.Mesh(sphereGeomety, outerEyeMaterial);
    outerEye.scale.set(0.6, 0.6, 0.6)
    outerEyeScene.add(outerEye);
    var innerEyeMaterial = new THREE.ShaderMaterial({
        uniforms: innerEyeUniforms,
        vertexShader: document.getElementById('eyeVertexShader').textContent,
        fragmentShader: document.getElementById('eyeFragmentShader').textContent,
        transparent: true,
        side: THREE.doubleSide
    })
        , innerEye = new THREE.Mesh(sphereGeomety, innerEyeMaterial);
    innerEye.scale.set(0.6, 0.6, 0.6)
    innerEyeScene.add(innerEye);

    var geometry = new THREE.SphereGeometry(32, 64, 64);
    var loader = new THREE.TextureLoader();




    var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(500, 400);
    document.body.appendChild(renderer.domElement);

    var svg = document.getElementById("svgContainer").querySelector("svg");
    var svgData = (new XMLSerializer()).serializeToString(svg);

    var canvas = document.createElement("canvas");
    var svgSize = svg.getBoundingClientRect();
    canvas.width = svgSize.width;
    canvas.height = svgSize.height;
    var ctx = canvas.getContext("2d");

    var img = document.createElement("img");
    img.setAttribute("src", "data:image/svg+xml;base64," + window.btoa(unescape(encodeURIComponent(svgData))));

    img.onload = function () {
        ctx.drawImage(img, 0, 0);

        var texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;

        var geometry = new THREE.SphereGeometry(3, 50, 50, 0, Math.PI * 2, 0, Math.PI * 2);
        var material = new THREE.MeshBasicMaterial({ map: texture });
        material.map.minFilter = THREE.LinearFilter;
        mesh = new THREE.Mesh(geometry, material);
        iinnerEyeScene.add(mesh);
    };











    // iinnerEyeScene.add(iinnerEye);

    var light = new THREE.PointLight(0xffffff, 4, 0);

    // Specify the light's position
    light.position.set(1, 1, 100);

    // Add the light to the scene
    iinnerEyeScene.add(light);






    var blackMaskGeometry = new THREE.SphereGeometry(46, 64, 64)
        , blackMaskMaterial = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('blackMaskVertexShader').textContent,
            fragmentShader: document.getElementById('blackMaskFragmentShader').textContent,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthTest: false
        })
        , blackMask = new THREE.Mesh(blackMaskGeometry, blackMaskMaterial)
    blackMask.scale.set(0.6, 0.6, 0.6)
    outerEyeScene.add(blackMask);
    var hBlur = new THREE.ShaderPass(THREE.HorizontalBlurShader)
        , vBlur = new THREE.ShaderPass(THREE.VerticalBlurShader);
    hBlur.uniforms.h.value = 2.75 / window.innerHeight;
    vBlur.uniforms.v.value = 2.75 / window.innerWidth;
    var bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.0, 0.0, 1.0);
    var bgRenderPass = new THREE.RenderPass(sceneBG, camera)
        , iinnerEyeRenderPass = new THREE.RenderPass(iinnerEyeScene, camera)
        , innerEyeRenderPass = new THREE.RenderPass(innerEyeScene, camera)
        , outerEyerenderPass = new THREE.RenderPass(outerEyeScene, camera);
    iinnerEyeRenderPass.clear = false;
    innerEyeRenderPass.clear = false;
    outerEyerenderPass.clear = false;
    var effectCopy = new THREE.ShaderPass(THREE.CopyShader);
    effectCopy.renderToScreen = true;
    var rtParameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        stencilBuffer: true
    }
        , outerEyeComposer = new THREE.EffectComposer(outerEyeRenderer, new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParameters));
    innerEyeComposer = new THREE.EffectComposer(innerEyeRenderer, new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParameters));
    iinnerEyeComposer = new THREE.EffectComposer(iinnerEyeRenderer, new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParameters));
    outerEyeComposer.renderTarget1.stencilBuffer = true;
    outerEyeComposer.renderTarget2.stencilBuffer = true;
    innerEyeComposer.renderTarget1.stencilBuffer = true;
    innerEyeComposer.renderTarget2.stencilBuffer = true;
    iinnerEyeComposer.renderTarget1.stencilBuffer = true;
    iinnerEyeComposer.renderTarget2.stencilBuffer = true;
    outerEyeComposer.addPass(bgRenderPass);
    outerEyeComposer.addPass(outerEyerenderPass);
    outerEyeComposer.addPass(hBlur);
    outerEyeComposer.addPass(vBlur);
    outerEyeComposer.addPass(effectCopy);
    innerEyeComposer.addPass(bgRenderPass);
    innerEyeComposer.addPass(innerEyeRenderPass);
    innerEyeComposer.addPass(bloomPass);
    innerEyeComposer.addPass(effectCopy);
    iinnerEyeComposer.addPass(bgRenderPass);
    iinnerEyeComposer.addPass(iinnerEyeRenderPass);
    iinnerEyeComposer.addPass(bloomPass);
    iinnerEyeComposer.addPass(effectCopy);
    render();
    var bloomTimer = 0;
    function showHideObj(obj, state) {
        obj.traverse(function (child) {
            if (child instanceof THREE.Mesh) {
                child.visible = state;
            }
        });
    }
    function render(a) {
        if (eyeVisible) {
            bloomTimer += 0.1;
            if (bloomTimer >= 15) {
                if (bloomTimer < 20) {
                    bloomPass.strength += 0.05;
                    bloomPass.threshold -= 0.05;
                    innerEyeUniforms.cornea_bump_amount.value += 0.0035;
                    iinnerEyeUniforms.cornea_bump_amount.value += 0.0035;
                } else {
                    bloomPass.strength -= 0.05;
                    bloomPass.threshold += 0.05;
                    innerEyeUniforms.cornea_bump_amount.value -= 0.0035;
                    iinnerEyeUniforms.cornea_bump_amount.value -= 0.0035;
                }
                var flash = 19;
                if (bloomTimer > flash) {
                    if (bloomTimer < flash + 0.3) {
                        showHideObj(innerEye, false);
                        showHideObj(iinnerEye, false);
                        showHideObj(outerEye, false);
                    } else if (bloomTimer < flash + 0.6) {
                        showHideObj(innerEye, true);
                        showHideObj(iinnerEye, true);
                        showHideObj(outerEye, true);
                        if (innerEye != null && halfSpheresObj != null)
                            innerEye.geometry = halfSpheresObj;
                        if (iinnerEye != null && halfSpheresObj != null)
                            iinnerEye.geometry = geometry;
                    } else if (bloomTimer < flash + 0.9) {
                        showHideObj(innerEye, false);
                        showHideObj(iinnerEye, false);
                        showHideObj(outerEye, false);
                        if (innerEye != null && halfSpheresObj != null)
                            innerEye.geometry = halfSpheresObj;
                        if (iinnerEye != null && halfSpheresObj != null)
                            iinnerEye.geometry = geometry;
                    } else {
                        if (innerEye != null && halfSpheresObj != null)
                            innerEye.geometry = halfSpheresObj;
                        showHideObj(innerEye, true);
                        if (iinnerEye != null && halfSpheresObj != null)
                            iinnerEye.geometry = geometry;
                        showHideObj(iinnerEye, true);
                        showHideObj(outerEye, true);
                    }
                    if (bloomTimer < flash + 0.15) {
                        outerEye.scale.set(0.0, 0.0, 0.0);
                        iinnerEye.scale.set(0.6, 0.6, 0.6);
                    }
                    if (bloomTimer > 23 && bloomTimer < 23.5) {
                        showHideObj(innerEye, false);
                        showHideObj(iinnerEye, false);
                        showHideObj(outerEye, false);
                        outerEye.scale.set(0.6, 0.6, 0.6);
                        iinnerEye.scale.set(0.0, 0.0, 0.0);
                    } else if (bloomTimer > 23.5) {
                        showHideObj(innerEye, true);
                        showHideObj(iinnerEye, true);
                        showHideObj(outerEye, true);
                        if (innerEye != null)
                            innerEye.geometry = sphereGeomety;
                        if (iinnerEye != null)
                            iinnerEye.geometry = geometry;
                        outerEye.scale.set(0.6, 0.6, 0.6);
                        iinnerEye.scale.set(0.0, 0.0, 0.0);
                    }
                }
                if (bloomTimer > 25) {
                    bloomTimer = 0;
                    bloomPass.strength = 0;
                    bloomPass.threshold = 1;
                    innerEyeUniforms.cornea_bump_amount.value = 0.0;
                    iinnerEyeUniforms.cornea_bump_amount.value = 0.0;
                }
            } else {
                if (innerEye != null)
                    innerEye.geometry = sphereGeomety;
                if (iinnerEye != null)
                    iinnerEye.geometry = geometry;
            }
            var time = Date.now() * 0.005;
            innerEyeUniforms.pupil_size.value = 0.08 * Math.sin(0.35 * time) + 0.4;
            iinnerEyeUniforms.pupil_size.value = 0.08 * Math.sin(0.35 * time) + 0.4;
            outerEyeUniforms.iris_size.value = 0.005 * Math.cos(0.5 * time) + 0.75;
            var delta = clock.getDelta();
            if (innerEye != null) {
                innerEye.lookAt(camera.position);
                innerEye.rotateOnAxis(new THREE.Vector3(1, 0, 0), mouseY);
                innerEye.rotateOnAxis(new THREE.Vector3(0, 1, 0), mouseX);
            }
            if (iinnerEye != null) {
                iinnerEye.lookAt(camera.position);
                iinnerEye.rotateOnAxis(new THREE.Vector3(1, 0, 0), mouseY);
                iinnerEye.rotateOnAxis(new THREE.Vector3(0, 1, 0), mouseX);
            }
            if (outerEye != null) {
                outerEye.lookAt(camera.position);
                outerEye.rotateOnAxis(new THREE.Vector3(1, 0, 0), mouseY);
                outerEye.rotateOnAxis(new THREE.Vector3(0, 1, 0), mouseX);
            }
            outerEyeRenderer.clear();
            innerEyeRenderer.clear();
            iinnerEyeRenderer.clear();
            outerEyeComposer.render(delta);
            innerEyeComposer.render(delta);
            iinnerEyeComposer.render(delta);
        }
        reqAnim = requestAnimationFrame(render);
    }
}
window.onload = function () {
    if ($('body').hasClass('home'))
        eyeInit();
}
    ;
if ($('html').hasClass('desktop') && $('body').hasClass('home')) {
    var bodyEl = document.getElementsByTagName('head')[0];
    var script = document.createElement('script');
    script.src = themeUrl + '/assets/js/libs/particles.js';
    script.setAttribute('id', 'particles-script');
    bodyEl.appendChild(script);
}
$(function () {
    noformat.init();
    noformat.initOnce();
    $.history({
        swapBox: '#main',
        outerWidth: true,
        direction: 'bottom-to-top',
        inEasing: '',
        outEasing: ''
    });
    $(document).on({
        historyLoadCallback: function () {
            noformat.single.introVideoReady = noformat.single.contentReady = false;
            if (noformat.scroll != null) {
                noformat.scroll.destroy();
                noformat.scroll = null;
                $('.vs-scrollbar').remove();
            }
        },
        historySwapCallback: function () {
            if ($('html').hasClass('desktop') && $('body').hasClass('single')) {
                noformat.scroll = new Smooth({
                    native: false,
                    section: document.querySelector('.single-holder')
                });
                noformat.scroll.init();
            } else if ($('html').hasClass('desktop') && $('body').hasClass('page-template-page-work')) {
                noformat.scroll = new Smooth({
                    native: false,
                    section: document.querySelector('.work-grid')
                });
                noformat.scroll.init();
                noformat.work.resize();
            }
            if ($('body').hasClass('home')) {
                eyeVisible = true;
                eyeInit();
                if ($('html').hasClass('desktop')) {
                    var bodyEl = document.getElementsByTagName('body')[0];
                    var script = document.createElement('script');
                    script.setAttribute('id', 'particles-script');
                    script.src = themeUrl + '/assets/js/libs/particles.js';
                    bodyEl.appendChild(script);
                }
            } else {
                if ($('html').hasClass('desktop')) {
                    document.getElementById('particles-script').remove();
                }
                eyeVisible = false;
                if (outerEyeRenderer != null) {
                    outerEyeRenderer.clear();
                    innerEyeRenderer.clearTarget();
                    iinnerEyeRenderer.clearTarget();
                    outerEyeRenderer.clear();
                    innerEyeRenderer.clearTarget();
                    iinnerEyeRenderer.clearTarget();
                    outerEyeRenderer.dispose();
                    innerEyeRenderer.dispose();
                    iinnerEyeRenderer.dispose();
                    cancelAnimationFrame(reqAnim);
                }
            }
        }
    });
});
$('body').on('click', '.single-intro article', function (e) {
    e.preventDefault();
    $(this).parents('.single-intro').find('.vimeovideo-video-wrapper').trigger('click');
});
$('body').on('click', '.video-wrapper', function (e) {
    var curr = $(this)
        , currIndex = curr.index('.video-wrapper');
    noformat.single.isManuallyPaused[currIndex] = curr.children().hasClass('vimeovideo-playing') ? true : false;
});
$('body').on('click touchend', '.history-btn', function (e) {
    var currUrl = window.location.href
        , curr = $(this);
    if (curr.attr('href') == currUrl) {
        e.preventDefault();
        e.stopImmediatePropagation();
        return false;
    }
    curr.parents('section').hasClass('case-study') ? $.history({
        direction: 'top-to-bottom'
    }) : $.history({
        direction: 'bottom-to-top'
    });
});
!function (a, b) {
    "use strict";
    function c() {
        if (!e) {
            e = !0;
            var a, c, d, f, g = -1 !== navigator.appVersion.indexOf("MSIE 10"), h = !!navigator.userAgent.match(/Trident.*rv:11\./), i = b.querySelectorAll("iframe.wp-embedded-content");
            for (c = 0; c < i.length; c++) {
                if (d = i[c],
                    !d.getAttribute("data-secret"))
                    f = Math.random().toString(36).substr(2, 10),
                        d.src += "#?secret=" + f,
                        d.setAttribute("data-secret", f);
                if (g || h)
                    a = d.cloneNode(!0),
                        a.removeAttribute("security"),
                        d.parentNode.replaceChild(a, d)
            }
        }
    }
    var d = !1
        , e = !1;
    if (b.querySelector)
        if (a.addEventListener)
            d = !0;
    if (a.wp = a.wp || {},
        !a.wp.receiveEmbedMessage)
        if (a.wp.receiveEmbedMessage = function (c) {
            var d = c.data;
            if (d.secret || d.message || d.value)
                if (!/[^a-zA-Z0-9]/.test(d.secret)) {
                    var e, f, g, h, i, j = b.querySelectorAll('iframe[data-secret="' + d.secret + '"]'), k = b.querySelectorAll('blockquote[data-secret="' + d.secret + '"]');
                    for (e = 0; e < k.length; e++)
                        k[e].style.display = "none";
                    for (e = 0; e < j.length; e++)
                        if (f = j[e],
                            c.source === f.contentWindow) {
                            if (f.removeAttribute("style"),
                                "height" === d.message) {
                                if (g = parseInt(d.value, 10),
                                    g > 1e3)
                                    g = 1e3;
                                else if (~~g < 200)
                                    g = 200;
                                f.height = g
                            }
                            if ("link" === d.message)
                                if (h = b.createElement("a"),
                                    i = b.createElement("a"),
                                    h.href = f.getAttribute("src"),
                                    i.href = d.value,
                                    i.host === h.host)
                                    if (b.activeElement === f)
                                        a.top.location.href = d.value
                        } else
                            ;
                }
        }
            ,
            d)
            a.addEventListener("message", a.wp.receiveEmbedMessage, !1),
                b.addEventListener("DOMContentLoaded", c, !1),
                a.addEventListener("load", c, !1)
}(window, document);
